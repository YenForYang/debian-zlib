Intel(R) Advisor can now assist with vectorization and show optimization
  report messages with your source code.
See "https://software.intel.com/en-us/intel-advisor-xe" for details.

Intel(R) C Intel(R) 64 Compiler for applications running on Intel(R) 64, Version 19.0.1.144 Build 20181018

Compiler options: -O3 -diag-disable=10013,10385,10237,10346 -fabi-version=13 -falign-functions -falign-loops -fbuiltin -fdata-sections -ffunction-sections -ffat-lto-objects -fpermissive -gcc-name=gcc.intel -gnu-prefix=x86_64-linux-gnu- -gxx-name=g++.intel -inline-level=2 -inline-min-caller-growth=0 -ipo -march=native -no-inline-max-per-compile -no-inline-max-per-routine -no-inline-max-size -no-inline-max-total-size -par-schedule-auto -parallel -qopt-matmul -qopt-mem-layout-trans -qopt-multi-version-aggressive -qopt-prefetch -qoverride-limits -static-intel -qopt-report=5 -qno-opt-report-embed -shared -g -Wformat -Wformat-security -D_FORTIFY_SOURCE=2 -Wall -D_REENTRANT -O3 -DUNALIGNED_OK -fpic -D_LARGEFILE64_SOURCE=1 -olibz.so.1.2.11 -qopt-report-file=libz.so.1.2.11.optrpt -lc -Wl,--as-needed,--relax,--gc-sections,-O,2 -pipe

    Report from: Interprocedural optimizations [ipo]

  WHOLE PROGRAM (SAFE) [EITHER METHOD]: false
  WHOLE PROGRAM (SEEN) [TABLE METHOD]: false
  WHOLE PROGRAM (READ) [OBJECT READER METHOD]: false

INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: disabled (user-specified)
  -inline-max-total-size: disabled (user-specified)
  -inline-max-per-routine: disabled (user-specified)
  -inline-max-per-compile: disabled (user-specified)

In the inlining report below:
   "sz" refers to the "size" of the routine. The smaller a routine's size,
      the more likely it is to be inlined.
   "isz" refers to the "inlined size" of the routine. This is the amount
      the calling routine will grow if the called routine is inlined into it.
      The compiler generally limits the amount a routine can grow by having
      routines inlined into it.

Begin optimization report for: adler32_z()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (adler32_z()) [1/166=0.6%] adler32.c(67,1)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at adler32.c(92,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (93:13) and adler (93:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (93:13) and adler (93:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (93:13) and adler (93:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (93:13) and adler (93:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(92,9)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(103,5)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (107:13) and adler (110:9)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (110:9) and adler (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (110:9) and adler (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (107:13) and adler (110:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (110:9)
   remark #15346: vector dependence: assumed FLOW dependence between adler (110:9) and adler (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (110:9) and adler (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (110:9)

   LOOP BEGIN at adler32.c(105,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #17106: parallel dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #17106: parallel dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #17106: parallel dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9)
<Remainder>
LOOP END

    Report from: Code generation optimizations [cg]

adler32.c(67,1):remark #34051: REGISTER ALLOCATION : [adler32_z] adler32.c:67

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   11[ rax rdx rcx rbx rbp rsi rdi r8-r11]
        
    Routine temporaries
        Total         :     202
            Global    :      31
            Local     :     171
        Regenerable   :       6
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      16 bytes*
            Reads     :       2 [1.62e-01 ~ 0.0%]
            Writes    :       2 [1.62e-01 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: adler32_combine()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (adler32_combine()) [2/166=1.2%] adler32.c(176,1)
  -> (177,12) adler32_combine_() (isz = 41) (sz = 53)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

adler32.c(176,1):remark #34051: REGISTER ALLOCATION : [adler32_combine] adler32.c:176

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rdx rsi rdi]
        
    Routine temporaries
        Total         :      15
            Global    :       0
            Local     :      15
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: adler32_combine_()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (adler32_combine_()) [3/166=1.8%] adler32.c(147,1)


    Report from: Code generation optimizations [cg]

adler32.c(147,1):remark #34051: REGISTER ALLOCATION : [adler32_combine_] adler32.c:147

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r8-r11]
        
    Routine temporaries
        Total         :      60
            Global    :      12
            Local     :      48
        Regenerable   :       7
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: adler32_combine64()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (adler32_combine64()) [4/166=2.4%] adler32.c(184,1)
  -> (185,12) adler32_combine_() (isz = 41) (sz = 53)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

adler32.c(184,1):remark #34051: REGISTER ALLOCATION : [adler32_combine64] adler32.c:184

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rdx rsi rdi]
        
    Routine temporaries
        Total         :      15
            Global    :       0
            Local     :      15
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: get_crc_table()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (get_crc_table()) [5/166=3.0%] crc32.c(189,1)


    Report from: Code generation optimizations [cg]

crc32.c(189,1):remark #34051: REGISTER ALLOCATION : [get_crc_table] crc32.c:189

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rax]
        
    Routine temporaries
        Total         :       8
            Global    :       0
            Local     :       8
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: crc32()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (crc32()) [6/166=3.6%] crc32.c(241,1)
  -> (242,12) crc32_z() (isz = 564) (sz = 577)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

crc32.c(241,1):remark #34051: REGISTER ALLOCATION : [crc32] crc32.c:241

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rdx rsi rdi]
        
    Routine temporaries
        Total         :      16
            Global    :       0
            Local     :      16
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: crc32_little()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (crc32_little()) crc32.c(270,1)

===========================================================================

Begin optimization report for: crc32_big()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (crc32_big()) crc32.c(310,1)

===========================================================================

Begin optimization report for: gf2_matrix_times()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gf2_matrix_times()) crc32.c(347,1)

===========================================================================

Begin optimization report for: gf2_matrix_square()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gf2_matrix_square()) crc32.c(364,1)

===========================================================================

Begin optimization report for: crc32_combine_()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (crc32_combine_()) crc32.c(376,1)

===========================================================================

Begin optimization report for: crc32_combine()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (crc32_combine()) [12/166=7.2%] crc32.c(432,1)
  -> INLINE: (433,12) crc32_combine_() (isz = 224) (sz = 236)
    -> INLINE: (395,5) gf2_matrix_square() (isz = 30) (sz = 37)
      -> INLINE: (368,21) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (398,5) gf2_matrix_square() (isz = 30) (sz = 37)
      -> INLINE: (368,21) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (404,9) gf2_matrix_square() (isz = 30) (sz = 37)
      -> INLINE: (368,21) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (406,20) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (414,9) gf2_matrix_square() (isz = 30) (sz = 37)
      -> INLINE: (368,21) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (416,20) gf2_matrix_times() (isz = 15) (sz = 24)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at crc32.c(389,5) inlined into crc32.c(433,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between row (390:9) and row (391:9)
   remark #17106: parallel dependence: assumed FLOW dependence between row (391:9) and row (390:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between row (390:9) and row (391:9)
   remark #15346: vector dependence: assumed FLOW dependence between row (391:9) and row (390:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at crc32.c(389,5) inlined into crc32.c(433,12)
<Remainder>
LOOP END

LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(433,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive   [ crc32.c(351,5) ]
   remark #25015: Estimate of max trip count of loop=32

   LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(433,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END
LOOP END

LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(433,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive   [ crc32.c(351,5) ]
   remark #25015: Estimate of max trip count of loop=32

   LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(433,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END
LOOP END

LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(433,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(433,12)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15541: outer loop was not auto-vectorized: consider using SIMD directive   [ crc32.c(351,5) ]
      remark #25015: Estimate of max trip count of loop=32

      LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(433,12)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
         remark #25478: While Loop Unrolled by 8  
         remark #25015: Estimate of max trip count of loop=4
      LOOP END
   LOOP END

   LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(433,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END

   LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(433,12)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15541: outer loop was not auto-vectorized: consider using SIMD directive   [ crc32.c(351,5) ]
      remark #25015: Estimate of max trip count of loop=32

      LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(433,12)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
         remark #25478: While Loop Unrolled by 8  
         remark #25015: Estimate of max trip count of loop=4
      LOOP END
   LOOP END

   LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(433,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

crc32.c(432,1):remark #34051: REGISTER ALLOCATION : [crc32_combine] crc32.c:432

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r8-r11]
        
    Routine temporaries
        Total         :     124
            Global    :      34
            Local     :      90
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :     512 bytes*
            Reads     :      52 [7.56e+02 ~ 10.7%]
            Writes    :       8 [2.46e+02 ~ 3.5%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: crc32_combine64()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (crc32_combine64()) [13/166=7.8%] crc32.c(440,1)
  -> INLINE: (441,12) crc32_combine_() (isz = 224) (sz = 236)
    -> INLINE: (395,5) gf2_matrix_square() (isz = 30) (sz = 37)
      -> INLINE: (368,21) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (398,5) gf2_matrix_square() (isz = 30) (sz = 37)
      -> INLINE: (368,21) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (404,9) gf2_matrix_square() (isz = 30) (sz = 37)
      -> INLINE: (368,21) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (406,20) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (414,9) gf2_matrix_square() (isz = 30) (sz = 37)
      -> INLINE: (368,21) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (416,20) gf2_matrix_times() (isz = 15) (sz = 24)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at crc32.c(389,5) inlined into crc32.c(441,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between row (390:9) and row (391:9)
   remark #17106: parallel dependence: assumed FLOW dependence between row (391:9) and row (390:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between row (390:9) and row (391:9)
   remark #15346: vector dependence: assumed FLOW dependence between row (391:9) and row (390:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at crc32.c(389,5) inlined into crc32.c(441,12)
<Remainder>
LOOP END

LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(441,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive   [ crc32.c(351,5) ]
   remark #25015: Estimate of max trip count of loop=32

   LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(441,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END
LOOP END

LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(441,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive   [ crc32.c(351,5) ]
   remark #25015: Estimate of max trip count of loop=32

   LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(441,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END
LOOP END

LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(441,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(441,12)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15541: outer loop was not auto-vectorized: consider using SIMD directive   [ crc32.c(351,5) ]
      remark #25015: Estimate of max trip count of loop=32

      LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(441,12)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
         remark #25478: While Loop Unrolled by 8  
         remark #25015: Estimate of max trip count of loop=4
      LOOP END
   LOOP END

   LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(441,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END

   LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(441,12)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15541: outer loop was not auto-vectorized: consider using SIMD directive   [ crc32.c(351,5) ]
      remark #25015: Estimate of max trip count of loop=32

      LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(441,12)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
         remark #25478: While Loop Unrolled by 8  
         remark #25015: Estimate of max trip count of loop=4
      LOOP END
   LOOP END

   LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(441,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

crc32.c(440,1):remark #34051: REGISTER ALLOCATION : [crc32_combine64] crc32.c:440

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r8-r11]
        
    Routine temporaries
        Total         :     124
            Global    :      34
            Local     :      90
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :     512 bytes*
            Reads     :      52 [7.56e+02 ~ 10.7%]
            Writes    :       8 [2.46e+02 ~ 3.5%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflate_stored()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflate_stored()) [14/166=8.4%] deflate.c(1646,1)
  -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
    -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
    -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (1178,23) adler32() (isz = 341) (sz = 352)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> (1786,9) read_buf() (isz = 46) (sz = 58)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (1810,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(1658,21)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(1646,1):remark #34051: REGISTER ALLOCATION : [deflate_stored] deflate.c:1646

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   15[ rax rdx rcx rbx rbp rsi rdi r8-r15]
        
    Routine temporaries
        Total         :     220
            Global    :      60
            Local     :     160
        Regenerable   :       6
        Spilled       :      12
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      56 bytes*
            Reads     :      25 [7.45e+00 ~ 2.9%]
            Writes    :       7 [5.12e+00 ~ 2.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflate_fast()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflate_fast()) [15/166=9.0%] deflate.c(1827,1)
  -> (1838,13) fill_window() (isz = 308) (sz = 313)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> (1861,31) longest_match() (isz = 187) (sz = 197)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (1908,21) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (1908,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
    -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
    -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
      -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
    -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
      -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
      -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
    -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
    -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
       [[ Callee not marked with inlining pragma  <1>]]
    -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (1912,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (1912,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (1916,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
    -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
    -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
      -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
    -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
      -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
      -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
    -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
    -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
       [[ Callee not marked with inlining pragma  <1>]]
    -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (1916,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(1876,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between s->strstart (1880:21) and s->window[s->strstart+2] (1881:21)
   remark #17106: parallel dependence: assumed ANTI dependence between s->window[s->strstart+2] (1881:21) and s->strstart (1880:21)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between s->strstart (1880:21) and s->window[s->strstart+2] (1881:21)
   remark #15346: vector dependence: assumed ANTI dependence between s->window[s->strstart+2] (1881:21) and s->strstart (1880:21)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at deflate.c(1876,13)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1908,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1908,21)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1908,21)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1908,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1908,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1908,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1908,21)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1908,21)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1908,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1908,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1908,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1908,21)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1908,21)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1908,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1908,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(1908,21)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1908,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1908,21)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1908,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1908,21)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(1908,21)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(1908,21)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1916,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1916,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1916,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1916,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1916,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1916,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1916,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->static_len (650:34) and s->static_len (650:34)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->static_len (650:34) and s->static_len (650:34)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1916,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1916,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(523,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1916,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1916,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1916,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1916,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1916,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1916,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1916,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(1916,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1916,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1916,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1916,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1916,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(1916,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(1916,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at deflate.c(1908,9)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at trees.c(1143,5) inlined into deflate.c(1908,21)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1143,5) inlined into deflate.c(1916,9)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(1827,1):remark #34051: REGISTER ALLOCATION : [deflate_fast] deflate.c:1827

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    4301
            Global    :    1094
            Local     :    3207
        Regenerable   :     144
        Spilled       :     132
        
    Routine stack
        Variables     :     192 bytes*
            Reads     :       6 [8.79e+00 ~ 0.0%]
            Writes    :      96 [1.29e+02 ~ 0.6%]
        Spills        :     984 bytes*
            Reads     :     296 [6.93e+02 ~ 3.1%]
            Writes    :     242 [8.51e+02 ~ 3.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: fill_window()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (fill_window()) [16/166=9.6%] deflate.c(1484,1)
  -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
  -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
    -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (1178,23) adler32() (isz = 341) (sz = 352)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(1492,48)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1516,13)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1516,13)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1516,13)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1516,13)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1516,13)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1516,13)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
deflate.c(1484,1):remark #34051: REGISTER ALLOCATION : [fill_window] deflate.c:1484

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :     212
            Global    :      63
            Local     :     149
        Regenerable   :       5
        Spilled       :      13
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      80 bytes*
            Reads     :      21 [1.46e+01 ~ 3.3%]
            Writes    :      10 [8.79e+00 ~ 2.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: longest_match()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (longest_match()) [17/166=10.2%] deflate.c(1239,1)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(1279,42)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable

   LOOP BEGIN at deflate.c(1314,48)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable match was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

deflate.c(1239,1):remark #34051: REGISTER ALLOCATION : [longest_match] deflate.c:1239

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   15[ rax rdx rcx rbx rbp rsi rdi r8-r15]
        
    Routine temporaries
        Total         :      64
            Global    :      25
            Local     :      39
        Regenerable   :       1
        Spilled       :       9
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      24 bytes*
            Reads     :       5 [1.69e+00 ~ 1.3%]
            Writes    :       3 [3.00e+00 ~ 2.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflate_slow()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflate_slow()) [18/166=10.8%] deflate.c(1929,1)
  -> INLINE: (1941,13) fill_window() (isz = 308) (sz = 313)
    -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
    -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
      -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1178,23) adler32() (isz = 341) (sz = 352)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
  -> INLINE: (1967,31) longest_match() (isz = 187) (sz = 197)
  -> INLINE: (2011,25) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> (2011,25) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (2021,17) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
    -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
    -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
      -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
    -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
      -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
      -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
    -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
    -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
       [[ Callee not marked with inlining pragma  <1>]]
    -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (2021,17) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> (2043,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (2043,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> (2047,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> (2047,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(1487,18) inlined into deflate.c(1941,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1941,13)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1941,13)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1941,13)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1941,13)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1941,13)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1941,13)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into deflate.c(1941,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(1279,42) inlined into deflate.c(1967,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable

   LOOP BEGIN at deflate.c(1314,48) inlined into deflate.c(1967,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable match was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2003,23)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2021,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2021,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2021,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2021,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2021,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2021,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2021,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2021,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2021,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2021,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2021,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2021,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2021,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2021,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2021,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(2021,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2021,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2021,17)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2021,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2021,17)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(2021,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(2021,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at deflate.c(2011,13)
   remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at trees.c(1143,5) inlined into deflate.c(2021,17)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(1929,1):remark #34051: REGISTER ALLOCATION : [deflate_slow] deflate.c:1929

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :    2516
            Global    :     647
            Local     :    1869
        Regenerable   :      87
        Spilled       :      76
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [3.14e+00 ~ 0.0%]
            Writes    :      48 [4.59e+01 ~ 0.5%]
        Spills        :     552 bytes*
            Reads     :     166 [2.57e+02 ~ 2.9%]
            Writes    :     129 [3.09e+02 ~ 3.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: memcpy(void *__restrict__, const void *__restrict__, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (memcpy(void *__restrict__, const void *__restrict__, size_t))/usr/include/x86_64-linux-gnu/bits/string_fortified.h(33,1)

===========================================================================

Begin optimization report for: memset(void *, int, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (memset(void *, int, size_t))/usr/include/x86_64-linux-gnu/bits/string_fortified.h(60,1)

===========================================================================

Begin optimization report for: _tr_flush_bits(deflate_state *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (_tr_flush_bits(deflate_state *)) [21/166=12.7%] trees.c(888,1)
  -> (889,5) bi_flush() (isz = 61) (sz = 66)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

trees.c(888,1):remark #34051: REGISTER ALLOCATION : [_tr_flush_bits] trees.c:888

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rdi]
        
    Routine temporaries
        Total         :       9
            Global    :       0
            Local     :       9
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: slide_hash()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (slide_hash()) deflate.c(203,1)

===========================================================================

Begin optimization report for: deflateSetDictionary()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateSetDictionary()) [23/166=13.9%] deflate.c(380,1)
  -> (387,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (396,23) adler32() (isz = 341) (sz = 352)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (402,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
  -> INLINE: (416,5) fill_window() (isz = 308) (sz = 313)
    -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
    -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
      -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1178,23) adler32() (isz = 341) (sz = 352)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
  -> INLINE: (430,9) fill_window() (isz = 308) (sz = 313)
    -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
    -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
      -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1178,23) adler32() (isz = 341) (sz = 352)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(1492,67) inlined into deflate.c(416,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(416,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(416,5)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(416,5)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(416,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(416,5)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(416,5)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into deflate.c(416,5)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(417,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(423,40)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at deflate.c(1487,18) inlined into deflate.c(430,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(430,9)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=7
      LOOP END

      LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(430,9)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #25453: Loop Reversed
         remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
         remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 1.667
         remark #15301: REVERSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 8 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 4.370 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(430,9)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(430,9)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=7
      LOOP END

      LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(430,9)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #25453: Loop Reversed
         remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
         remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 1.667
         remark #15301: REVERSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 8 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 4.370 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(430,9)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at deflate.c(1545,13) inlined into deflate.c(430,9)
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
         remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
         remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
deflate.c(380,1):remark #34051: REGISTER ALLOCATION : [deflateSetDictionary] deflate.c:380

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :     479
            Global    :     138
            Local     :     341
        Regenerable   :      13
        Spilled       :      23
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :     136 bytes*
            Reads     :      34 [1.73e+01 ~ 2.5%]
            Writes    :      21 [1.39e+01 ~ 2.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateGetDictionary()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateGetDictionary()) [24/166=14.5%] deflate.c(449,1)
  -> (453,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (460,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(449,1):remark #34051: REGISTER ALLOCATION : [deflateGetDictionary] deflate.c:449

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r8 r12-r14]
        
    Routine temporaries
        Total         :      32
            Global    :      14
            Local     :      18
        Regenerable   :       2
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateReset()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateReset()) [25/166=15.1%] deflate.c(507,1)
  -> (510,11) deflateResetKeep() (isz = 397) (sz = 405)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (512,9) lm_init() (isz = 55) (sz = 60)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

deflate.c(507,1):remark #34051: REGISTER ALLOCATION : [deflateReset] deflate.c:507

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdi r13-r14]
        
    Routine temporaries
        Total         :      14
            Global    :       9
            Local     :       5
        Regenerable   :       0
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateResetKeep()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateResetKeep()) [26/166=15.7%] deflate.c(469,1)
  -> (472,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (494,24) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (496,9) adler32() (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> (499,5) _tr_init(deflate_state *) (isz = 26) (sz = 31)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

deflate.c(469,1):remark #34051: REGISTER ALLOCATION : [deflateResetKeep] deflate.c:469

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rcx rbx rsi rdi r15]
        
    Routine temporaries
        Total         :      31
            Global    :      12
            Local     :      19
        Regenerable   :       8
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateSetHeader()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateSetHeader()) [27/166=16.3%] deflate.c(520,1)
  -> (521,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

deflate.c(520,1):remark #34051: REGISTER ALLOCATION : [deflateSetHeader] deflate.c:520

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    5[ rax rbx rbp rsi rdi]
        
    Routine temporaries
        Total         :      16
            Global    :      10
            Local     :       6
        Regenerable   :       2
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflatePending()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflatePending()) [28/166=16.9%] deflate.c(532,1)
  -> (533,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

deflate.c(532,1):remark #34051: REGISTER ALLOCATION : [deflatePending] deflate.c:532

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rsi rdi r12-r14]
        
    Routine temporaries
        Total         :      21
            Global    :      10
            Local     :      11
        Regenerable   :       2
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflatePrime()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflatePrime()) [29/166=17.5%] deflate.c(546,1)
  -> (550,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (560,9) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
    -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(552,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

    Report from: Code generation optimizations [cg]

deflate.c(546,1):remark #34051: REGISTER ALLOCATION : [deflatePrime] deflate.c:546

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r12-r15]
        
    Routine temporaries
        Total         :      35
            Global    :      13
            Local     :      22
        Regenerable   :       4
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       8 bytes*
            Reads     :       1 [6.90e-01 ~ 0.6%]
            Writes    :       1 [6.90e-01 ~ 0.6%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateTune()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateTune()) [30/166=18.1%] deflate.c(623,1)
  -> (626,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

deflate.c(623,1):remark #34051: REGISTER ALLOCATION : [deflateTune] deflate.c:623

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   11[ rax rdx rcx rbx rbp rsi rdi r8 r13-r15]
        
    Routine temporaries
        Total         :      22
            Global    :      13
            Local     :       9
        Regenerable   :       0
        Spilled       :       5
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateBound()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateBound()) [31/166=18.7%] deflate.c(655,1)
  -> (664,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(684,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable str was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at deflate.c(689,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable str was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

    Report from: Code generation optimizations [cg]

deflate.c(655,1):remark #34051: REGISTER ALLOCATION : [deflateBound] deflate.c:655

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rbx rsi rdi r8 r14-r15]
        
    Routine temporaries
        Total         :      47
            Global    :      20
            Local     :      27
        Regenerable   :       2
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: putShortMSB()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (putShortMSB()) deflate.c(719,1)

===========================================================================

Begin optimization report for: deflate()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflate()) [33/166=19.9%] deflate.c(766,1)
  -> (770,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (787,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (831,9) putShortMSB() (isz = 23) (sz = 30)
  -> INLINE: (835,13) putShortMSB() (isz = 23) (sz = 30)
  -> INLINE: (836,13) putShortMSB() (isz = 23) (sz = 30)
  -> INLINE: (838,23) adler32() (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> (842,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (851,23) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (868,13) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (894,31) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (909,17) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (911,17) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (922,13) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (933,21) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (934,21) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (944,13) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (955,21) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (956,21) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (966,13) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (973,17) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (981,27) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (986,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1000,34) deflate_stored() (isz = 676) (sz = 687)
    -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
      -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
      -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1178,23) adler32() (isz = 341) (sz = 352)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (1786,9) read_buf() (isz = 46) (sz = 58)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (1810,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (1001,50) deflate_huff() (isz = 11827) (sz = 11841)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (1002,41) deflate_rle() (isz = 6524) (sz = 6538)
    -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
      -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
      -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
        -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1178,23) adler32() (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
      -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
      -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
      -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
      -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
        -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
        -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
        -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
      -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
      -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
        -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
        -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
      -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
      -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
         [[ Callee not marked with inlining pragma  <1>]]
      -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (2118,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> (2118,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (2122,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (2122,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
       [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INDIRECT: (1003,18)  func_V$11_2.0.3[(EXPR_CONV.SI32.SI64(s.776_V$d4.3.37->level_V$3f))]
     [[ Callee not marked with inlining pragma  <1>]]
  -> (1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
    -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
  -> (1038,13) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1064,9) putShortMSB() (isz = 23) (sz = 30)
  -> INLINE: (1065,9) putShortMSB() (isz = 23) (sz = 30)
  -> (1067,5) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(904,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into deflate.c(1000,34)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into deflate.c(1002,41)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1002,41)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1002,41)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1002,41)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1002,41)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1002,41)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1002,41)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into deflate.c(1002,41)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1002,41)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1002,41)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1002,41)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(1002,41)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1002,41)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1002,41)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(1002,41)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(1002,41)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at deflate.c(2114,9) inlined into deflate.c(1002,41)
   remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at trees.c(1143,5) inlined into deflate.c(1002,41)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(766,1):remark #34051: REGISTER ALLOCATION : [deflate] deflate.c:766

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :    2958
            Global    :     732
            Local     :    2226
        Regenerable   :     125
        Spilled       :      74
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [1.28e-01 ~ 0.0%]
            Writes    :      48 [1.87e+00 ~ 0.5%]
        Spills        :     536 bytes*
            Reads     :     179 [1.01e+01 ~ 2.6%]
            Writes    :     129 [1.25e+01 ~ 3.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateCopy()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateCopy()) [34/166=20.5%] deflate.c(1105,1)
  -> (1114,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (1120,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INDIRECT-: (1122,28)  dest_958_V$102.3.39->zalloc_V$87
     [[ Unable to inline indirect callsite  <3>]]
  -> INLINE (MANUAL): (1125,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INDIRECT-: (1128,28)  dest_958_V$102.3.39->zalloc_V$87
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1129,28)  dest_958_V$102.3.39->zalloc_V$87
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1130,28)  dest_958_V$102.3.39->zalloc_V$87
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1131,24)  dest_958_V$102.3.39->zalloc_V$87
     [[ Unable to inline indirect callsite  <3>]]
  -> (1136,9) deflateEnd() (isz = 63) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (1140,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1141,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1142,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1143,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to increase the width of loads
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(1105,1):remark #34051: REGISTER ALLOCATION : [deflateCopy] deflate.c:1105

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   18[ rax rdx rcx rsi rdi r8-r9 r12-r15 zmm0-zmm6]
        
    Routine temporaries
        Total         :     104
            Global    :      23
            Local     :      81
        Regenerable   :      11
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateEnd()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateEnd()) [35/166=21.1%] deflate.c(1078,1)
  -> (1081,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (1086,5)  strm_943_V$100.3.38->zfree_V$88
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1087,5)  strm_943_V$100.3.38->zfree_V$88
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1088,5)  strm_943_V$100.3.38->zfree_V$88
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1089,5)  strm_943_V$100.3.38->zfree_V$88
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1091,5)  strm_943_V$100.3.38->zfree_V$88
     [[ Unable to inline indirect callsite  <3>]]


    Report from: Code generation optimizations [cg]

deflate.c(1078,1):remark #34051: REGISTER ALLOCATION : [deflateEnd] deflate.c:1078

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rbp rsi rdi r12]
        
    Routine temporaries
        Total         :      37
            Global    :      14
            Local     :      23
        Regenerable   :       3
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflate_rle()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (deflate_rle()) deflate.c(2060,1)

===========================================================================

Begin optimization report for: zcfree(voidpf, voidpf)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (zcfree(voidpf, voidpf)) [37/166=22.3%] zutil.c(318,1)
  -> EXTERN: (320,5) free(void *)


    Report from: Code generation optimizations [cg]

zutil.c(318,1):remark #34051: REGISTER ALLOCATION : [zcfree] zutil.c:318

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rsi rdi]
        
    Routine temporaries
        Total         :      10
            Global    :       0
            Local     :      10
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: zcalloc(voidpf, unsigned int, unsigned int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (zcalloc(voidpf, unsigned int, unsigned int)) [38/166=22.9%] zutil.c(309,1)
  -> EXTERN: (311,39) malloc(size_t)


    Report from: Code generation optimizations [cg]

zutil.c(309,1):remark #34051: REGISTER ALLOCATION : [zcalloc] zutil.c:309

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rdx rsi rdi]
        
    Routine temporaries
        Total         :      14
            Global    :       0
            Local     :      14
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: memcpy(void *__restrict__, const void *__restrict__, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (memcpy(void *__restrict__, const void *__restrict__, size_t))/usr/include/x86_64-linux-gnu/bits/string_fortified.h(33,1)

===========================================================================

Begin optimization report for: inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *)) [40/166=24.1%] inftrees.c(39,1)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inftrees.c(107,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between left (134:9) and left (134:9)
   remark #17106: parallel dependence: assumed FLOW dependence between left (134:9) and left (134:9)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(135,30) ]
LOOP END

LOOP BEGIN at inftrees.c(142,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(39,1):remark #34051: REGISTER ALLOCATION : [inflate_table] inftrees.c:39

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :     216
            Global    :      77
            Local     :     139
        Regenerable   :      10
        Spilled       :      35
        
    Routine stack
        Variables     :      68 bytes*
            Reads     :      28 [1.91e+01 ~ 7.9%]
            Writes    :      37 [1.39e+01 ~ 5.7%]
        Spills        :     208 bytes*
            Reads     :      67 [8.14e+00 ~ 3.3%]
            Writes    :      41 [4.75e+00 ~ 2.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflate_fast(z_streamp, unsigned int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflate_fast(z_streamp, unsigned int)) [41/166=24.7%] inffast.c(53,1)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inffast.c(147,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at inffast.c(290,19)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at inffast.c(277,20)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(53,1):remark #34051: REGISTER ALLOCATION : [inflate_fast] inffast.c:53

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   15[ rax rdx rcx rbx rbp rsi rdi r8-r15]
        
    Routine temporaries
        Total         :     249
            Global    :      61
            Local     :     188
        Regenerable   :       9
        Spilled       :      26
        
    Routine stack
        Variables     :       4 bytes*
            Reads     :       7 [1.42e+01 ~ 4.6%]
            Writes    :       4 [7.02e+00 ~ 2.3%]
        Spills        :     152 bytes*
            Reads     :      49 [5.61e+00 ~ 1.8%]
            Writes    :      23 [1.41e+01 ~ 4.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: fixedtables()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (fixedtables()) infback.c(84,1)

===========================================================================

Begin optimization report for: inflateBack()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateBack()) [43/166=25.9%] infback.c(256,1)
  -> INDIRECT-: (299,13)  in_627_V$51.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (309,17) fixedtables() (isz = 10) (sz = 15)
  -> INDIRECT-: (329,13)  in_627_V$51.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (343,17)  in_627_V$51.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (344,17)  out_627_V$53.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (347,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INDIRECT-: (360,13)  in_627_V$51.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (379,17)  in_627_V$51.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (388,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
  -> INDIRECT-: (403,21)  in_627_V$51.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (411,25)  in_627_V$51.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (423,25)  in_627_V$51.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (430,25)  in_627_V$51.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (462,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
  -> INLINE: (471,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
  -> INLINE: (487,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
  -> INDIRECT-: (496,17)  in_627_V$51.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (504,21)  in_627_V$51.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (516,17)  out_627_V$53.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (540,17)  in_627_V$51.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (550,17)  in_627_V$51.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (558,21)  in_627_V$51.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (573,17)  in_627_V$51.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (587,17)  out_627_V$53.4.49
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (610,21)  out_627_V$53.4.49
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inffast.c(147,13) inlined into infback.c(487,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into infback.c(487,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into infback.c(487,17)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into infback.c(487,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into infback.c(487,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into infback.c(487,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into infback.c(487,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into infback.c(487,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into infback.c(487,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into infback.c(487,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into infback.c(487,17)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into infback.c(487,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into infback.c(487,17)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into infback.c(487,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at infback.c(502,30)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at infback.c(540,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at infback.c(556,30)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at infback.c(573,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at infback.c(577,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification

   LOOP BEGIN at infback.c(599,17)
      remark #25401: memcopy(with guard) generated
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between *from (599:17) and *put (601:22)
      remark #17106: parallel dependence: assumed FLOW dependence between *put (601:22) and *from (599:17)
      remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

      LOOP BEGIN at infback.c(599,17)
      <Multiversioned v2>
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed FLOW dependence between *put (601:22) and *from (601:22)
         remark #17106: parallel dependence: assumed ANTI dependence between *from (601:22) and *put (601:22)
         remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
         remark #25439: unrolled with remainder by 2  
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      LOOP END

      LOOP BEGIN at infback.c(599,17)
      <Remainder, Multiversioned v2>
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at infback.c(360,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at infback.c(378,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification

   LOOP BEGIN at infback.c(379,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
   LOOP END
LOOP END

LOOP BEGIN at infback.c(383,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ infback.c(384,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between strm->state->lens[order[state->have]] (384:17) and strm->state->lens[order[state->have]] (384:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between strm->state->lens[order[state->have]] (384:17) and strm->state->lens[order[state->have]] (384:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ infback.c(384,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <strm->state->lens[order[state->have]]>, part of index is read from memory   [ infback.c(384,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at infback.c(383,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into infback.c(388,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into infback.c(388,19)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into infback.c(388,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
   remark #25015: Estimate of max trip count of loop=15
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into infback.c(388,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into infback.c(388,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into infback.c(388,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into infback.c(388,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into infback.c(388,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into infback.c(388,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into infback.c(388,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at infback.c(399,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at infback.c(411,25)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
   LOOP END

   LOOP BEGIN at infback.c(423,25)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
   LOOP END

   LOOP BEGIN at infback.c(430,25)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
   LOOP END

   LOOP BEGIN at infback.c(441,21)
   <Peeled loop for vectorization>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at infback.c(441,21)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ infback.c(442,37) ]
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15388: vectorization support: reference strm->state->lens[state->have] has aligned access   [ infback.c(442,25) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 4.500
      remark #15300: LOOP WAS VECTORIZED
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 3 
      remark #15477: vector cost: 0.500 
      remark #15478: estimated potential speedup: 4.840 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=40
   LOOP END

   LOOP BEGIN at infback.c(441,21)
   <Remainder loop for vectorization>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      remark #25015: Estimate of max trip count of loop=320
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into infback.c(462,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into infback.c(462,19)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into infback.c(462,19)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into infback.c(462,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into infback.c(462,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into infback.c(462,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into infback.c(462,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into infback.c(462,19)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into infback.c(462,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into infback.c(462,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into infback.c(462,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into infback.c(462,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into infback.c(471,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into infback.c(471,19)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into infback.c(471,19)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into infback.c(471,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into infback.c(471,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into infback.c(471,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into infback.c(471,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into infback.c(471,19)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into infback.c(471,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into infback.c(471,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into infback.c(471,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into infback.c(471,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at infback.c(329,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at infback.c(341,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at infback.c(299,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at infback.c(488,17)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at inffast.c(290,19) inlined into infback.c(487,17)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inffast.c(277,20) inlined into infback.c(487,17)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END

   LOOP BEGIN at infback.c(496,17)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at infback.c(550,17)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inftrees.c(132,5) inlined into infback.c(388,19)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inftrees.c(132,5) inlined into infback.c(462,19)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inftrees.c(132,5) inlined into infback.c(471,19)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
infback.c(494,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
infback.c(401,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
infback.c(499,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
infback.c(501,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
infback.c(548,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
infback.c(599,17):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
infback.c(599,17):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
infback.c(599,17):remark #34026: call to memcpy implemented as a call to optimized library version
infback.c(553,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
infback.c(555,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
infback.c(256,1):remark #34051: REGISTER ALLOCATION : [inflateBack] infback.c:256

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1284
            Global    :     329
            Local     :     955
        Regenerable   :      79
        Spilled       :      80
        
    Routine stack
        Variables     :     224 bytes*
            Reads     :     171 [7.26e+00 ~ 2.9%]
            Writes    :     181 [9.45e+00 ~ 3.8%]
        Spills        :     576 bytes*
            Reads     :     383 [8.36e+00 ~ 3.4%]
            Writes    :     179 [1.20e+01 ~ 4.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateBackEnd()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateBackEnd()) [44/166=26.5%] infback.c(633,1)
  -> INDIRECT-: (636,5)  strm_954_V$7c.4.50->zfree_V$88
     [[ Unable to inline indirect callsite  <3>]]


    Report from: Code generation optimizations [cg]

infback.c(633,1):remark #34051: REGISTER ALLOCATION : [inflateBackEnd] infback.c:633

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rbp rsi rdi]
        
    Routine temporaries
        Total         :      15
            Global    :       9
            Local     :       6
        Regenerable   :       2
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: memcpy(void *__restrict__, const void *__restrict__, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (memcpy(void *__restrict__, const void *__restrict__, size_t))/usr/include/x86_64-linux-gnu/bits/string_fortified.h(33,1)

===========================================================================

Begin optimization report for: inflateStateCheck()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (inflateStateCheck()) inflate.c(107,1)

===========================================================================

Begin optimization report for: inflatePrime()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflatePrime()) [47/166=28.3%] inflate.c(251,1)
  -> INLINE: (254,9) inflateStateCheck() (isz = 25) (sz = 34)


    Report from: Code generation optimizations [cg]

inflate.c(251,1):remark #34051: REGISTER ALLOCATION : [inflatePrime] inflate.c:251

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rcx rsi rdi r8-r9]
        
    Routine temporaries
        Total         :      30
            Global    :      13
            Local     :      17
        Regenerable   :       5
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: fixedtables()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (fixedtables()) inflate.c(280,1)

===========================================================================

Begin optimization report for: inflate()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflate()) [49/166=29.5%] inflate.c(625,1)
  -> INLINE: (645,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> INLINE: (667,32) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (668,17) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (701,42) adler32() (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> INLINE: (722,17) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (730,17) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (740,17) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (750,21) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (769,40) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (790,36) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (811,36) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (833,42) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (847,42) adler32() (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> INLINE: (867,17) fixedtables() (isz = 10) (sz = 15)
  -> INLINE (MANUAL): (909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
  -> INLINE: (1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
  -> INLINE: (1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
  -> INLINE: (1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
  -> INLINE: (1205,25) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1205,25) adler32() (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> (1257,13) updatewindow() (isz = 101) (sz = 113)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1268,13) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (1268,13) adler32() (isz = 341) (sz = 352)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inflate.c(1223,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into inflate.c(1205,25)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into inflate.c(1205,25)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into inflate.c(1205,25)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into inflate.c(1205,25)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into inflate.c(1205,25)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into inflate.c(1205,25)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into inflate.c(1047,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into inflate.c(1047,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into inflate.c(1047,17)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into inflate.c(1047,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into inflate.c(1047,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into inflate.c(1047,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into inflate.c(1047,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into inflate.c(1047,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into inflate.c(1047,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into inflate.c(1047,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into inflate.c(1047,17)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into inflate.c(1047,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into inflate.c(1047,17)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into inflate.c(1047,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into inflate.c(1023,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into inflate.c(1023,19)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into inflate.c(1023,19)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into inflate.c(1023,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into inflate.c(1023,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into inflate.c(1023,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into inflate.c(1023,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into inflate.c(1023,19)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into inflate.c(1023,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into inflate.c(1023,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into inflate.c(1023,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into inflate.c(1023,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into inflate.c(1032,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into inflate.c(1032,19)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into inflate.c(1032,19)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into inflate.c(1032,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into inflate.c(1032,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into inflate.c(1032,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into inflate.c(1032,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into inflate.c(1032,19)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into inflate.c(1032,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into inflate.c(1032,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into inflate.c(1032,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into inflate.c(1032,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into inflate.c(949,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into inflate.c(949,19)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into inflate.c(949,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
   remark #25015: Estimate of max trip count of loop=15
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into inflate.c(949,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into inflate.c(949,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into inflate.c(949,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into inflate.c(949,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into inflate.c(949,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into inflate.c(949,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into inflate.c(949,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at inflate.c(1226,21)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at inflate.c(1107,17)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inffast.c(290,19) inlined into inflate.c(1047,17)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inffast.c(277,20) inlined into inflate.c(1047,17)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END

   LOOP BEGIN at inflate.c(1057,17)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inflate.c(960,13)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inftrees.c(132,5) inlined into inflate.c(1023,19)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inftrees.c(132,5) inlined into inflate.c(1032,19)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inflate.c(939,13)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inftrees.c(132,5) inlined into inflate.c(949,19)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(625,1):remark #34051: REGISTER ALLOCATION : [inflate] inflate.c:625

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1638
            Global    :     395
            Local     :    1243
        Regenerable   :      98
        Spilled       :      97
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :     131 [2.94e+00 ~ 1.0%]
            Writes    :     159 [4.04e+00 ~ 1.4%]
        Spills        :     704 bytes*
            Reads     :     557 [4.77e+00 ~ 1.7%]
            Writes    :     173 [7.63e+00 ~ 2.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateGetDictionary()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateGetDictionary()) [50/166=30.1%] inflate.c(1295,1)
  -> INLINE: (1299,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> INLINE (MANUAL): (1304,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1306,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1295,1):remark #34051: REGISTER ALLOCATION : [inflateGetDictionary] inflate.c:1295

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rbp rsi rdi r12-r13]
        
    Routine temporaries
        Total         :      34
            Global    :      12
            Local     :      22
        Regenerable   :       2
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateSetDictionary()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateSetDictionary()) [51/166=30.7%] inflate.c(1318,1)
  -> INLINE: (1324,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> INLINE: (1331,18) adler32() (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> (1332,18) adler32() (isz = 341) (sz = 352)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (1339,11) updatewindow() (isz = 101) (sz = 113)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

inflate.c(1318,1):remark #34051: REGISTER ALLOCATION : [inflateSetDictionary] inflate.c:1318

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rbx rbp rsi rdi r12-r13]
        
    Routine temporaries
        Total         :      31
            Global    :      16
            Local     :      15
        Regenerable   :       4
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateGetHeader()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateGetHeader()) [52/166=31.3%] inflate.c(1352,1)
  -> INLINE: (1356,9) inflateStateCheck() (isz = 25) (sz = 34)


    Report from: Code generation optimizations [cg]

inflate.c(1352,1):remark #34051: REGISTER ALLOCATION : [inflateGetHeader] inflate.c:1352

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      15
            Global    :      11
            Local     :       4
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: syncsearch()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (syncsearch()) inflate.c(1381,1)

===========================================================================

Begin optimization report for: inflateSync()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateSync()) [54/166=32.5%] inflate.c(1402,1)
  -> INLINE: (1409,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> INLINE: (1425,9) syncsearch() (isz = 32) (sz = 43)
  -> INLINE: (1429,11) syncsearch() (isz = 32) (sz = 43)
  -> (1437,5) inflateReset() (isz = 40) (sz = 48)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inflate.c(1419,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1421,13) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1422,13) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between state->hold (1420:13) and state->hold (1421:13)
   remark #17106: parallel dependence: assumed FLOW dependence between state->hold (1421:13) and state->hold (1420:13)
   remark #17106: parallel dependence: assumed FLOW dependence between state->hold (1421:13) and state->hold (1420:13)
   remark #17106: parallel dependence: assumed ANTI dependence between state->hold (1420:13) and state->hold (1421:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between state->hold (1420:13) and state->hold (1421:13)
   remark #15346: vector dependence: assumed FLOW dependence between state->hold (1421:13) and state->hold (1420:13)
   remark #15346: vector dependence: assumed FLOW dependence between state->hold (1421:13) and state->hold (1420:13)
   remark #15346: vector dependence: assumed ANTI dependence between state->hold (1420:13) and state->hold (1421:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
   remark #25457: Number of partial sums replaced: 1
   remark #25015: Estimate of max trip count of loop=4
LOOP END

LOOP BEGIN at inflate.c(1419,9)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=4
LOOP END

LOOP BEGIN at inflate.c(1387,5) inlined into inflate.c(1425,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1389:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1389:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1389:13)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1391:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1391:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1391:13)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1393:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1393:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1393:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inflate.c(1388,9) ]
   remark #25015: Estimate of max trip count of loop=4
LOOP END

LOOP BEGIN at inflate.c(1387,5) inlined into inflate.c(1429,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1389:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1389:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1389:13)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1391:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1391:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1391:13)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1393:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1393:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1393:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inflate.c(1394,9) ]
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1402,1):remark #34051: REGISTER ALLOCATION : [inflateSync] inflate.c:1402

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   13[ rax rdx rcx rbx rbp rsi rdi r8-r11 r14-r15]
        
    Routine temporaries
        Total         :      63
            Global    :      32
            Local     :      31
        Regenerable   :       5
        Spilled       :       4
        
    Routine stack
        Variables     :       4 bytes*
            Reads     :       1 [6.48e-01 ~ 0.6%]
            Writes    :       3 [1.83e+00 ~ 1.7%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateSyncPoint()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateSyncPoint()) [55/166=33.1%] inflate.c(1453,1)
  -> INLINE: (1456,9) inflateStateCheck() (isz = 25) (sz = 34)


    Report from: Code generation optimizations [cg]

inflate.c(1453,1):remark #34051: REGISTER ALLOCATION : [inflateSyncPoint] inflate.c:1453

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rax rdx rdi]
        
    Routine temporaries
        Total         :      14
            Global    :      10
            Local     :       4
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateCopy()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateCopy()) [56/166=33.7%] inflate.c(1464,1)
  -> INLINE: (1471,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> INDIRECT-: (1477,12)  source_1222_V$ca.6.70->zalloc_V$87
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1482,18)  source_1222_V$ca.6.70->zalloc_V$87
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1484,13)  source_1222_V$ca.6.70->zfree_V$88
     [[ Unable to inline indirect callsite  <3>]]
  -> INLINE (MANUAL): (1490,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1491,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1501,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to increase the width of loads
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1464,1):remark #34051: REGISTER ALLOCATION : [inflateCopy] inflate.c:1464

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   18[ rax rdx rcx rbp rsi rdi r8 r12-r15 zmm0-zmm6]
        
    Routine temporaries
        Total         :      69
            Global    :      17
            Local     :      52
        Regenerable   :      10
        Spilled       :       5
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateUndermine()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateUndermine()) [57/166=34.3%] inflate.c(1511,1)
  -> INLINE: (1514,9) inflateStateCheck() (isz = 25) (sz = 34)


    Report from: Code generation optimizations [cg]

inflate.c(1511,1):remark #34051: REGISTER ALLOCATION : [inflateUndermine] inflate.c:1511

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      13
            Global    :       9
            Local     :       4
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateValidate()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateValidate()) [58/166=34.9%] inflate.c(1529,1)
  -> INLINE: (1532,9) inflateStateCheck() (isz = 25) (sz = 34)


    Report from: Code generation optimizations [cg]

inflate.c(1529,1):remark #34051: REGISTER ALLOCATION : [inflateValidate] inflate.c:1529

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      17
            Global    :      11
            Local     :       6
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateMark()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateMark()) [59/166=35.5%] inflate.c(1543,1)
  -> INLINE: (1546,9) inflateStateCheck() (isz = 25) (sz = 34)


    Report from: Code generation optimizations [cg]

inflate.c(1543,1):remark #34051: REGISTER ALLOCATION : [inflateMark] inflate.c:1543

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rcx rdi]
        
    Routine temporaries
        Total         :      18
            Global    :      10
            Local     :       8
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateCodesUsed()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateCodesUsed()) [60/166=36.1%] inflate.c(1556,1)
  -> INLINE: (1558,9) inflateStateCheck() (isz = 25) (sz = 34)


    Report from: Code generation optimizations [cg]

inflate.c(1556,1):remark #34051: REGISTER ALLOCATION : [inflateCodesUsed] inflate.c:1556

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rcx rdi]
        
    Routine temporaries
        Total         :      16
            Global    :       9
            Local     :       7
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: memcpy(void *__restrict__, const void *__restrict__, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (memcpy(void *__restrict__, const void *__restrict__, size_t))/usr/include/x86_64-linux-gnu/bits/string_fortified.h(33,1)

===========================================================================

Begin optimization report for: pqdownheap()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (pqdownheap()) trees.c(455,1)

===========================================================================

Begin optimization report for: gen_bitlen()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gen_bitlen()) trees.c(489,1)

===========================================================================

Begin optimization report for: gen_codes()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gen_codes()) trees.c(576,1)

===========================================================================

Begin optimization report for: build_tree()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (build_tree()) trees.c(618,1)

===========================================================================

Begin optimization report for: scan_tree()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (scan_tree()) trees.c(707,1)

===========================================================================

Begin optimization report for: send_tree()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (send_tree()) trees.c(752,1)

===========================================================================

Begin optimization report for: build_bl_tree()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (build_bl_tree()) trees.c(801,1)

===========================================================================

Begin optimization report for: send_all_trees()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (send_all_trees()) trees.c(837,1)

===========================================================================

Begin optimization report for: _tr_tally()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (_tr_tally()) [70/166=42.2%] trees.c(1018,1)


    Report from: Code generation optimizations [cg]

trees.c(1018,1):remark #34051: REGISTER ALLOCATION : [_tr_tally] trees.c:1018

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rsi rdi r8]
        
    Routine temporaries
        Total         :      33
            Global    :      11
            Local     :      22
        Regenerable   :       4
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: compress_block()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (compress_block()) trees.c(1068,1)

===========================================================================

Begin optimization report for: detect_data_type()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (detect_data_type()) trees.c(1126,1)

===========================================================================

Begin optimization report for: bi_reverse()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (bi_reverse()) trees.c(1161,1)

===========================================================================

Begin optimization report for: zlibVersion()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (zlibVersion()) [74/166=44.6%] zutil.c(28,1)


    Report from: Code generation optimizations [cg]

zutil.c(28,1):remark #34051: REGISTER ALLOCATION : [zlibVersion] zutil.c:28

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rax]
        
    Routine temporaries
        Total         :       8
            Global    :       0
            Local     :       8
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: zlibCompileFlags()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (zlibCompileFlags()) [75/166=45.2%] zutil.c(33,1)


    Report from: Code generation optimizations [cg]

zutil.c(33,1):remark #34051: REGISTER ALLOCATION : [zlibCompileFlags] zutil.c:33

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rax]
        
    Routine temporaries
        Total         :       7
            Global    :       0
            Local     :       7
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: compress2()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (compress2()) [76/166=45.8%] compress.c(28,1)
  -> (41,11) deflateInit_() (isz = 5) (sz = 18)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (58,15) deflate() (isz = 9099) (sz = 9125)
    -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(838,23) adler32() (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(851,23) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(894,31) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(909,17) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(922,13) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(933,21) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(944,13) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(955,21) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(966,13) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(981,27) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
      -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
        -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1178,23) adler32() (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1786,9) read_buf() (isz = 46) (sz = 58)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1810,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
      -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
        -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
        -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32() (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
        -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
        -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
          -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
        -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
          -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
        -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
        -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
           [[ Callee not marked with inlining pragma  <1>]]
        -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
      -> (2118,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (2118,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> (2122,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> (2122,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.3[(EXPR_CONV.SI32.SI64(s.776_V$d4.3.37.1135->level_V$3f))]
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
      -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
    -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (62,5) deflateEnd() (isz = 63) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(904,13) inlined into compress.c(58,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into compress.c(58,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into compress.c(58,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into compress.c(58,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into compress.c(58,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into compress.c(58,15)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into compress.c(58,15)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into compress.c(58,15)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into compress.c(58,15)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into compress.c(58,15)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into compress.c(58,15)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into compress.c(58,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into compress.c(58,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(58,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(58,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into compress.c(58,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into compress.c(58,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into compress.c(58,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(58,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(58,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into compress.c(58,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into compress.c(58,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into compress.c(58,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(58,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(58,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into compress.c(58,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into compress.c(58,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into compress.c(58,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into compress.c(58,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into compress.c(58,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into compress.c(58,15)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into compress.c(58,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into compress.c(58,15)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into compress.c(58,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into compress.c(58,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at compress.c(59,21)
   remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into compress.c(58,15)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into compress.c(58,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
compress.c(28,1):remark #34051: REGISTER ALLOCATION : [compress2] compress.c:28

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    3085
            Global    :     779
            Local     :    2306
        Regenerable   :     114
        Spilled       :      78
        
    Routine stack
        Variables     :     208 bytes*
            Reads     :      54 [2.54e+01 ~ 1.4%]
            Writes    :      80 [3.79e+01 ~ 2.1%]
        Spills        :     576 bytes*
            Reads     :     292 [3.66e+01 ~ 2.0%]
            Writes    :     193 [3.56e+01 ~ 2.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: adler32()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (adler32()) [77/166=46.4%] adler32.c(138,1)
  -> INLINE: (139,12) adler32_z() (isz = 340) (sz = 354)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at adler32.c(103,5) inlined into adler32.c(139,12)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into adler32.c(139,12)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into adler32.c(139,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into adler32.c(139,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into adler32.c(139,12)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into adler32.c(139,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

    Report from: Code generation optimizations [cg]

adler32.c(138,1):remark #34051: REGISTER ALLOCATION : [adler32] adler32.c:138

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   11[ rax rdx rcx rbx rbp rsi rdi r8-r11]
        
    Routine temporaries
        Total         :     194
            Global    :      30
            Local     :     164
        Regenerable   :       4
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      16 bytes*
            Reads     :       2 [1.62e-01 ~ 0.0%]
            Writes    :       2 [1.62e-01 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: bi_flush()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (bi_flush()) [78/166=47.0%] trees.c(1175,1)


    Report from: Code generation optimizations [cg]

trees.c(1175,1):remark #34051: REGISTER ALLOCATION : [bi_flush] trees.c:1175

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rcx rsi rdi r8-r9]
        
    Routine temporaries
        Total         :      21
            Global    :       8
            Local     :      13
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: bi_windup()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (bi_windup()) [79/166=47.6%] trees.c(1192,1)


    Report from: Code generation optimizations [cg]

trees.c(1192,1):remark #34051: REGISTER ALLOCATION : [bi_windup] trees.c:1192

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rsi rdi r8]
        
    Routine temporaries
        Total         :      21
            Global    :       8
            Local     :      13
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: _tr_stored_block(deflate_state *, charf *, ulg, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (_tr_stored_block(deflate_state *, charf *, ulg, int)) [80/166=48.2%] trees.c(868,1)
  -> (870,5) bi_windup() (isz = 51) (sz = 56)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
trees.c(868,1):remark #34051: REGISTER ALLOCATION : [_tr_stored_block] trees.c:868

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   12[ rax rdx rcx rsi rdi r8-r11 r13-r15]
        
    Routine temporaries
        Total         :      49
            Global    :      13
            Local     :      36
        Regenerable   :       0
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: flush_pending()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (flush_pending()) [81/166=48.8%] deflate.c(732,1)
  -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
    -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(732,1):remark #34051: REGISTER ALLOCATION : [flush_pending] deflate.c:732

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rbx rbp rsi rdi r14-r15]
        
    Routine temporaries
        Total         :      22
            Global    :      11
            Local     :      11
        Regenerable   :       0
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: _tr_flush_block(deflate_state *, charf *, ulg, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (_tr_flush_block(deflate_state *, charf *, ulg, int)) [82/166=49.4%] trees.c(916,1)
  -> INLINE: (925,34) detect_data_type() (isz = 48) (sz = 58)
  -> INLINE: (928,9) build_tree() (isz = 834) (sz = 841)
    -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
    -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
      -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
  -> INLINE: (932,9) build_tree() (isz = 834) (sz = 841)
    -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
    -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
      -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
  -> INLINE: (942,23) build_bl_tree() (isz = 1068) (sz = 1075)
    -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
    -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
    -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
  -> (971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (979,9) compress_block() (isz = 546) (sz = 555)
  -> INLINE: (986,9) send_all_trees() (isz = 1701) (sz = 1712)
    -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
    -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
  -> INLINE: (988,9) compress_block() (isz = 546) (sz = 555)
  -> (998,5) init_block() (isz = 39) (sz = 44)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (1001,9) bi_windup() (isz = 51) (sz = 56)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at trees.c(1135,5) inlined into trees.c(925,34)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(928,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(928,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(928,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(928,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(928,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(928,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into trees.c(928,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into trees.c(928,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into trees.c(928,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(932,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(932,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(932,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(932,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(932,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(932,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into trees.c(932,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into trees.c(932,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into trees.c(932,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(942,23)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(942,23)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(942,23)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(942,23)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(942,23)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(942,23)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into trees.c(942,23)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into trees.c(942,23)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into trees.c(942,23)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into trees.c(986,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into trees.c(986,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into trees.c(986,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into trees.c(986,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into trees.c(986,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into trees.c(986,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into trees.c(986,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into trees.c(986,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into trees.c(988,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into trees.c(979,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at trees.c(1143,5) inlined into trees.c(925,34)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

trees.c(916,1):remark #34051: REGISTER ALLOCATION : [_tr_flush_block] trees.c:916

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    2063
            Global    :     532
            Local     :    1531
        Regenerable   :      65
        Spilled       :      65
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [2.77e+00 ~ 0.0%]
            Writes    :      48 [4.06e+01 ~ 0.6%]
        Spills        :     456 bytes*
            Reads     :     143 [2.13e+02 ~ 3.2%]
            Writes    :     114 [2.65e+02 ~ 3.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: _tr_align(deflate_state *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (_tr_align(deflate_state *)) [83/166=50.0%] trees.c(898,1)
  -> (904,5) bi_flush() (isz = 61) (sz = 66)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

trees.c(898,1):remark #34051: REGISTER ALLOCATION : [_tr_align] trees.c:898

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rsi rdi r8]
        
    Routine temporaries
        Total         :      35
            Global    :      12
            Local     :      23
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: read_buf()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (read_buf()) [84/166=50.6%] deflate.c(1168,1)
  -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> (1178,23) adler32() (isz = 341) (sz = 352)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(1168,1):remark #34051: REGISTER ALLOCATION : [read_buf] deflate.c:1168

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rbp rsi rdi r12-r14]
        
    Routine temporaries
        Total         :      36
            Global    :      16
            Local     :      20
        Regenerable   :       1
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflate_huff()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflate_huff()) [85/166=51.2%] deflate.c(2133,1)
  -> (2139,13) fill_window() (isz = 308) (sz = 313)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (2153,21) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (2153,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
    -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
    -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
      -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
    -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
      -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
      -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
    -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
    -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
       [[ Callee not marked with inlining pragma  <1>]]
    -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (2157,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (2157,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (2161,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
    -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
    -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
      -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
    -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
      -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
      -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
    -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
    -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
       [[ Callee not marked with inlining pragma  <1>]]
    -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (2161,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at trees.c(1135,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2153,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2153,21)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2153,21)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2153,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2153,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2153,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2153,21)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2153,21)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2153,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2153,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2153,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2153,21)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2153,21)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2153,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2153,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(2153,21)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2153,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2153,21)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2153,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2153,21)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(2153,21)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(2153,21)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2161,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2161,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2161,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2161,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2161,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2161,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2161,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->static_len (650:34) and s->static_len (650:34)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->static_len (650:34) and s->static_len (650:34)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2161,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2161,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(523,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2161,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2161,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2161,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2161,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2161,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2161,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2161,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(2161,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2161,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2161,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2161,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2161,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(2161,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(2161,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at deflate.c(2153,9)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at trees.c(1143,5) inlined into deflate.c(2153,21)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1143,5) inlined into deflate.c(2161,9)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(2133,1):remark #34051: REGISTER ALLOCATION : [deflate_huff] deflate.c:2133

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    4182
            Global    :    1068
            Local     :    3114
        Regenerable   :     142
        Spilled       :     128
        
    Routine stack
        Variables     :     192 bytes*
            Reads     :       6 [9.87e+00 ~ 0.0%]
            Writes    :      96 [1.44e+02 ~ 0.6%]
        Spills        :     952 bytes*
            Reads     :     289 [7.58e+02 ~ 3.1%]
            Writes    :     238 [9.46e+02 ~ 3.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateStateCheck()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateStateCheck()) [86/166=51.8%] deflate.c(355,1)


    Report from: Code generation optimizations [cg]

deflate.c(355,1):remark #34051: REGISTER ALLOCATION : [deflateStateCheck] deflate.c:355

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :      13
            Global    :       9
            Local     :       4
        Regenerable   :       3
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: compress()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (compress()) [87/166=52.4%] compress.c(73,1)
  -> INLINE: (74,12) compress2() (isz = 9163) (sz = 9179)
    -> (41,11) deflateInit_() (isz = 5) (sz = 18)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (58,15) deflate() (isz = 9099) (sz = 9125)
      -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(838,23) adler32() (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(851,23) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(894,31) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(909,17) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(922,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(933,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(944,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(955,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(966,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(981,27) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
        -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32() (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1786,9) read_buf() (isz = 46) (sz = 58)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1810,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
        -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
          -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
          -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32() (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
          -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
          -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
            -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
          -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
            -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
          -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
             [[ Callee not marked with inlining pragma  <1>]]
          -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (2118,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2118,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.3[(EXPR_CONV.SI32.SI64(s.776_V$d4.3.37.1312->level_V$3f))]
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
      -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (62,5) deflateEnd() (isz = 63) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(904,13) inlined into compress.c(74,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into compress.c(74,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into compress.c(74,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into compress.c(74,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into compress.c(74,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into compress.c(74,12)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into compress.c(74,12)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into compress.c(74,12)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into compress.c(74,12)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into compress.c(74,12)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into compress.c(74,12)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into compress.c(74,12)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into compress.c(74,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(74,12)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(74,12)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into compress.c(74,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into compress.c(74,12)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into compress.c(74,12)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(74,12)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(74,12)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into compress.c(74,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into compress.c(74,12)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into compress.c(74,12)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(74,12)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(74,12)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into compress.c(74,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into compress.c(74,12)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into compress.c(74,12)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into compress.c(74,12)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into compress.c(74,12)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into compress.c(74,12)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into compress.c(74,12)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into compress.c(74,12)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into compress.c(74,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into compress.c(74,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at compress.c(59,21) inlined into compress.c(74,12)
   remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into compress.c(74,12)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into compress.c(74,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
compress.c(73,1):remark #34051: REGISTER ALLOCATION : [compress] compress.c:73

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    3081
            Global    :     779
            Local     :    2302
        Regenerable   :     115
        Spilled       :      78
        
    Routine stack
        Variables     :     208 bytes*
            Reads     :      54 [2.54e+01 ~ 1.4%]
            Writes    :      80 [3.79e+01 ~ 2.1%]
        Spills        :     576 bytes*
            Reads     :     292 [3.66e+01 ~ 2.0%]
            Writes    :     193 [3.56e+01 ~ 2.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: compressBound()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (compressBound()) [88/166=53.0%] compress.c(83,1)


    Report from: Code generation optimizations [cg]

compress.c(83,1):remark #34051: REGISTER ALLOCATION : [compressBound] compress.c:83

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rax rdx rdi]
        
    Routine temporaries
        Total         :      15
            Global    :       0
            Local     :      15
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: uncompress2()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (uncompress2()) [89/166=53.6%] uncompr.c(32,1)
  -> (55,11) inflateInit_() (isz = 2) (sz = 13)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (70,15) inflate() (isz = 5502) (sz = 5516)
    -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
    -> INLINE: inflate.c:(667,32) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(668,17) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(701,42) adler32() (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(722,17) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(730,17) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(740,17) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(750,21) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: inflate.c:(769,40) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(790,36) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(811,36) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(833,42) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(847,42) adler32() (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
    -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
    -> INLINE: inflate.c:(1205,25) adler32() (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(1205,25) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
       [[ Callee not marked with inlining pragma  <1>]]
    -> inflate.c:(1268,13) adler32() (isz = 341) (sz = 352)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(1268,13) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
  -> (79,5) inflateEnd() (isz = 48) (sz = 56)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inflate.c(1223,17) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into uncompr.c(70,15)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into uncompr.c(70,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into uncompr.c(70,15)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 8  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into uncompr.c(70,15)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into uncompr.c(70,15)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into uncompr.c(70,15)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into uncompr.c(70,15)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into uncompr.c(70,15)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into uncompr.c(70,15)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into uncompr.c(70,15)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into uncompr.c(70,15)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into uncompr.c(70,15)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into uncompr.c(70,15)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into uncompr.c(70,15)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into uncompr.c(70,15)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into uncompr.c(70,15)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into uncompr.c(70,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference stream.state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into uncompr.c(70,15)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into uncompr.c(70,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(70,15)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(70,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(70,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into uncompr.c(70,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(70,15)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(70,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(70,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into uncompr.c(70,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between stream.state->lens[order[state->have]] (945:17) and stream.state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between stream.state->lens[order[state->have]] (945:17) and stream.state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <stream.state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into uncompr.c(70,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into uncompr.c(70,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(70,15)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at uncompr.c(71,21)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at inflate.c(1226,21) inlined into uncompr.c(70,15)
      remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1107,17) inlined into uncompr.c(70,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inffast.c(290,19) inlined into uncompr.c(70,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inffast.c(277,20) inlined into uncompr.c(70,15)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END

      LOOP BEGIN at inflate.c(1057,17) inlined into uncompr.c(70,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inflate.c(960,13) inlined into uncompr.c(70,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into uncompr.c(70,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into uncompr.c(70,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inflate.c(939,13) inlined into uncompr.c(70,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into uncompr.c(70,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
uncompr.c(32,1):remark #34051: REGISTER ALLOCATION : [uncompress2] uncompr.c:32

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1699
            Global    :     402
            Local     :    1297
        Regenerable   :     103
        Spilled       :     112
        
    Routine stack
        Variables     :     329 bytes*
            Reads     :     154 [5.10e+01 ~ 3.4%]
            Writes    :     218 [5.88e+01 ~ 3.9%]
        Spills        :     776 bytes*
            Reads     :     527 [4.21e+01 ~ 2.8%]
            Writes    :     225 [4.49e+01 ~ 3.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateEnd()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateEnd()) [90/166=54.2%] inflate.c(1279,1)
  -> INLINE: (1281,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> INDIRECT-: (1284,34)  strm_1171_V$ad.6.63->zfree_V$88
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1285,5)  strm_1171_V$ad.6.63->zfree_V$88
     [[ Unable to inline indirect callsite  <3>]]


    Report from: Code generation optimizations [cg]

inflate.c(1279,1):remark #34051: REGISTER ALLOCATION : [inflateEnd] inflate.c:1279

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rsi rdi r15]
        
    Routine temporaries
        Total         :      20
            Global    :      11
            Local     :       9
        Regenerable   :       2
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: uncompress()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (uncompress()) [91/166=54.8%] uncompr.c(91,1)
  -> INLINE: (92,12) uncompress2() (isz = 5598) (sz = 5612)
    -> (55,11) inflateInit_() (isz = 2) (sz = 13)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (70,15) inflate() (isz = 5502) (sz = 5516)
      -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
      -> INLINE: inflate.c:(667,32) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(668,17) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(701,42) adler32() (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> INLINE: inflate.c:(722,17) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(730,17) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(740,17) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(750,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: inflate.c:(769,40) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(790,36) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(811,36) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(833,42) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(847,42) adler32() (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
      -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
      -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
      -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
      -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
      -> INLINE: inflate.c:(1205,25) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(1205,25) adler32() (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(1268,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> inflate.c:(1268,13) adler32() (isz = 341) (sz = 352)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (79,5) inflateEnd() (isz = 48) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inflate.c(1223,17) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into uncompr.c(92,12)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into uncompr.c(92,12)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into uncompr.c(92,12)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 8  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into uncompr.c(92,12)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into uncompr.c(92,12)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into uncompr.c(92,12)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into uncompr.c(92,12)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into uncompr.c(92,12)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into uncompr.c(92,12)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into uncompr.c(92,12)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into uncompr.c(92,12)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into uncompr.c(92,12)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into uncompr.c(92,12)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into uncompr.c(92,12)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into uncompr.c(92,12)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into uncompr.c(92,12)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into uncompr.c(92,12)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference stream.state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into uncompr.c(92,12)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into uncompr.c(92,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(92,12)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(92,12)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(92,12)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into uncompr.c(92,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(92,12)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(92,12)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(92,12)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into uncompr.c(92,12)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between stream.state->lens[order[state->have]] (945:17) and stream.state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between stream.state->lens[order[state->have]] (945:17) and stream.state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <stream.state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into uncompr.c(92,12)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into uncompr.c(92,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(92,12)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at uncompr.c(71,21) inlined into uncompr.c(92,12)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at inflate.c(1226,21) inlined into uncompr.c(92,12)
      remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1107,17) inlined into uncompr.c(92,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inffast.c(290,19) inlined into uncompr.c(92,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inffast.c(277,20) inlined into uncompr.c(92,12)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END

      LOOP BEGIN at inflate.c(1057,17) inlined into uncompr.c(92,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inflate.c(960,13) inlined into uncompr.c(92,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into uncompr.c(92,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into uncompr.c(92,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inflate.c(939,13) inlined into uncompr.c(92,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into uncompr.c(92,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
uncompr.c(91,1):remark #34051: REGISTER ALLOCATION : [uncompress] uncompr.c:91

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1694
            Global    :     400
            Local     :    1294
        Regenerable   :     103
        Spilled       :     111
        
    Routine stack
        Variables     :     329 bytes*
            Reads     :     151 [4.89e+01 ~ 3.3%]
            Writes    :     218 [5.88e+01 ~ 4.0%]
        Spills        :     768 bytes*
            Reads     :     522 [3.92e+01 ~ 2.6%]
            Writes    :     231 [4.39e+01 ~ 2.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzclose_r(gzFile)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzclose_r(gzFile)) [92/166=55.4%] gzread.c(629,1)
  -> (644,9) inflateEnd() (isz = 48) (sz = 56)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (645,9) free(void *)
  -> EXTERN: (646,9) free(void *)
  -> (649,5) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (650,5) free(void *)
  -> EXTERN: (651,11) close(int)
  -> EXTERN: (652,5) free(void *)


    Report from: Code generation optimizations [cg]

gzread.c(629,1):remark #34051: REGISTER ALLOCATION : [gzclose_r] gzread.c:629

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rcx rsi rdi r13-r15]
        
    Routine temporaries
        Total         :      33
            Global    :      10
            Local     :      23
        Regenerable   :       7
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzclose_w(gzFile)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzclose_w(gzFile)) [93/166=56.0%] gzwrite.c(629,1)
  -> (645,13) gz_zero() (isz = 9326) (sz = 9337)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (650,9) gz_comp() (isz = 9270) (sz = 9284)
    -> (82,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (89,20) write(int, const void *, size_t)
    -> (91,17) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (91,42) __errno_location(void)
    -> EXTERN: (91,42) strerror(int)
    -> EXTERN: (110,24) write(int, const void *, size_t)
    -> (112,21) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (112,46) __errno_location(void)
    -> EXTERN: (112,46) strerror(int)
    -> INLINE: (126,15) deflate() (isz = 9099) (sz = 9125)
      -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(838,23) adler32() (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(851,23) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(894,31) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(909,17) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(922,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(933,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(944,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(955,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(966,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(981,27) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
        -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32() (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1786,9) read_buf() (isz = 46) (sz = 58)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1810,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
        -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
          -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
          -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32() (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
          -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
          -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
            -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
          -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
            -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
          -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
             [[ Callee not marked with inlining pragma  <1>]]
          -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (2118,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2118,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.3[(EXPR_CONV.SI32.SI64(s.776_V$d4.3.37.1881->level_V$3f))]
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
      -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (128,13) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
      -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
         [[ Callee not marked with inlining pragma  <1>]]
  -> (654,19) deflateEnd() (isz = 63) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (655,13) free(void *)
  -> EXTERN: (657,9) free(void *)
  -> (659,5) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (660,5) free(void *)
  -> EXTERN: (661,9) close(int)
  -> EXTERN: (663,5) free(void *)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(650,9)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(650,9)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(650,9)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(650,9)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(650,9)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(650,9)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(650,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(650,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(650,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(650,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(650,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(650,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(650,9)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(650,9)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(650,9)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(629,1):remark #34051: REGISTER ALLOCATION : [gzclose_w] gzwrite.c:629

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :    2982
            Global    :     754
            Local     :    2228
        Regenerable   :     109
        Spilled       :      89
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [6.98e-02 ~ 0.0%]
            Writes    :      48 [1.02e+00 ~ 0.4%]
        Spills        :     664 bytes*
            Reads     :     227 [6.35e+00 ~ 2.3%]
            Writes    :     157 [7.58e+00 ~ 2.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_zero()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_zero()) [94/166=56.6%] gzwrite.c(148,1)
  -> INLINE: (154,27) gz_comp() (isz = 9270) (sz = 9284)
    -> (82,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (89,20) write(int, const void *, size_t)
    -> (91,17) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (91,42) __errno_location(void)
    -> EXTERN: (91,42) strerror(int)
    -> EXTERN: (110,24) write(int, const void *, size_t)
    -> (112,21) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (112,46) __errno_location(void)
    -> EXTERN: (112,46) strerror(int)
    -> INLINE: (126,15) deflate() (isz = 9099) (sz = 9125)
      -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(838,23) adler32() (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(851,23) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(894,31) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(909,17) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(922,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(933,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(944,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(955,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(966,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(981,27) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
        -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32() (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1786,9) read_buf() (isz = 46) (sz = 58)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1810,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
        -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
          -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
          -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32() (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
          -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
          -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
            -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
          -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
            -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
          -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
             [[ Callee not marked with inlining pragma  <1>]]
          -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (2118,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2118,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.3[(EXPR_CONV.SI32.SI64(s.776_V$d4.3.37.1431->level_V$3f))]
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
      -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (128,13) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
      -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
         [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (163,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
  -> CP_CLONE (169,13) gz_comp..0() (isz = 9270) (sz = 9284)
     [[ Inlining inhibited by overrideable criterion  <2>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(154,27)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(154,27)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(154,27)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(154,27)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(154,27)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(154,27)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(154,27)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(154,27)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(154,27)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(154,27)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(154,27)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(154,27)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(154,27)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(154,27)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(154,27)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(154,27)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(154,27)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(154,27)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(154,27)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(154,27)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(154,27)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(154,27)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(154,27)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(154,27)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(154,27)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(154,27)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(154,27)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at gzwrite.c(159,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(154,27)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(154,27)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(154,27)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(148,1):remark #34051: REGISTER ALLOCATION : [gz_zero] gzwrite.c:148

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2918
            Global    :     742
            Local     :    2176
        Regenerable   :     116
        Spilled       :      76
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [4.92e-02 ~ 0.0%]
            Writes    :      48 [7.20e-01 ~ 0.3%]
        Spills        :     568 bytes*
            Reads     :     186 [4.26e+00 ~ 1.7%]
            Writes    :     142 [5.52e+00 ~ 2.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzclose()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzclose()) [95/166=57.2%] gzclose.c(13,1)
  -> INLINE (PARTIAL): (21,37) gzclose_r(gzFile) (isz = 10) (sz = 10)
    -> PI_CLONE gzread.c:(634,5) gzclose_r..0(gzFile) (isz = 0) (sz = 0)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (PARTIAL): (21,55) gzclose_w(gzFile) (isz = 12) (sz = 12)
    -> PI_CLONE gzwrite.c:(634,5) gzclose_w..0(gzFile) (isz = 0) (sz = 0)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzclose.c(13,1):remark #34051: REGISTER ALLOCATION : [gzclose] gzclose.c:13

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :      11
            Global    :       7
            Local     :       4
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzclose_r..0(gzFile)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzclose_r..0(gzFile)) [96/166=57.8%] gzread.c(629,1)
  -> (644,9) inflateEnd() (isz = 48) (sz = 56)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (645,9) free(void *)
  -> EXTERN: (646,9) free(void *)
  -> (649,5) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (650,5) free(void *)
  -> EXTERN: (651,11) close(int)
  -> EXTERN: (652,5) free(void *)


    Report from: Code generation optimizations [cg]

gzread.c(629,1):remark #34051: REGISTER ALLOCATION : [gzclose_r..0] gzread.c:629

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rcx rbx rsi rdi r14-r15]
        
    Routine temporaries
        Total         :      32
            Global    :      10
            Local     :      22
        Regenerable   :       6
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzclose_w..0(gzFile)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzclose_w..0(gzFile)) [97/166=58.4%] gzwrite.c(629,1)
  -> (645,13) gz_zero() (isz = 9326) (sz = 9337)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (650,9) gz_comp() (isz = 9270) (sz = 9284)
    -> (82,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (89,20) write(int, const void *, size_t)
    -> (91,17) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (91,42) strerror(int)
    -> EXTERN: (91,42) __errno_location(void)
    -> EXTERN: (110,24) write(int, const void *, size_t)
    -> (112,21) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (112,46) strerror(int)
    -> EXTERN: (112,46) __errno_location(void)
    -> INLINE: (126,15) deflate() (isz = 9099) (sz = 9125)
      -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(838,23) adler32() (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(851,23) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(894,31) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(909,17) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(922,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(933,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(944,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(955,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(966,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(981,27) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
        -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32() (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1786,9) read_buf() (isz = 46) (sz = 58)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1810,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
        -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
          -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
          -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32() (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
          -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
          -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
            -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
          -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
            -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
          -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
             [[ Callee not marked with inlining pragma  <1>]]
          -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
        -> (2118,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2118,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2122,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2122,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.3[(EXPR_CONV.SI32.SI64(s.776_V$d4.3.37.2383->level_V$3f))]
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
      -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (128,13) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
      -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
         [[ Callee not marked with inlining pragma  <1>]]
  -> (654,19) deflateEnd() (isz = 63) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (655,13) free(void *)
  -> EXTERN: (657,9) free(void *)
  -> (659,5) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (660,5) free(void *)
  -> EXTERN: (661,9) close(int)
  -> EXTERN: (663,5) free(void *)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(650,9)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(650,9)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(650,9)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(650,9)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(650,9)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(650,9)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(650,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(650,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(650,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(650,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(650,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(650,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(650,9)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(650,9)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(650,9)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(629,1):remark #34051: REGISTER ALLOCATION : [gzclose_w..0] gzwrite.c:629

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :    2981
            Global    :     754
            Local     :    2227
        Regenerable   :     108
        Spilled       :      86
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [6.98e-02 ~ 0.0%]
            Writes    :      48 [1.02e+00 ~ 0.4%]
        Spills        :     656 bytes*
            Reads     :     233 [6.71e+00 ~ 2.4%]
            Writes    :     166 [8.08e+00 ~ 2.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: snprintf(char *__restrict__, size_t, const char *__restrict__, ...)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (snprintf(char *__restrict__, size_t, const char *__restrict__, ...))/usr/include/x86_64-linux-gnu/bits/stdio2.h(66,1)

===========================================================================

Begin optimization report for: open(const char *, int, ...)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (open(const char *, int, ...))/usr/include/x86_64-linux-gnu/bits/fcntl2.h(42,1)

===========================================================================

Begin optimization report for: gz_reset()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gz_reset()) gzlib.c(77,1)

===========================================================================

Begin optimization report for: gz_open()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gz_open()) gzlib.c(95,1)

===========================================================================

Begin optimization report for: gzopen()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzopen()) [102/166=61.4%] gzlib.c(273,1)
  -> INLINE: (274,12) gz_open() (isz = 257) (sz = 275)
    -> EXTERN: (111,24) malloc(size_t)
    -> EXTERN: (140,17) free(void *)
    -> EXTERN: (177,9) free(void *)
    -> EXTERN: (184,13) free(void *)
    -> EXTERN: (199,15) strlen(const char *)
    -> EXTERN: (200,27) malloc(size_t)
    -> EXTERN: (202,9) free(void *)
    -> INLINE: (214,15) snprintf(char *__restrict__, size_t, const char *__restrict__, ...) (isz = 10) (sz = 21)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(67,10) __builtin___snprintf_chk(char *, unsigned long, int, unsigned long, const char *, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,8) __builtin_object_size(const void *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,28) __builtin_va_arg_pack(void)
    -> INLINE: (245,9) open(const char *, int, ...) (isz = 48) (sz = 60)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(43,7) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(44,5) __open_too_many_args(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(46,7) __builtin_constant_p(...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(48,42) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(50,4) __open_missing_mode(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(51,11) __open_2(const char *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(53,14) __open_alias(const char *, int, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(53,45) __builtin_va_arg_pack(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(56,7) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(57,12) __open_2(const char *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(59,10) __open_alias(const char *, int, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(59,41) __builtin_va_arg_pack(void)
    -> EXTERN: (247,9) free(void *)
    -> EXTERN: (248,9) free(void *)
    -> EXTERN: (252,9) lseek64(int, __off64_t, int)
    -> EXTERN: (258,24) lseek64(int, __off64_t, int)
    -> INLINE: (263,5) gz_reset() (isz = 19) (sz = 24)
      -> (85,5) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]



Non-optimizable loops:


LOOP BEGIN at gzlib.c(123,5) inlined into gzlib.c(274,12)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ gzlib.c(127,13) ]
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

gzlib.c(273,1):remark #34051: REGISTER ALLOCATION : [gzopen] gzlib.c:273

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   14[ rax rdx rcx rbx rbp rsi rdi r8-r11 r13-r15]
        
    Routine temporaries
        Total         :      76
            Global    :      31
            Local     :      45
        Regenerable   :      21
        Spilled       :       5
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzopen64()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzopen64()) [103/166=62.0%] gzlib.c(281,1)
  -> INLINE: (282,12) gz_open() (isz = 257) (sz = 275)
    -> EXTERN: (111,24) malloc(size_t)
    -> EXTERN: (140,17) free(void *)
    -> EXTERN: (177,9) free(void *)
    -> EXTERN: (184,13) free(void *)
    -> EXTERN: (199,15) strlen(const char *)
    -> EXTERN: (200,27) malloc(size_t)
    -> EXTERN: (202,9) free(void *)
    -> INLINE: (214,15) snprintf(char *__restrict__, size_t, const char *__restrict__, ...) (isz = 10) (sz = 21)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(67,10) __builtin___snprintf_chk(char *, unsigned long, int, unsigned long, const char *, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,8) __builtin_object_size(const void *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,28) __builtin_va_arg_pack(void)
    -> INLINE: (245,9) open(const char *, int, ...) (isz = 48) (sz = 60)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(43,7) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(44,5) __open_too_many_args(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(46,7) __builtin_constant_p(...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(48,42) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(50,4) __open_missing_mode(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(51,11) __open_2(const char *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(53,14) __open_alias(const char *, int, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(53,45) __builtin_va_arg_pack(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(56,7) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(57,12) __open_2(const char *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(59,10) __open_alias(const char *, int, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(59,41) __builtin_va_arg_pack(void)
    -> EXTERN: (247,9) free(void *)
    -> EXTERN: (248,9) free(void *)
    -> EXTERN: (252,9) lseek64(int, __off64_t, int)
    -> EXTERN: (258,24) lseek64(int, __off64_t, int)
    -> INLINE: (263,5) gz_reset() (isz = 19) (sz = 24)
      -> (85,5) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]



Non-optimizable loops:


LOOP BEGIN at gzlib.c(123,5) inlined into gzlib.c(282,12)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ gzlib.c(127,13) ]
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

gzlib.c(281,1):remark #34051: REGISTER ALLOCATION : [gzopen64] gzlib.c:281

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   14[ rax rdx rcx rbx rbp rsi rdi r8-r11 r13-r15]
        
    Routine temporaries
        Total         :      76
            Global    :      31
            Local     :      45
        Regenerable   :      21
        Spilled       :       5
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzdopen()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzdopen()) [104/166=62.7%] gzlib.c(289,1)
  -> EXTERN: (293,37) malloc(size_t)
  -> INLINE: (296,11) snprintf(char *__restrict__, size_t, const char *__restrict__, ...) (isz = 10) (sz = 21)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(67,10) __builtin___snprintf_chk(char *, unsigned long, int, unsigned long, const char *, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,8) __builtin_object_size(const void *, int)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,28) __builtin_va_arg_pack(void)
  -> INLINE: (300,10) gz_open() (isz = 257) (sz = 275)
    -> EXTERN: (111,24) malloc(size_t)
    -> EXTERN: (140,17) free(void *)
    -> EXTERN: (177,9) free(void *)
    -> EXTERN: (184,13) free(void *)
    -> EXTERN: (199,15) strlen(const char *)
    -> EXTERN: (200,27) malloc(size_t)
    -> EXTERN: (202,9) free(void *)
    -> INLINE: (214,15) snprintf(char *__restrict__, size_t, const char *__restrict__, ...) (isz = 10) (sz = 21)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(67,10) __builtin___snprintf_chk(char *, unsigned long, int, unsigned long, const char *, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,8) __builtin_object_size(const void *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,28) __builtin_va_arg_pack(void)
    -> INLINE: (245,9) open(const char *, int, ...) (isz = 48) (sz = 60)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(43,7) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(44,5) __open_too_many_args(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(46,7) __builtin_constant_p(...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(48,42) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(50,4) __open_missing_mode(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(51,11) __open_2(const char *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(53,14) __open_alias(const char *, int, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(53,45) __builtin_va_arg_pack(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(56,7) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(57,12) __open_2(const char *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(59,10) __open_alias(const char *, int, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(59,41) __builtin_va_arg_pack(void)
    -> EXTERN: (247,9) free(void *)
    -> EXTERN: (248,9) free(void *)
    -> EXTERN: (252,9) lseek64(int, __off64_t, int)
    -> EXTERN: (258,24) lseek64(int, __off64_t, int)
    -> INLINE: (263,5) gz_reset() (isz = 19) (sz = 24)
      -> (85,5) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (301,5) free(void *)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]



Non-optimizable loops:


LOOP BEGIN at gzlib.c(123,5) inlined into gzlib.c(300,10)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ gzlib.c(127,13) ]
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

gzlib.c(289,1):remark #34051: REGISTER ALLOCATION : [gzdopen] gzlib.c:289

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   15[ rax rdx rcx rbx rbp rsi rdi r8-r15]
        
    Routine temporaries
        Total         :      88
            Global    :      32
            Local     :      56
        Regenerable   :      29
        Spilled       :       6
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzbuffer()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzbuffer()) [105/166=63.3%] gzlib.c(319,1)


    Report from: Code generation optimizations [cg]

gzlib.c(319,1):remark #34051: REGISTER ALLOCATION : [gzbuffer] gzlib.c:319

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rax rsi rdi]
        
    Routine temporaries
        Total         :      19
            Global    :      10
            Local     :       9
        Regenerable   :       4
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzrewind()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzrewind()) [106/166=63.9%] gzlib.c(345,1)
  -> EXTERN: (359,9) lseek64(int, __off64_t, int)
  -> INLINE: (361,5) gz_reset() (isz = 19) (sz = 24)
    -> (85,5) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzlib.c(345,1):remark #34051: REGISTER ALLOCATION : [gzrewind] gzlib.c:345

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    5[ rax rdx rsi rdi r13]
        
    Routine temporaries
        Total         :      24
            Global    :      10
            Local     :      14
        Regenerable   :       8
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzseek()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzseek()) [107/166=64.5%] gzlib.c(447,1)
  -> (450,11) gzseek64() (isz = 141) (sz = 161)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzlib.c(447,1):remark #34051: REGISTER ALLOCATION : [gzseek] gzlib.c:447

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rdx rsi rdi]
        
    Routine temporaries
        Total         :      15
            Global    :       0
            Local     :      15
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzseek64()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzseek64()) [108/166=65.1%] gzlib.c(370,1)
  -> EXTERN: (400,15) lseek64(int, __off64_t, int)
  -> (407,9) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (PARTIAL): (420,13) gzrewind() (isz = 10) (sz = 10)
    -> PI_CLONE (349,5) gzrewind..0() (isz = 0) (sz = 0)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzlib.c(370,1):remark #34051: REGISTER ALLOCATION : [gzseek64] gzlib.c:370

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rcx rbp rsi rdi r12]
        
    Routine temporaries
        Total         :      50
            Global    :      16
            Local     :      34
        Regenerable   :      12
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzrewind..0()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzrewind..0()) [109/166=65.7%] gzlib.c(345,1)
  -> EXTERN: (359,9) lseek64(int, __off64_t, int)
  -> INLINE: (361,5) gz_reset() (isz = 19) (sz = 24)
    -> (85,5) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzlib.c(345,1):remark #34051: REGISTER ALLOCATION : [gzrewind..0] gzlib.c:345

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    5[ rax rdx rsi rdi r14]
        
    Routine temporaries
        Total         :      23
            Global    :      10
            Local     :      13
        Regenerable   :       7
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gztell64()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gztell64()) [110/166=66.3%] gzlib.c(457,1)


    Report from: Code generation optimizations [cg]

gzlib.c(457,1):remark #34051: REGISTER ALLOCATION : [gztell64] gzlib.c:457

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :      14
            Global    :       9
            Local     :       5
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gztell()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gztell()) [111/166=66.9%] gzlib.c(474,1)
  -> INLINE: (477,11) gztell64() (isz = 19) (sz = 28)


    Report from: Code generation optimizations [cg]

gzlib.c(474,1):remark #34051: REGISTER ALLOCATION : [gztell] gzlib.c:474

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :      12
            Global    :      10
            Local     :       2
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzoffset64()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzoffset64()) [112/166=67.5%] gzlib.c(484,1)
  -> EXTERN: (496,14) lseek64(int, __off64_t, int)


    Report from: Code generation optimizations [cg]

gzlib.c(484,1):remark #34051: REGISTER ALLOCATION : [gzoffset64] gzlib.c:484

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    5[ rax rdx rsi rdi r14]
        
    Routine temporaries
        Total         :      20
            Global    :      10
            Local     :      10
        Regenerable   :       5
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzoffset()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzoffset()) [113/166=68.1%] gzlib.c(507,1)
  -> INLINE: (510,11) gzoffset64() (isz = 26) (sz = 36)
    -> EXTERN: (496,14) lseek64(int, __off64_t, int)


    Report from: Code generation optimizations [cg]

gzlib.c(507,1):remark #34051: REGISTER ALLOCATION : [gzoffset] gzlib.c:507

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    5[ rax rdx rsi rdi r12]
        
    Routine temporaries
        Total         :      17
            Global    :      10
            Local     :       7
        Regenerable   :       2
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzeof()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzeof()) [114/166=68.7%] gzlib.c(517,1)


    Report from: Code generation optimizations [cg]

gzlib.c(517,1):remark #34051: REGISTER ALLOCATION : [gzeof] gzlib.c:517

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :      13
            Global    :       9
            Local     :       4
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: read(int, void *, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (read(int, void *, size_t))/usr/include/x86_64-linux-gnu/bits/unistd.h(35,1)

===========================================================================

Begin optimization report for: memcpy(void *__restrict__, const void *__restrict__, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (memcpy(void *__restrict__, const void *__restrict__, size_t))/usr/include/x86_64-linux-gnu/bits/string_fortified.h(33,1)

===========================================================================

Begin optimization report for: gz_load()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gz_load()) gzread.c(26,1)

===========================================================================

Begin optimization report for: gz_avail()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gz_avail()) gzread.c(58,1)

===========================================================================

Begin optimization report for: gz_decomp()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gz_decomp()) gzread.c(177,1)

===========================================================================

Begin optimization report for: gz_read()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gz_read()) gzread.c(298,1)

===========================================================================

Begin optimization report for: gz_fetch()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_fetch()) [121/166=72.9%] gzread.c(231,1)
  -> INLINE: (237,17) gz_look() (isz = 249) (sz = 262)
    -> EXTERN: (99,38) malloc(size_t)
    -> EXTERN: (100,39) malloc(size_t)
    -> EXTERN: (102,13) free(void *)
    -> EXTERN: (103,13) free(void *)
    -> (104,13) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (115,13) inflateInit2_() (isz = 58) (sz = 74)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (116,13) free(void *)
    -> EXTERN: (117,13) free(void *)
    -> (119,13) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (126,13) gz_avail() (isz = 103) (sz = 112)
      -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
        -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
        -> (41,9) gz_error() (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> EXTERN: (41,34) __errno_location(void)
        -> EXTERN: (41,34) strerror(int)
    -> (141,9) inflateReset() (isz = 40) (sz = 48)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (161,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (243,17) gz_load() (isz = 42) (sz = 56)
    -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
    -> (41,9) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (41,34) __errno_location(void)
    -> EXTERN: (41,34) strerror(int)
  -> INLINE: (251,17) gz_decomp() (isz = 5691) (sz = 5702)
    -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
      -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
        -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
        -> (41,9) gz_error() (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> EXTERN: (41,34) __errno_location(void)
        -> EXTERN: (41,34) strerror(int)
    -> (189,13) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (194,15) inflate() (isz = 5502) (sz = 5516)
      -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
      -> INLINE: inflate.c:(667,32) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(668,17) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(701,42) adler32() (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> INLINE: inflate.c:(722,17) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(730,17) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(740,17) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(750,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: inflate.c:(769,40) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(790,36) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(811,36) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(833,42) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(847,42) adler32() (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
      -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
      -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
      -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
      -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
      -> INLINE: inflate.c:(1205,25) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(1205,25) adler32() (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(1268,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> inflate.c:(1268,13) adler32() (isz = 341) (sz = 352)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (196,13) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (201,13) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (205,13) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(237,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(237,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(237,17)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(237,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(251,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(251,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(251,17)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(251,17)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(251,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(251,17)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(251,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(251,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(251,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(251,17)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(251,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(251,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(251,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(251,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(251,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(251,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(251,17)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(251,17)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(251,17)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(251,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(251,17)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(251,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(251,17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(251,17)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(251,17)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(251,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(251,17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(251,17)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(251,17)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(251,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(251,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(251,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(251,17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(243,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(254,31)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(251,17)
      remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(251,17)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(251,17)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(251,17)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(251,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END

         LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(251,17)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(251,17)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(251,17)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(251,17)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(251,17)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(251,17)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(231,1):remark #34051: REGISTER ALLOCATION : [gz_fetch] gzread.c:231

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    1824
            Global    :     464
            Local     :    1360
        Regenerable   :     134
        Spilled       :     106
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :     131 [0.00e+00 ~ 0.0%]
            Writes    :     159 [0.00e+00 ~ 0.0%]
        Spills        :     792 bytes*
            Reads     :     758 [1.93e+00 ~ 2.0%]
            Writes    :     310 [2.42e+00 ~ 2.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_skip()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_skip()) [122/166=73.5%] gzread.c(262,1)
  -> INLINE: (284,17) gz_fetch() (isz = 6046) (sz = 6058)
    -> INLINE: (237,17) gz_look() (isz = 249) (sz = 262)
      -> EXTERN: (99,38) malloc(size_t)
      -> EXTERN: (100,39) malloc(size_t)
      -> EXTERN: (102,13) free(void *)
      -> EXTERN: (103,13) free(void *)
      -> (104,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (115,13) inflateInit2_() (isz = 58) (sz = 74)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (116,13) free(void *)
      -> EXTERN: (117,13) free(void *)
      -> (119,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (126,13) gz_avail() (isz = 103) (sz = 112)
        -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
          -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
          -> (41,9) gz_error() (isz = 59) (sz = 71)
             [[ Callee not marked with inlining pragma  <1>]]
          -> EXTERN: (41,34) strerror(int)
          -> EXTERN: (41,34) __errno_location(void)
      -> (141,9) inflateReset() (isz = 40) (sz = 48)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (161,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (243,17) gz_load() (isz = 42) (sz = 56)
      -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
      -> (41,9) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (41,34) strerror(int)
      -> EXTERN: (41,34) __errno_location(void)
    -> INLINE: (251,17) gz_decomp() (isz = 5691) (sz = 5702)
      -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
        -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
          -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
          -> (41,9) gz_error() (isz = 59) (sz = 71)
             [[ Callee not marked with inlining pragma  <1>]]
          -> EXTERN: (41,34) strerror(int)
          -> EXTERN: (41,34) __errno_location(void)
      -> (189,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (194,15) inflate() (isz = 5502) (sz = 5516)
        -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
        -> INLINE: inflate.c:(667,32) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(668,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(701,42) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(722,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(730,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(740,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(750,21) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(769,40) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(790,36) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(811,36) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(833,42) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(847,42) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
        -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
        -> INLINE: inflate.c:(1205,25) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(1205,25) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
           [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1268,13) adler32() (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(1268,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> (196,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (201,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (205,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(284,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(284,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(284,17)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(284,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(284,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(284,17)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(284,17)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(284,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(284,17)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(284,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(284,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(284,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(284,17)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(284,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(284,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(284,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(284,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(284,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(284,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(284,17)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(284,17)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(284,17)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(284,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(284,17)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(284,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(284,17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(284,17)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(284,17)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(284,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(284,17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(284,17)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(284,17)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(284,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(284,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(284,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(284,17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(266,5)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(254,31) inlined into gzread.c(284,17)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(284,17)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(284,17)
            remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(284,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(284,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate

               LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(284,17)
                  remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
                  remark #17102: loop was not parallelized: not a parallelization candidate
               LOOP END
            LOOP END

            LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(284,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(284,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(284,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(284,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(284,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(284,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(262,1):remark #34051: REGISTER ALLOCATION : [gz_skip] gzread.c:262

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    1827
            Global    :     465
            Local     :    1362
        Regenerable   :     130
        Spilled       :     106
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :     131 [0.00e+00 ~ 0.0%]
            Writes    :     159 [0.00e+00 ~ 0.0%]
        Spills        :     792 bytes*
            Reads     :     762 [3.28e+00 ~ 1.9%]
            Writes    :     314 [3.48e+00 ~ 2.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: crc32_z()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (crc32_z()) [123/166=74.1%] crc32.c(206,1)
  -> INLINE: (220,20) crc32_little() (isz = 274) (sz = 285)
  -> INLINE: (222,20) crc32_big() (isz = 274) (sz = 285)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at crc32.c(276,5) inlined into crc32.c(220,20)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c (277:9) and c (277:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (277:9) and c (277:9)
   remark #17106: parallel dependence: assumed ANTI dependence between c (277:9) and c (277:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (277:9) and c (277:9)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ crc32.c(278,9) ]
LOOP END

LOOP BEGIN at crc32.c(282,5) inlined into crc32.c(220,20)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c (283:9) and c (283:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (283:9) and c (283:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (283:9) and c (283:9)
   remark #17106: parallel dependence: assumed ANTI dependence between c (283:9) and c (283:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between c (283:9) and c (283:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (283:9) and c (283:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (283:9) and c (283:9)
   remark #15346: vector dependence: assumed ANTI dependence between c (283:9) and c (283:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at crc32.c(286,5) inlined into crc32.c(220,20)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c (287:9) and c (287:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (287:9) and c (287:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (287:9) and c (287:9)
   remark #17106: parallel dependence: assumed ANTI dependence between c (287:9) and c (287:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between c (287:9) and c (287:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (287:9) and c (287:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (287:9) and c (287:9)
   remark #15346: vector dependence: assumed ANTI dependence between c (287:9) and c (287:9)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at crc32.c(286,5) inlined into crc32.c(220,20)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at crc32.c(292,5) inlined into crc32.c(220,20)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c (293:9) and c (293:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (293:9) and c (293:9)
   remark #17106: parallel dependence: assumed ANTI dependence between c (293:9) and c (293:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (293:9) and c (293:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between c (293:9) and c (293:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (293:9) and c (293:9)
   remark #15346: vector dependence: assumed ANTI dependence between c (293:9) and c (293:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (293:9) and c (293:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at crc32.c(292,5) inlined into crc32.c(220,20)
<Remainder>
LOOP END

LOOP BEGIN at crc32.c(316,5) inlined into crc32.c(222,20)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c (317:9) and c (317:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (317:9) and c (317:9)
   remark #17106: parallel dependence: assumed ANTI dependence between c (317:9) and c (317:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (317:9) and c (317:9)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ crc32.c(318,9) ]
LOOP END

LOOP BEGIN at crc32.c(322,5) inlined into crc32.c(222,20)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c (323:9) and c (323:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (323:9) and c (323:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (323:9) and c (323:9)
   remark #17106: parallel dependence: assumed ANTI dependence between c (323:9) and c (323:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between c (323:9) and c (323:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (323:9) and c (323:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (323:9) and c (323:9)
   remark #15346: vector dependence: assumed ANTI dependence between c (323:9) and c (323:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at crc32.c(326,5) inlined into crc32.c(222,20)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c (327:9) and c (327:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (327:9) and c (327:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (327:9) and c (327:9)
   remark #17106: parallel dependence: assumed ANTI dependence between c (327:9) and c (327:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between c (327:9) and c (327:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (327:9) and c (327:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (327:9) and c (327:9)
   remark #15346: vector dependence: assumed ANTI dependence between c (327:9) and c (327:9)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at crc32.c(326,5) inlined into crc32.c(222,20)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at crc32.c(332,5) inlined into crc32.c(222,20)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c (333:9) and c (333:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (333:9) and c (333:9)
   remark #17106: parallel dependence: assumed ANTI dependence between c (333:9) and c (333:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (333:9) and c (333:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between c (333:9) and c (333:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (333:9) and c (333:9)
   remark #15346: vector dependence: assumed ANTI dependence between c (333:9) and c (333:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (333:9) and c (333:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at crc32.c(332,5) inlined into crc32.c(222,20)
<Remainder>
LOOP END

    Report from: Code generation optimizations [cg]

crc32.c(206,1):remark #34051: REGISTER ALLOCATION : [crc32_z] crc32.c:206

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   10[ rax rdx rcx rsi rdi r8-r12]
        
    Routine temporaries
        Total         :     225
            Global    :      26
            Local     :     199
        Regenerable   :       8
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       8 bytes*
            Reads     :       1 [4.27e-01 ~ 0.1%]
            Writes    :       1 [4.27e-01 ~ 0.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: updatewindow()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (updatewindow()) [124/166=74.7%] inflate.c(400,1)
  -> INDIRECT-: (409,25)  strm_665_V$61.6.61->zalloc_V$87
     [[ Unable to inline indirect callsite  <3>]]
  -> INLINE (MANUAL): (423,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (430,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (433,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(400,1):remark #34051: REGISTER ALLOCATION : [updatewindow] inflate.c:400

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rbp rsi rdi r12-r14]
        
    Routine temporaries
        Total         :      60
            Global    :      18
            Local     :      42
        Regenerable   :       6
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateReset()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateReset()) [125/166=75.3%] inflate.c(146,1)
  -> INLINE: (149,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> (154,12) inflateResetKeep() (isz = 74) (sz = 82)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

inflate.c(146,1):remark #34051: REGISTER ALLOCATION : [inflateReset] inflate.c:146

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rax rdx rdi]
        
    Routine temporaries
        Total         :      13
            Global    :       9
            Local     :       4
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateResetKeep()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateResetKeep()) [126/166=75.9%] inflate.c(121,1)
  -> INLINE: (124,9) inflateStateCheck() (isz = 25) (sz = 34)


    Report from: Code generation optimizations [cg]

inflate.c(121,1):remark #34051: REGISTER ALLOCATION : [inflateResetKeep] inflate.c:121

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rcx rdi]
        
    Routine temporaries
        Total         :      18
            Global    :      11
            Local     :       7
        Regenerable   :       4
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzread()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzread()) [127/166=76.5%] gzread.c(379,1)
  -> (395,9) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (400,11) gz_read() (isz = 5842) (sz = 5858)
    -> (309,13) gz_skip() (isz = 6092) (sz = 6102)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE (MANUAL): (325,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (340,17) gz_fetch() (isz = 6046) (sz = 6058)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (349,17) gz_load() (isz = 42) (sz = 56)
      -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
      -> (41,9) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (41,34) strerror(int)
      -> EXTERN: (41,34) __errno_location(void)
    -> INLINE: (357,17) gz_decomp() (isz = 5691) (sz = 5702)
      -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
        -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
          -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
          -> (41,9) gz_error() (isz = 59) (sz = 71)
             [[ Callee not marked with inlining pragma  <1>]]
          -> EXTERN: (41,34) strerror(int)
          -> EXTERN: (41,34) __errno_location(void)
      -> (189,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (194,15) inflate() (isz = 5502) (sz = 5516)
        -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
        -> INLINE: inflate.c:(667,32) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(668,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(701,42) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(722,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(730,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(740,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(750,21) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(769,40) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(790,36) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(811,36) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(833,42) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(847,42) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
        -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
        -> INLINE: inflate.c:(1205,25) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(1205,25) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
           [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1268,13) adler32() (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(1268,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> (196,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (201,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (205,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(400,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(400,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(400,11)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(400,11)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(400,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(400,11)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(400,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(400,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(400,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(400,11)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(400,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(400,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(400,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(400,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(400,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(400,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(400,11)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(400,11)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(400,11)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(400,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(400,11)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(400,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(400,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(400,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(400,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(400,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(400,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(400,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(400,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(400,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(400,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(400,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(400,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(368,14) inlined into gzread.c(400,11)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(400,11)
      remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(400,11)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(400,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(400,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(400,11)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END

         LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(400,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(400,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(400,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(400,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(400,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(400,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(379,1):remark #34051: REGISTER ALLOCATION : [gzread] gzread.c:379

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1742
            Global    :     429
            Local     :    1313
        Regenerable   :     116
        Spilled       :     112
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :     131 [2.36e-01 ~ 0.3%]
            Writes    :     159 [3.24e-01 ~ 0.5%]
        Spills        :     824 bytes*
            Reads     :     586 [1.23e+00 ~ 1.7%]
            Writes    :     281 [1.59e+00 ~ 2.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzfread()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzfread()) [128/166=77.1%] gzread.c(416,1)
  -> (433,9) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (438,18) gz_read() (isz = 5842) (sz = 5858)
    -> (309,13) gz_skip() (isz = 6092) (sz = 6102)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE (MANUAL): (325,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (340,17) gz_fetch() (isz = 6046) (sz = 6058)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (349,17) gz_load() (isz = 42) (sz = 56)
      -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
      -> (41,9) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (41,34) strerror(int)
      -> EXTERN: (41,34) __errno_location(void)
    -> INLINE: (357,17) gz_decomp() (isz = 5691) (sz = 5702)
      -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
        -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
          -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
          -> (41,9) gz_error() (isz = 59) (sz = 71)
             [[ Callee not marked with inlining pragma  <1>]]
          -> EXTERN: (41,34) strerror(int)
          -> EXTERN: (41,34) __errno_location(void)
      -> (189,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (194,15) inflate() (isz = 5502) (sz = 5516)
        -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
        -> INLINE: inflate.c:(667,32) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(668,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(701,42) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(722,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(730,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(740,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(750,21) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(769,40) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(790,36) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(811,36) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(833,42) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(847,42) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
        -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
        -> INLINE: inflate.c:(1205,25) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(1205,25) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
           [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1268,13) adler32() (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(1268,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> (196,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (201,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (205,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(438,18)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(438,18)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(438,18)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(438,18)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(438,18)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(438,18)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(438,18)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(438,18)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(438,18)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(438,18)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(438,18)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(438,18)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(438,18)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(438,18)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(438,18)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(438,18)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(438,18)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(438,18)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(438,18)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(438,18)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(438,18)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(438,18)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(438,18)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(438,18)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(438,18)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(438,18)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(438,18)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(438,18)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(438,18)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(438,18)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(438,18)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(438,18)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(438,18)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(368,14) inlined into gzread.c(438,18)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(438,18)
      remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(438,18)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(438,18)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(438,18)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(438,18)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END

         LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(438,18)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(438,18)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(438,18)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(438,18)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(438,18)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(438,18)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(416,1):remark #34051: REGISTER ALLOCATION : [gzfread] gzread.c:416

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1749
            Global    :     429
            Local     :    1320
        Regenerable   :     117
        Spilled       :     106
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :     131 [5.17e-02 ~ 0.1%]
            Writes    :     159 [7.09e-02 ~ 0.2%]
        Spills        :     784 bytes*
            Reads     :     592 [2.80e-01 ~ 0.6%]
            Writes    :     267 [3.46e-01 ~ 0.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzgetc()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzgetc()) [129/166=77.7%] gzread.c(449,1)
  -> INLINE: (472,11) gz_read() (isz = 5842) (sz = 5858)
    -> (309,13) gz_skip() (isz = 6092) (sz = 6102)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE (MANUAL): (325,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (340,17) gz_fetch() (isz = 6046) (sz = 6058)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (349,17) gz_load() (isz = 42) (sz = 56)
      -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
      -> (41,9) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (41,34) strerror(int)
      -> EXTERN: (41,34) __errno_location(void)
    -> INLINE: (357,17) gz_decomp() (isz = 5691) (sz = 5702)
      -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
        -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
          -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
          -> (41,9) gz_error() (isz = 59) (sz = 71)
             [[ Callee not marked with inlining pragma  <1>]]
          -> EXTERN: (41,34) strerror(int)
          -> EXTERN: (41,34) __errno_location(void)
      -> (189,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (194,15) inflate() (isz = 5502) (sz = 5516)
        -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
        -> INLINE: inflate.c:(667,32) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(668,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(701,42) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(722,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(730,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(740,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(750,21) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(769,40) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(790,36) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(811,36) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(833,42) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(847,42) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
        -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
        -> INLINE: inflate.c:(1205,25) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(1205,25) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
           [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1268,13) adler32() (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(1268,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> (196,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (201,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (205,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(472,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(472,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(472,11)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(472,11)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(472,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(472,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(472,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(472,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(472,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(472,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(472,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(472,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(472,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(472,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(472,11)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(472,11)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(472,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(472,11)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(472,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(472,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(472,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(472,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(472,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(368,14) inlined into gzread.c(472,11)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(472,11)
      remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(472,11)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(472,11)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END

         LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(449,1):remark #34051: REGISTER ALLOCATION : [gzgetc] gzread.c:449

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1739
            Global    :     430
            Local     :    1309
        Regenerable   :     110
        Spilled       :     107
        
    Routine stack
        Variables     :     217 bytes*
            Reads     :     132 [1.43e-01 ~ 0.3%]
            Writes    :     159 [1.37e-01 ~ 0.3%]
        Spills        :     776 bytes*
            Reads     :     575 [5.78e-01 ~ 1.3%]
            Writes    :     280 [7.18e-01 ~ 1.6%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzgetc_()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzgetc_()) [130/166=78.3%] gzread.c(478,1)
  -> INLINE (PARTIAL): (479,12) gzgetc() (isz = 10) (sz = 10)
    -> PI_CLONE (455,5) gzgetc..0() (isz = 0) (sz = 0)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzread.c(478,1):remark #34051: REGISTER ALLOCATION : [gzgetc_] gzread.c:478

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzgetc..0()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzgetc..0()) [131/166=78.9%] gzread.c(449,1)
  -> INLINE: (472,11) gz_read() (isz = 5842) (sz = 5858)
    -> (309,13) gz_skip() (isz = 6092) (sz = 6102)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE (MANUAL): (325,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (340,17) gz_fetch() (isz = 6046) (sz = 6058)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (349,17) gz_load() (isz = 42) (sz = 56)
      -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
      -> (41,9) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (41,34) __errno_location(void)
      -> EXTERN: (41,34) strerror(int)
    -> INLINE: (357,17) gz_decomp() (isz = 5691) (sz = 5702)
      -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
        -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
          -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
          -> (41,9) gz_error() (isz = 59) (sz = 71)
             [[ Callee not marked with inlining pragma  <1>]]
          -> EXTERN: (41,34) __errno_location(void)
          -> EXTERN: (41,34) strerror(int)
      -> (189,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (194,15) inflate() (isz = 5502) (sz = 5516)
        -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
        -> INLINE: inflate.c:(667,32) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(668,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(701,42) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(722,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(730,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(740,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(750,21) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(769,40) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(790,36) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(811,36) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(833,42) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(847,42) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
        -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
        -> INLINE: inflate.c:(1205,25) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(1205,25) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(1268,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1268,13) adler32() (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
      -> (196,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (201,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (205,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(472,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(472,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(472,11)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(472,11)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(472,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(472,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(472,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(472,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(472,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(472,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(472,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(472,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(472,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(472,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(472,11)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(472,11)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(472,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(472,11)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(472,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(472,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(472,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(472,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(472,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(368,14) inlined into gzread.c(472,11)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(472,11)
      remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(472,11)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(472,11)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END

         LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(449,1):remark #34051: REGISTER ALLOCATION : [gzgetc..0] gzread.c:449

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1738
            Global    :     430
            Local     :    1308
        Regenerable   :     109
        Spilled       :     111
        
    Routine stack
        Variables     :     217 bytes*
            Reads     :     132 [1.43e-01 ~ 0.3%]
            Writes    :     159 [1.37e-01 ~ 0.3%]
        Spills        :     808 bytes*
            Reads     :     576 [5.75e-01 ~ 1.3%]
            Writes    :     289 [7.23e-01 ~ 1.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzungetc()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzungetc()) [132/166=79.5%] gzread.c(486,1)
  -> INLINE: (502,13) gz_skip() (isz = 6092) (sz = 6102)
    -> INLINE: (284,17) gz_fetch() (isz = 6046) (sz = 6058)
      -> INLINE: (237,17) gz_look() (isz = 249) (sz = 262)
        -> EXTERN: (99,38) malloc(size_t)
        -> EXTERN: (100,39) malloc(size_t)
        -> EXTERN: (102,13) free(void *)
        -> EXTERN: (103,13) free(void *)
        -> (104,13) gz_error() (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (115,13) inflateInit2_() (isz = 58) (sz = 74)
           [[ Callee not marked with inlining pragma  <1>]]
        -> EXTERN: (116,13) free(void *)
        -> EXTERN: (117,13) free(void *)
        -> (119,13) gz_error() (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (126,13) gz_avail() (isz = 103) (sz = 112)
          -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
            -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
            -> (41,9) gz_error() (isz = 59) (sz = 71)
               [[ Callee not marked with inlining pragma  <1>]]
            -> EXTERN: (41,34) __errno_location(void)
            -> EXTERN: (41,34) strerror(int)
        -> (141,9) inflateReset() (isz = 40) (sz = 48)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (161,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (243,17) gz_load() (isz = 42) (sz = 56)
        -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
        -> (41,9) gz_error() (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> EXTERN: (41,34) __errno_location(void)
        -> EXTERN: (41,34) strerror(int)
      -> INLINE: (251,17) gz_decomp() (isz = 5691) (sz = 5702)
        -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
          -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
            -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
            -> (41,9) gz_error() (isz = 59) (sz = 71)
               [[ Callee not marked with inlining pragma  <1>]]
            -> EXTERN: (41,34) __errno_location(void)
            -> EXTERN: (41,34) strerror(int)
        -> (189,13) gz_error() (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (194,15) inflate() (isz = 5502) (sz = 5516)
          -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
          -> INLINE: inflate.c:(667,32) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(668,17) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(701,42) adler32() (isz = 341) (sz = 352)
            -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
          -> INLINE: inflate.c:(722,17) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(730,17) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(740,17) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(750,21) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: inflate.c:(769,40) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(790,36) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(811,36) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(833,42) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(847,42) adler32() (isz = 341) (sz = 352)
            -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
          -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
          -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
          -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
          -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
          -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
          -> INLINE: inflate.c:(1205,25) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(1205,25) adler32() (isz = 341) (sz = 352)
            -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
          -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(1268,13) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> inflate.c:(1268,13) adler32() (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
        -> (196,13) gz_error() (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (201,13) gz_error() (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (205,13) gz_error() (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
  -> (522,9) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(502,13)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(502,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(502,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(502,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(502,13)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(502,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(502,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(502,13)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(502,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(502,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(502,13)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(502,13)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(502,13)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(502,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(502,13)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(502,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(502,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(502,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(502,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(502,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(502,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(502,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(502,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(530,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable dest was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(266,5) inlined into gzread.c(502,13)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(254,31) inlined into gzread.c(502,13)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(502,13)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(502,13)
            remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate

               LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(502,13)
                  remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
                  remark #17102: loop was not parallelized: not a parallelization candidate
               LOOP END
            LOOP END

            LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(486,1):remark #34051: REGISTER ALLOCATION : [gzungetc] gzread.c:486

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    1864
            Global    :     478
            Local     :    1386
        Regenerable   :     136
        Spilled       :     112
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :     131 [0.00e+00 ~ 0.0%]
            Writes    :     159 [0.00e+00 ~ 0.0%]
        Spills        :     840 bytes*
            Reads     :     733 [1.90e-01 ~ 0.5%]
            Writes    :     281 [2.03e-01 ~ 0.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzgets()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzgets()) [133/166=80.1%] gzread.c(547,1)
  -> (566,13) gz_skip() (isz = 6092) (sz = 6102)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (577,35) gz_fetch() (isz = 6046) (sz = 6058)
    -> INLINE: (237,17) gz_look() (isz = 249) (sz = 262)
      -> EXTERN: (99,38) malloc(size_t)
      -> EXTERN: (100,39) malloc(size_t)
      -> EXTERN: (102,13) free(void *)
      -> EXTERN: (103,13) free(void *)
      -> (104,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (115,13) inflateInit2_() (isz = 58) (sz = 74)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (116,13) free(void *)
      -> EXTERN: (117,13) free(void *)
      -> (119,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (126,13) gz_avail() (isz = 103) (sz = 112)
        -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
          -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
          -> (41,9) gz_error() (isz = 59) (sz = 71)
             [[ Callee not marked with inlining pragma  <1>]]
          -> EXTERN: (41,34) strerror(int)
          -> EXTERN: (41,34) __errno_location(void)
      -> (141,9) inflateReset() (isz = 40) (sz = 48)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (161,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (243,17) gz_load() (isz = 42) (sz = 56)
      -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
      -> (41,9) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (41,34) strerror(int)
      -> EXTERN: (41,34) __errno_location(void)
    -> INLINE: (251,17) gz_decomp() (isz = 5691) (sz = 5702)
      -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
        -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
          -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
          -> (41,9) gz_error() (isz = 59) (sz = 71)
             [[ Callee not marked with inlining pragma  <1>]]
          -> EXTERN: (41,34) strerror(int)
          -> EXTERN: (41,34) __errno_location(void)
      -> (189,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (194,15) inflate() (isz = 5502) (sz = 5516)
        -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
        -> INLINE: inflate.c:(667,32) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(668,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(701,42) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(722,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(730,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(740,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(750,21) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(769,40) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(790,36) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(811,36) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(833,42) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(847,42) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
        -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
        -> INLINE: inflate.c:(1205,25) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(1205,25) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
           [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1268,13) adler32() (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(1268,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> (196,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (201,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (205,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (586,32) memchr(const void *, int, size_t)
  -> INLINE (MANUAL): (591,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(577,35)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(577,35)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(577,35)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(577,35)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(577,35)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(577,35)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(577,35)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(577,35)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(577,35)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(577,35)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(577,35)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(577,35)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(577,35)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(577,35)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(577,35)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(577,35)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(577,35)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(577,35)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(577,35)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(577,35)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(577,35)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(577,35)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(577,35)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(577,35)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(577,35)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(577,35)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(577,35)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(577,35)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(577,35)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(577,35)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(577,35)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(577,35)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(577,35)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(577,35)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(577,35)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(577,35)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(597,14)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(254,31) inlined into gzread.c(577,35)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(577,35)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(577,35)
            remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(577,35)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(577,35)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate

               LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(577,35)
                  remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
                  remark #17102: loop was not parallelized: not a parallelization candidate
               LOOP END
            LOOP END

            LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(577,35)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(577,35)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(577,35)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(577,35)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(577,35)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(577,35)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(547,1):remark #34051: REGISTER ALLOCATION : [gzgets] gzread.c:547

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    1851
            Global    :     475
            Local     :    1376
        Regenerable   :     133
        Spilled       :     113
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :     131 [0.00e+00 ~ 0.0%]
            Writes    :     159 [0.00e+00 ~ 0.0%]
        Spills        :     840 bytes*
            Reads     :     733 [4.15e-01 ~ 0.9%]
            Writes    :     294 [6.68e-01 ~ 1.4%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzdirect()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzdirect()) [134/166=80.7%] gzread.c(609,1)
  -> (620,15) gz_look() (isz = 249) (sz = 262)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzread.c(609,1):remark #34051: REGISTER ALLOCATION : [gzdirect] gzread.c:609

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rax rdi r12]
        
    Routine temporaries
        Total         :      12
            Global    :       7
            Local     :       5
        Regenerable   :       1
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_look()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_look()) [135/166=81.3%] gzread.c(93,1)
  -> EXTERN: (99,38) malloc(size_t)
  -> EXTERN: (100,39) malloc(size_t)
  -> EXTERN: (102,13) free(void *)
  -> EXTERN: (103,13) free(void *)
  -> (104,13) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (115,13) inflateInit2_() (isz = 58) (sz = 74)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (116,13) free(void *)
  -> EXTERN: (117,13) free(void *)
  -> (119,13) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (126,13) gz_avail() (isz = 103) (sz = 112)
    -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
      -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
      -> (41,9) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (41,34) strerror(int)
      -> EXTERN: (41,34) __errno_location(void)
  -> (141,9) inflateReset() (isz = 40) (sz = 48)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (161,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(126,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(126,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(126,13)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(126,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzread.c(93,1):remark #34051: REGISTER ALLOCATION : [gz_look] gzread.c:93

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   14[ rax rdx rcx rbx rbp rsi rdi r8-r10 r12-r15]
        
    Routine temporaries
        Total         :     103
            Global    :      34
            Local     :      69
        Regenerable   :      22
        Spilled       :       6
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      24 bytes*
            Reads     :       6 [3.15e-01 ~ 0.7%]
            Writes    :       3 [3.15e-01 ~ 0.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: vsnprintf(char *__restrict__, size_t, const char *__restrict__, struct __va_list_tag *)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (vsnprintf(char *__restrict__, size_t, const char *__restrict__, struct __va_list_tag *))/usr/include/x86_64-linux-gnu/bits/stdio2.h(79,1)

===========================================================================

Begin optimization report for: memcpy(void *__restrict__, const void *__restrict__, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (memcpy(void *__restrict__, const void *__restrict__, size_t))/usr/include/x86_64-linux-gnu/bits/string_fortified.h(33,1)

===========================================================================

Begin optimization report for: memset(void *, int, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (memset(void *, int, size_t))/usr/include/x86_64-linux-gnu/bits/string_fortified.h(60,1)

===========================================================================

Begin optimization report for: gz_comp()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gz_comp()) gzwrite.c(76,1)

===========================================================================

Begin optimization report for: gz_write()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gz_write()) gzwrite.c(182,1)

===========================================================================

Begin optimization report for: gz_comp..0()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_comp..0()) [141/166=84.9%] gzwrite.c(76,1)
  CLONED FROM: gz_comp()(X,0)
  -> (82,29) gz_init() (isz = 92) (sz = 102)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (89,20) write(int, const void *, size_t)
  -> (91,17) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (91,42) __errno_location(void)
  -> EXTERN: (91,42) strerror(int)
  -> EXTERN: (110,24) write(int, const void *, size_t)
  -> (112,21) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (112,46) __errno_location(void)
  -> EXTERN: (112,46) strerror(int)
  -> INLINE: (126,15) deflate() (isz = 9099) (sz = 9125)
    -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(838,23) adler32() (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(851,23) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(894,31) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(909,17) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(922,13) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(933,21) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(944,13) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(955,21) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(966,13) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(981,27) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
      -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
        -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1178,23) adler32() (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1786,9) read_buf() (isz = 46) (sz = 58)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1810,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
      -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
        -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
        -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32() (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
        -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
        -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
          -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
        -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
          -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
        -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
        -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
           [[ Callee not marked with inlining pragma  <1>]]
        -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (2118,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> (2118,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (2122,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (2122,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.3[(EXPR_CONV.SI32.SI64(s.776_V$d4.3.37.2476->level_V$3f))]
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
      -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
    -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (128,13) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
    -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(87,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(126,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(126,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(126,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(126,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(126,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(126,15)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(126,15)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(126,15)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(126,15)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(126,15)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(126,15)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(126,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(126,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(126,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(126,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(126,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(126,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(126,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(126,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(126,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(126,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(126,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(126,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(126,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(126,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(126,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(126,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(126,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(126,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(126,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(126,15)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(126,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(126,15)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(126,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(126,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(126,15)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(126,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(76,1):remark #34051: REGISTER ALLOCATION : [gz_comp..0] gzwrite.c:76

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2907
            Global    :     737
            Local     :    2170
        Regenerable   :     117
        Spilled       :      74
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [2.23e-01 ~ 0.0%]
            Writes    :      48 [3.27e+00 ~ 0.4%]
        Spills        :     544 bytes*
            Reads     :     176 [1.80e+01 ~ 2.2%]
            Writes    :     137 [2.20e+01 ~ 2.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzwrite()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzwrite()) [142/166=85.5%] gzwrite.c(250,1)
  -> (265,9) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (270,17) gz_write() (isz = 9388) (sz = 9405)
    -> (190,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (196,13) gz_zero() (isz = 9326) (sz = 9337)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE (MANUAL): (213,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> CP_CLONE (218,24) gz_comp..0() (isz = 9270) (sz = 9284)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (224,37) gz_comp() (isz = 9270) (sz = 9284)
      -> (82,29) gz_init() (isz = 92) (sz = 102)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (89,20) write(int, const void *, size_t)
      -> (91,17) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (91,42) strerror(int)
      -> EXTERN: (91,42) __errno_location(void)
      -> EXTERN: (110,24) write(int, const void *, size_t)
      -> (112,21) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (112,46) strerror(int)
      -> EXTERN: (112,46) __errno_location(void)
      -> INLINE: (126,15) deflate() (isz = 9099) (sz = 9125)
        -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(838,23) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(851,23) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(894,31) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(909,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(922,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(933,21) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(944,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(955,21) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(966,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(981,27) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
          -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
            -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32() (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1786,9) read_buf() (isz = 46) (sz = 58)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1810,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
          -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
            -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
            -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
              -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
              -> (1178,23) adler32() (isz = 341) (sz = 352)
                 [[ Callee not marked with inlining pragma  <1>]]
              -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
                -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                   [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
            -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
            -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
            -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
              -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
                -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
                -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                  -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
            -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
              -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
              -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
            -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
               [[ Callee not marked with inlining pragma  <1>]]
            -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
          -> (2118,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (2118,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> (2122,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> (2122,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.3[(EXPR_CONV.SI32.SI64(s.776_V$d4.3.37.2064->level_V$3f))]
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
        -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> (128,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
        -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
           [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (235,17) gz_comp..0() (isz = 9270) (sz = 9284)
       [[ Inlining inhibited by overrideable criterion  <2>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(201,5) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(270,17)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(270,17)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(270,17)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(270,17)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(270,17)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(270,17)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(270,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(270,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(270,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(270,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(270,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(270,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(270,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(270,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(270,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(270,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(270,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(270,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(270,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(270,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(270,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(270,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(270,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(270,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(270,17)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(270,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(270,17)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at gzwrite.c(228,9) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(270,17)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(270,17)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(270,17)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(250,1):remark #34051: REGISTER ALLOCATION : [gzwrite] gzwrite.c:250

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2952
            Global    :     756
            Local     :    2196
        Regenerable   :     120
        Spilled       :      79
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [7.73e-04 ~ 0.0%]
            Writes    :      48 [1.13e-02 ~ 0.0%]
        Spills        :     584 bytes*
            Reads     :     180 [6.69e-02 ~ 0.1%]
            Writes    :     136 [9.61e-02 ~ 0.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzfwrite()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzfwrite()) [143/166=86.1%] gzwrite.c(279,1)
  -> (295,9) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (300,18) gz_write() (isz = 9388) (sz = 9405)
    -> (190,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (196,13) gz_zero() (isz = 9326) (sz = 9337)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE (MANUAL): (213,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> CP_CLONE (218,24) gz_comp..0() (isz = 9270) (sz = 9284)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (224,37) gz_comp() (isz = 9270) (sz = 9284)
      -> (82,29) gz_init() (isz = 92) (sz = 102)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (89,20) write(int, const void *, size_t)
      -> (91,17) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (91,42) strerror(int)
      -> EXTERN: (91,42) __errno_location(void)
      -> EXTERN: (110,24) write(int, const void *, size_t)
      -> (112,21) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (112,46) strerror(int)
      -> EXTERN: (112,46) __errno_location(void)
      -> INLINE: (126,15) deflate() (isz = 9099) (sz = 9125)
        -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(838,23) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(851,23) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(894,31) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(909,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(922,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(933,21) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(944,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(955,21) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(966,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(981,27) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
          -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
            -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32() (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1786,9) read_buf() (isz = 46) (sz = 58)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1810,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
          -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
            -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
            -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
              -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
              -> (1178,23) adler32() (isz = 341) (sz = 352)
                 [[ Callee not marked with inlining pragma  <1>]]
              -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
                -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                   [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
            -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
            -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
            -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
              -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
                -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
                -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                  -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
            -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
              -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
              -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
            -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
               [[ Callee not marked with inlining pragma  <1>]]
            -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
          -> (2118,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (2118,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> (2122,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> (2122,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.3[(EXPR_CONV.SI32.SI64(s.776_V$d4.3.37.2156->level_V$3f))]
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
        -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> (128,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
        -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
           [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (235,17) gz_comp..0() (isz = 9270) (sz = 9284)
       [[ Inlining inhibited by overrideable criterion  <2>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(201,5) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(300,18)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(300,18)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(300,18)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(300,18)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(300,18)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(300,18)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(300,18)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(300,18)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(300,18)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(300,18)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(300,18)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(300,18)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(300,18)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(300,18)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(300,18)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(300,18)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(300,18)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(300,18)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(300,18)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(300,18)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(300,18)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(300,18)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(300,18)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(300,18)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(300,18)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(300,18)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(300,18)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at gzwrite.c(228,9) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(300,18)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(300,18)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(300,18)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(279,1):remark #34051: REGISTER ALLOCATION : [gzfwrite] gzwrite.c:279

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2961
            Global    :     758
            Local     :    2203
        Regenerable   :     122
        Spilled       :      83
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [1.70e-04 ~ 0.0%]
            Writes    :      48 [2.49e-03 ~ 0.0%]
        Spills        :     600 bytes*
            Reads     :     214 [1.98e-02 ~ 0.0%]
            Writes    :     157 [2.49e-02 ~ 0.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzputc()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzputc()) [144/166=86.7%] gzwrite.c(307,1)
  -> INLINE: (326,13) gz_zero() (isz = 9326) (sz = 9337)
    -> INLINE: (154,27) gz_comp() (isz = 9270) (sz = 9284)
      -> (82,29) gz_init() (isz = 92) (sz = 102)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (89,20) write(int, const void *, size_t)
      -> (91,17) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (91,42) strerror(int)
      -> EXTERN: (91,42) __errno_location(void)
      -> EXTERN: (110,24) write(int, const void *, size_t)
      -> (112,21) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (112,46) strerror(int)
      -> EXTERN: (112,46) __errno_location(void)
      -> INLINE: (126,15) deflate() (isz = 9099) (sz = 9125)
        -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(838,23) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(851,23) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(894,31) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(909,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(922,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(933,21) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(944,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(955,21) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(966,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(981,27) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
          -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
            -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32() (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1786,9) read_buf() (isz = 46) (sz = 58)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1810,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
          -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
            -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
            -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
              -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
              -> (1178,23) adler32() (isz = 341) (sz = 352)
                 [[ Callee not marked with inlining pragma  <1>]]
              -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
                -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                   [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
            -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
            -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
            -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
              -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
                -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
                -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                  -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
            -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
              -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
              -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
            -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
               [[ Callee not marked with inlining pragma  <1>]]
            -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
          -> (2118,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (2118,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> (2122,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> (2122,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.3[(EXPR_CONV.SI32.SI64(s.776_V$d4.3.37.1972->level_V$3f))]
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
        -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> (128,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
        -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
           [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (163,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> CP_CLONE (169,13) gz_comp..0() (isz = 9270) (sz = 9284)
       [[ Inlining inhibited by overrideable criterion  <2>]]
  -> CP_CLONE (346,9) gz_write..0() (isz = 9388) (sz = 9405)
     [[ Inlining inhibited by overrideable criterion  <2>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(326,13)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(326,13)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(326,13)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(326,13)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(326,13)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(326,13)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(326,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(326,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(326,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(326,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(326,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(326,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(326,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(326,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(326,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(326,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(326,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(326,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(326,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(326,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(326,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(326,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(326,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(326,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(326,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(326,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(326,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at gzwrite.c(159,5) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(326,13)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(326,13)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(326,13)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(307,1):remark #34051: REGISTER ALLOCATION : [gzputc] gzwrite.c:307

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2939
            Global    :     750
            Local     :    2189
        Regenerable   :     120
        Spilled       :      80
        
    Routine stack
        Variables     :      97 bytes*
            Reads     :       3 [2.43e-03 ~ 0.0%]
            Writes    :      49 [1.57e-01 ~ 0.3%]
        Spills        :     592 bytes*
            Reads     :     211 [3.62e-01 ~ 0.8%]
            Writes    :     154 [4.40e-01 ~ 0.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_write..0()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_write..0()) [145/166=87.3%] gzwrite.c(182,1)
  CLONED FROM: gz_write()(X,X,0x00000001,0x00000000)
  -> (190,29) gz_init() (isz = 92) (sz = 102)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (196,13) gz_zero() (isz = 9326) (sz = 9337)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE (MANUAL): (213,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> CP_CLONE (218,24) gz_comp..0() (isz = 9270) (sz = 9284)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (224,37) gz_comp() (isz = 9270) (sz = 9284)
    -> (82,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (89,20) write(int, const void *, size_t)
    -> (91,17) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (91,42) strerror(int)
    -> EXTERN: (91,42) __errno_location(void)
    -> EXTERN: (110,24) write(int, const void *, size_t)
    -> (112,21) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (112,46) strerror(int)
    -> EXTERN: (112,46) __errno_location(void)
    -> INLINE: (126,15) deflate() (isz = 9099) (sz = 9125)
      -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(838,23) adler32() (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(851,23) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(894,31) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(909,17) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(922,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(933,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(944,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(955,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(966,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(981,27) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
        -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32() (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1786,9) read_buf() (isz = 46) (sz = 58)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1810,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
        -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
          -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
          -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32() (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
          -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
          -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
            -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
          -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
            -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
          -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
             [[ Callee not marked with inlining pragma  <1>]]
          -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
        -> (2118,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2118,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2122,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2122,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.3[(EXPR_CONV.SI32.SI64(s.776_V$d4.3.37.2567->level_V$3f))]
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
      -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (128,13) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
      -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
         [[ Callee not marked with inlining pragma  <1>]]
  -> CP_CLONE (235,17) gz_comp..0() (isz = 9270) (sz = 9284)
     [[ Inlining inhibited by overrideable criterion  <2>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(201,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(224,37)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(224,37)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(224,37)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(224,37)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(224,37)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(224,37)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(224,37)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(224,37)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(224,37)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(224,37)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(224,37)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(224,37)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(224,37)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(224,37)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(224,37)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(224,37)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(224,37)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(224,37)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(224,37)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(224,37)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(224,37)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(224,37)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(224,37)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(224,37)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(224,37)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(224,37)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(224,37)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(224,37)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(224,37)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(224,37)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(182,1):remark #34051: REGISTER ALLOCATION : [gz_write..0] gzwrite.c:182

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2944
            Global    :     752
            Local     :    2192
        Regenerable   :     119
        Spilled       :      80
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [3.47e-03 ~ 0.0%]
            Writes    :      48 [5.08e-02 ~ 0.0%]
        Spills        :     592 bytes*
            Reads     :     238 [4.54e-01 ~ 0.4%]
            Writes    :     172 [5.25e-01 ~ 0.4%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzputs()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzputs()) [146/166=88.0%] gzwrite.c(355,1)
  -> EXTERN: (370,11) strlen(const char *)
  -> INLINE: (371,11) gz_write() (isz = 9388) (sz = 9405)
    -> (190,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (196,13) gz_zero() (isz = 9326) (sz = 9337)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE (MANUAL): (213,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> CP_CLONE (218,24) gz_comp..0() (isz = 9270) (sz = 9284)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (224,37) gz_comp() (isz = 9270) (sz = 9284)
      -> (82,29) gz_init() (isz = 92) (sz = 102)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (89,20) write(int, const void *, size_t)
      -> (91,17) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (91,42) strerror(int)
      -> EXTERN: (91,42) __errno_location(void)
      -> EXTERN: (110,24) write(int, const void *, size_t)
      -> (112,21) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (112,46) strerror(int)
      -> EXTERN: (112,46) __errno_location(void)
      -> INLINE: (126,15) deflate() (isz = 9099) (sz = 9125)
        -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(838,23) adler32() (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(851,23) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(894,31) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(909,17) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(922,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(933,21) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(944,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(955,21) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(966,13) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(981,27) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
          -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
            -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32() (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1786,9) read_buf() (isz = 46) (sz = 58)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1810,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
          -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
            -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
            -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
              -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
              -> (1178,23) adler32() (isz = 341) (sz = 352)
                 [[ Callee not marked with inlining pragma  <1>]]
              -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
                -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                   [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
            -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
            -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
            -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
              -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
                -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
                -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                  -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
            -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
              -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
              -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
            -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
               [[ Callee not marked with inlining pragma  <1>]]
            -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
          -> (2118,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (2118,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> (2122,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> (2122,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.3[(EXPR_CONV.SI32.SI64(s.776_V$d4.3.37.2248->level_V$3f))]
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
        -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> (128,13) gz_error() (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
        -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
           [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (235,17) gz_comp..0() (isz = 9270) (sz = 9284)
       [[ Inlining inhibited by overrideable criterion  <2>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(201,5) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(371,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(371,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(371,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(371,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(371,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(371,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(371,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(371,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(371,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(371,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(371,11)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(371,11)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at gzwrite.c(228,9) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(371,11)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(371,11)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(371,11)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(355,1):remark #34051: REGISTER ALLOCATION : [gzputs] gzwrite.c:355

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2947
            Global    :     757
            Local     :    2190
        Regenerable   :     116
        Spilled       :      79
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [4.56e-04 ~ 0.0%]
            Writes    :      48 [6.67e-03 ~ 0.0%]
        Spills        :     592 bytes*
            Reads     :     198 [4.79e-02 ~ 0.1%]
            Writes    :     149 [6.46e-02 ~ 0.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzprintf(gzFile, const char *, ...)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzprintf(gzFile, const char *, ...)) [147/166=88.6%] gzwrite.c(452,1)
  -> EXTERN: (456,5) __builtin_stdarg_start
  -> (457,11) gzvprintf(gzFile, const char *, struct __va_list_tag *) (isz = 9395) (sz = 9412)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (458,5) __builtin_va_end


    Report from: Code generation optimizations [cg]

gzwrite.c(452,1):remark #34051: REGISTER ALLOCATION : [gzprintf] gzwrite.c:452

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      19
            Global    :      10
            Local     :       9
        Regenerable   :       4
        Spilled       :       0
        
    Routine stack
        Variables     :     200 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       4 [4.00e+00 ~ 18.2%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzvprintf(gzFile, const char *, struct __va_list_tag *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzvprintf(gzFile, const char *, struct __va_list_tag *)) [148/166=89.2%] gzwrite.c(380,1)
  -> (398,29) gz_init() (isz = 92) (sz = 102)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (404,13) gz_zero() (isz = 9326) (sz = 9337)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE (MANUAL): (428,11) vsnprintf(char *__restrict__, size_t, const char *__restrict__, struct __va_list_tag *) (isz = 7) (sz = 20)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(80,10) __builtin___vsnprintf_chk(char *, unsigned long, int, unsigned long, const char *, struct __va_list_tag *)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(81,9) __builtin_object_size(const void *, int)
  -> INLINE: (442,13) gz_comp() (isz = 9270) (sz = 9284)
    -> (82,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (89,20) write(int, const void *, size_t)
    -> (91,17) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (91,42) __errno_location(void)
    -> EXTERN: (91,42) strerror(int)
    -> EXTERN: (110,24) write(int, const void *, size_t)
    -> (112,21) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (112,46) __errno_location(void)
    -> EXTERN: (112,46) strerror(int)
    -> INLINE: (126,15) deflate() (isz = 9099) (sz = 9125)
      -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(838,23) adler32() (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(851,23) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(894,31) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(909,17) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(922,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(933,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(944,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(955,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(966,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(981,27) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
        -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32() (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1786,9) read_buf() (isz = 46) (sz = 58)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1810,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
        -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
          -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
          -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32() (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
          -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
          -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
            -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
          -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
            -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
          -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
             [[ Callee not marked with inlining pragma  <1>]]
          -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (2118,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2118,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.3[(EXPR_CONV.SI32.SI64(s.776_V$d4.3.37.1611->level_V$3f))]
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
      -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (128,13) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
      -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
         [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (444,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(442,13)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(442,13)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(442,13)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(442,13)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(442,13)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(442,13)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(442,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(442,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(442,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(442,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(442,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(442,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(442,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(442,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(442,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(442,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(442,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(442,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(442,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(442,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(442,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(442,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(442,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(442,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(442,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(442,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(442,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(442,13)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(442,13)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(442,13)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(380,1):remark #34051: REGISTER ALLOCATION : [gzvprintf] gzwrite.c:380

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2952
            Global    :     751
            Local     :    2201
        Regenerable   :     116
        Spilled       :      80
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [7.74e-03 ~ 0.0%]
            Writes    :      48 [1.13e-01 ~ 0.2%]
        Spills        :     584 bytes*
            Reads     :     191 [6.79e-01 ~ 1.0%]
            Writes    :     141 [8.86e-01 ~ 1.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzflush()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzflush()) [149/166=89.8%] gzwrite.c(556,1)
  -> (575,13) gz_zero() (isz = 9326) (sz = 9337)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (580,11) gz_comp() (isz = 9270) (sz = 9284)
    -> (82,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (89,20) write(int, const void *, size_t)
    -> (91,17) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (91,42) __errno_location(void)
    -> EXTERN: (91,42) strerror(int)
    -> EXTERN: (110,24) write(int, const void *, size_t)
    -> (112,21) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (112,46) __errno_location(void)
    -> EXTERN: (112,46) strerror(int)
    -> INLINE: (126,15) deflate() (isz = 9099) (sz = 9125)
      -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(838,23) adler32() (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(851,23) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(894,31) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(909,17) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(922,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(933,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(944,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(955,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(966,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(981,27) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
        -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32() (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1786,9) read_buf() (isz = 46) (sz = 58)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1810,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
        -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
          -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
          -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32() (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
          -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
          -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
            -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
          -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
            -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
          -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
             [[ Callee not marked with inlining pragma  <1>]]
          -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (2118,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2118,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.3[(EXPR_CONV.SI32.SI64(s.776_V$d4.3.37.1701->level_V$3f))]
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
      -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (128,13) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
      -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(580,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(580,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(580,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(580,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(580,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(580,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(580,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(580,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(580,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(580,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(580,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(580,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(580,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(580,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(580,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(580,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(580,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(580,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(580,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(580,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(580,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(580,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(580,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(580,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(580,11)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(580,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(580,11)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(580,11)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(580,11)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(580,11)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(556,1):remark #34051: REGISTER ALLOCATION : [gzflush] gzwrite.c:556

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    3011
            Global    :     757
            Local     :    2254
        Regenerable   :     109
        Spilled       :      85
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [2.57e-02 ~ 0.0%]
            Writes    :      48 [3.76e-01 ~ 0.3%]
        Spills        :     648 bytes*
            Reads     :     260 [2.67e+00 ~ 2.1%]
            Writes    :     156 [3.26e+00 ~ 2.6%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzsetparams()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzsetparams()) [150/166=90.4%] gzwrite.c(589,1)
  -> (610,13) gz_zero() (isz = 9326) (sz = 9337)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (617,31) gz_comp() (isz = 9270) (sz = 9284)
    -> (82,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (89,20) write(int, const void *, size_t)
    -> (91,17) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (91,42) __errno_location(void)
    -> EXTERN: (91,42) strerror(int)
    -> EXTERN: (110,24) write(int, const void *, size_t)
    -> (112,21) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (112,46) __errno_location(void)
    -> EXTERN: (112,46) strerror(int)
    -> INLINE: (126,15) deflate() (isz = 9099) (sz = 9125)
      -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(838,23) adler32() (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(851,23) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(894,31) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(909,17) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(922,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(933,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(944,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(955,21) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(966,13) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(981,27) crc32() (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
        -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32() (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1786,9) read_buf() (isz = 46) (sz = 58)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1810,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
        -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
          -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
          -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32() (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
          -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
          -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
            -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
          -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
            -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
          -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
             [[ Callee not marked with inlining pragma  <1>]]
          -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (2118,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2118,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.3[(EXPR_CONV.SI32.SI64(s.776_V$d4.3.37.1791->level_V$3f))]
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
      -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (128,13) gz_error() (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
      -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
         [[ Callee not marked with inlining pragma  <1>]]
  -> (619,9) deflateParams() (isz = 9246) (sz = 9261)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(617,31)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(617,31)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(617,31)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(617,31)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(617,31)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(617,31)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(617,31)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(617,31)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(617,31)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(617,31)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(617,31)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(617,31)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(617,31)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(617,31)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(617,31)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(617,31)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(617,31)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(617,31)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(617,31)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(617,31)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(617,31)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(617,31)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(617,31)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(617,31)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(617,31)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(617,31)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(617,31)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(617,31)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(617,31)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(617,31)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(589,1):remark #34051: REGISTER ALLOCATION : [gzsetparams] gzwrite.c:589

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2911
            Global    :     739
            Local     :    2172
        Regenerable   :     109
        Spilled       :      76
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [2.21e-02 ~ 0.0%]
            Writes    :      48 [3.23e-01 ~ 0.3%]
        Spills        :     576 bytes*
            Reads     :     195 [2.03e+00 ~ 1.8%]
            Writes    :     139 [2.64e+00 ~ 2.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateParams()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateParams()) [151/166=91.0%] deflate.c(572,1)
  -> (576,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (592,19) deflate() (isz = 9099) (sz = 9125)
    -> (770,9) deflateStateCheck() (isz = 46) (sz = 55)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (787,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (831,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: (835,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: (836,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: (838,23) adler32() (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> (842,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (851,23) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (868,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (894,31) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (909,17) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (911,17) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (922,13) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (933,21) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (934,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (944,13) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (955,21) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (956,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (966,13) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (973,17) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (981,27) crc32() (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (986,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (1000,34) deflate_stored() (isz = 676) (sz = 687)
      -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
        -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1178,23) adler32() (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1786,9) read_buf() (isz = 46) (sz = 58)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1810,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (1001,50) deflate_huff() (isz = 11827) (sz = 11841)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (1002,41) deflate_rle() (isz = 6524) (sz = 6538)
      -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
        -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
        -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32() (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32() (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
        -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
        -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
          -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
        -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
          -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
        -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
        -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
           [[ Callee not marked with inlining pragma  <1>]]
        -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
      -> (2118,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (2118,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> (2122,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> (2122,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INDIRECT: (1003,18)  func_V$11_2.0.3[(EXPR_CONV.SI32.SI64(s.776_V$d4.3.37.1047->level_V$3f))]
       [[ Callee not marked with inlining pragma  <1>]]
    -> (1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
      -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> (1038,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (1064,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: (1065,9) putShortMSB() (isz = 23) (sz = 30)
    -> (1067,5) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (601,17) slide_hash() (isz = 51) (sz = 56)
  -> INLINE (MANUAL): (603,17) memset(void *, int, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(904,13) inlined into deflate.c(592,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into deflate.c(592,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into deflate.c(592,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into deflate.c(592,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into deflate.c(592,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(592,19)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(592,19)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(592,19)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(592,19)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(592,19)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(592,19)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into deflate.c(592,19)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into deflate.c(592,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(592,19)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(592,19)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(592,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(592,19)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(592,19)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(592,19)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(592,19)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(592,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(592,19)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(592,19)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(592,19)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(592,19)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(592,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(592,19)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(592,19)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(592,19)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(592,19)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(592,19)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(592,19)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(592,19)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(592,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(592,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at deflate.c(600,13)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at deflate.c(600,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #25453: Loop Reversed
   remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
   remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 1.667
   remark #15301: REVERSED LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 8 
   remark #15477: vector cost: 1.500 
   remark #15478: estimated potential speedup: 4.370 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at deflate.c(600,13)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(601,17)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(601,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #25453: Loop Reversed
   remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
   remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 1.667
   remark #15301: REVERSED LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 8 
   remark #15477: vector cost: 1.500 
   remark #15478: estimated potential speedup: 4.370 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(601,17)
<Remainder loop for vectorization>
LOOP END


Non-optimizable loops:


LOOP BEGIN at deflate.c(2114,9) inlined into deflate.c(592,19)
   remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at trees.c(1143,5) inlined into deflate.c(592,19)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(572,1):remark #34051: REGISTER ALLOCATION : [deflateParams] deflate.c:572

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :    2983
            Global    :     752
            Local     :    2231
        Regenerable   :     116
        Spilled       :      80
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [9.18e-03 ~ 0.0%]
            Writes    :      48 [1.34e-01 ~ 0.2%]
        Spills        :     576 bytes*
            Reads     :     197 [7.60e-01 ~ 1.0%]
            Writes    :     139 [8.66e-01 ~ 1.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateReset2()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateReset2()) [152/166=91.6%] inflate.c(160,1)
  -> INLINE: (165,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> INDIRECT-: (185,9)  strm_631_V$43.6.56->zfree_V$88
     [[ Unable to inline indirect callsite  <3>]]
  -> (192,12) inflateReset() (isz = 40) (sz = 48)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

inflate.c(160,1):remark #34051: REGISTER ALLOCATION : [inflateReset2] inflate.c:160

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rsi rdi r12-r15]
        
    Routine temporaries
        Total         :      23
            Global    :      13
            Local     :      10
        Regenerable   :       2
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_init()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_init()) [153/166=92.2%] gzwrite.c(19,1)
  -> EXTERN: (24,34) malloc(size_t)
  -> (26,9) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (33,39) malloc(size_t)
  -> EXTERN: (35,13) free(void *)
  -> (36,13) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (44,15) deflateInit2_() (isz = 223) (sz = 249)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (47,13) free(void *)
  -> EXTERN: (48,13) free(void *)
  -> (49,13) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzwrite.c(19,1):remark #34051: REGISTER ALLOCATION : [gz_init] gzwrite.c:19

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   10[ rax rdx rcx rsi rdi r8-r10 r14-r15]
        
    Routine temporaries
        Total         :      56
            Global    :      15
            Local     :      41
        Regenerable   :      18
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_error()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_error()) [154/166=92.8%] gzlib.c(583,1)
  -> EXTERN: (587,13) free(void *)
  -> EXTERN: (605,31) malloc(size_t)
  -> EXTERN: (605,38) strlen(const char *)
  -> EXTERN: (605,60) strlen(const char *)
  -> INLINE: (611,11) snprintf(char *__restrict__, size_t, const char *__restrict__, ...) (isz = 10) (sz = 21)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(67,10) __builtin___snprintf_chk(char *, unsigned long, int, unsigned long, const char *, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,8) __builtin_object_size(const void *, int)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,28) __builtin_va_arg_pack(void)
  -> EXTERN: (611,32) strlen(const char *)
  -> EXTERN: (611,54) strlen(const char *)


    Report from: Code generation optimizations [cg]

gzlib.c(583,1):remark #34051: REGISTER ALLOCATION : [gz_error] gzlib.c:583

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   10[ rax rdx rcx rbp rsi rdi r8-r9 r13 r15]
        
    Routine temporaries
        Total         :      42
            Global    :      19
            Local     :      23
        Regenerable   :       6
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzclearerr()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzclearerr()) [155/166=93.4%] gzlib.c(555,1)
  -> (570,5) gz_error() (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzlib.c(555,1):remark #34051: REGISTER ALLOCATION : [gzclearerr] gzlib.c:555

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      13
            Global    :       8
            Local     :       5
        Regenerable   :       3
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzerror()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzerror()) [156/166=94.0%] gzlib.c(535,1)


    Report from: Code generation optimizations [cg]

gzlib.c(535,1):remark #34051: REGISTER ALLOCATION : [gzerror] gzlib.c:535

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      18
            Global    :      10
            Local     :       8
        Regenerable   :       3
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: zError()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (zError()) [157/166=94.6%] zutil.c(135,1)


    Report from: Code generation optimizations [cg]

zutil.c(135,1):remark #34051: REGISTER ALLOCATION : [zError] zutil.c:135

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :      13
            Global    :       0
            Local     :      13
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: init_block()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (init_block()) [158/166=95.2%] trees.c(409,1)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at trees.c(413,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <s->freq[n]>, stride is 2   [ trees.c(413,36) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15453: unmasked strided stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 3.000 
   remark #15478: estimated potential speedup: 0.670 
   remark #15488: --- end vector cost summary ---
   remark #25438: unrolled without remainder by 2  
   remark #25015: Estimate of max trip count of loop=286
LOOP END

LOOP BEGIN at trees.c(414,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <s->freq[n]>, stride is 2   [ trees.c(414,36) ]
   remark #15305: vectorization support: vector length 2
   remark #15453: unmasked strided stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 3.000 
   remark #15478: estimated potential speedup: 0.660 
   remark #15488: --- end vector cost summary ---
   remark #25438: unrolled without remainder by 2  
   remark #25015: Estimate of max trip count of loop=30
LOOP END

LOOP BEGIN at trees.c(415,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <s->freq[n]>, stride is 2   [ trees.c(415,36) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 9
   remark #15453: unmasked strided stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 3.000 
   remark #15478: estimated potential speedup: 0.670 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(415,5)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

    Report from: Code generation optimizations [cg]

trees.c(409,1):remark #34051: REGISTER ALLOCATION : [init_block] trees.c:409

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rcx rdi]
        
    Routine temporaries
        Total         :      14
            Global    :      12
            Local     :       2
        Regenerable   :       3
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: tr_static_init()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (tr_static_init()) trees.c(233,1)

===========================================================================

Begin optimization report for: inflateInit_()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateInit_()) [160/166=96.4%] inflate.c(243,1)
  -> (244,12) inflateInit2_() (isz = 58) (sz = 74)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

inflate.c(243,1):remark #34051: REGISTER ALLOCATION : [inflateInit_] inflate.c:243

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rdx rcx rsi rdi]
        
    Routine temporaries
        Total         :      16
            Global    :       0
            Local     :      16
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateInit2_()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateInit2_()) [161/166=97.0%] inflate.c(200,1)
  -> INDIRECT-: (224,13)  strm_643_V$47.6.57->zalloc_V$87
     [[ Unable to inline indirect callsite  <3>]]
  -> (231,11) inflateReset2() (isz = 74) (sz = 85)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (233,9)  strm_643_V$47.6.57->zfree_V$88
     [[ Unable to inline indirect callsite  <3>]]


    Report from: Code generation optimizations [cg]

inflate.c(200,1):remark #34051: REGISTER ALLOCATION : [inflateInit2_] inflate.c:200

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rcx rbx rbp rsi rdi r12]
        
    Routine temporaries
        Total         :      33
            Global    :      16
            Local     :      17
        Regenerable   :       5
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateBackInit_()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateBackInit_()) [162/166=97.6%] infback.c(34,1)
  -> INDIRECT-: (58,41)  strm_615_V$3.4.47->zalloc_V$87
     [[ Unable to inline indirect callsite  <3>]]


    Report from: Code generation optimizations [cg]

infback.c(34,1):remark #34051: REGISTER ALLOCATION : [inflateBackInit_] infback.c:34

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rbx rbp rsi rdi r8 r12]
        
    Routine temporaries
        Total         :      32
            Global    :      16
            Local     :      16
        Regenerable   :       6
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: lm_init()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (lm_init()) [163/166=98.2%] deflate.c(1196,1)
  -> INLINE (MANUAL): (1199,5) memset(void *, int, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
deflate.c(1196,1):remark #34051: REGISTER ALLOCATION : [lm_init] deflate.c:1196

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rbx rbp rsi rdi r8-r9]
        
    Routine temporaries
        Total         :      27
            Global    :       8
            Local     :      19
        Regenerable   :       4
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateInit2_()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateInit2_()) [164/166=98.8%] deflate.c(250,1)
  -> INDIRECT-: (304,27)  strm_642_V$72.3.23->zalloc_V$87
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (321,27)  strm_642_V$72.3.23->zalloc_V$87
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (322,27)  strm_642_V$72.3.23->zalloc_V$87
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (323,27)  strm_642_V$72.3.23->zalloc_V$87
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (329,24)  strm_642_V$72.3.23->zalloc_V$87
     [[ Unable to inline indirect callsite  <3>]]
  -> (337,9) deflateEnd() (isz = 63) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (347,12) deflateReset() (isz = 7) (sz = 14)
    -> (510,11) deflateResetKeep() (isz = 397) (sz = 405)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (512,9) lm_init() (isz = 55) (sz = 60)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

deflate.c(250,1):remark #34051: REGISTER ALLOCATION : [deflateInit2_] deflate.c:250

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   14[ rax rdx rcx rbx rbp rsi rdi r8-r10 r12-r15]
        
    Routine temporaries
        Total         :      99
            Global    :      32
            Local     :      67
        Regenerable   :      18
        Spilled       :       7
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       8 bytes*
            Reads     :       1 [5.40e-03 ~ 0.0%]
            Writes    :       1 [5.40e-03 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateInit_()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateInit_()) [165/166=99.4%] deflate.c(233,1)
  -> (234,12) deflateInit2_() (isz = 223) (sz = 249)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

deflate.c(233,1):remark #34051: REGISTER ALLOCATION : [deflateInit_] deflate.c:233

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rcx rsi rdi r8-r9]
        
    Routine temporaries
        Total         :      24
            Global    :       8
            Local     :      16
        Regenerable   :       4
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: _tr_init(deflate_state *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (_tr_init(deflate_state *)) [166/166=100.0%] trees.c(381,1)
  -> DELETED: (382,5) tr_static_init() (isz = 0) (sz = 2)
  -> (401,5) init_block() (isz = 39) (sz = 44)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

trees.c(381,1):remark #34051: REGISTER ALLOCATION : [_tr_init] trees.c:381

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rcx rsi rdi r8-r10]
        
    Routine temporaries
        Total         :      16
            Global    :       0
            Local     :      16
        Regenerable   :       4
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

    Report from: Profile guided optimizations [pgo]



Profile feedback used a statically estimated profile for the following routines:

  File: adler32.c
        adler32_z()                                                       [Line    67]
        adler32()                                                         [Line   138]
        adler32_combine_()                                                [Line   147]
        adler32_combine()                                                 [Line   176]
        adler32_combine64()                                               [Line   184]

  File: compress.c
        compress2()                                                       [Line    28]
        compress()                                                        [Line    73]
        compressBound()                                                   [Line    83]

  File: crc32.c
        get_crc_table()                                                   [Line   189]
        crc32_z()                                                         [Line   206]
        crc32()                                                           [Line   241]
        crc32_combine()                                                   [Line   432]
        crc32_combine64()                                                 [Line   440]

  File: deflate.c
        deflateInit_()                                                    [Line   233]
        deflateInit2_()                                                   [Line   250]
        deflateStateCheck()                                               [Line   355]
        deflateSetDictionary()                                            [Line   380]
        deflateGetDictionary()                                            [Line   449]
        deflateResetKeep()                                                [Line   469]
        deflateReset()                                                    [Line   507]
        deflateSetHeader()                                                [Line   520]
        deflatePending()                                                  [Line   532]
        deflatePrime()                                                    [Line   546]
        deflateParams()                                                   [Line   572]
        deflateTune()                                                     [Line   623]
        deflateBound()                                                    [Line   655]
        flush_pending()                                                   [Line   732]
        deflate()                                                         [Line   766]
        deflateEnd()                                                      [Line  1078]
        deflateCopy()                                                     [Line  1105]
        read_buf()                                                        [Line  1168]
        lm_init()                                                         [Line  1196]
        longest_match()                                                   [Line  1239]
        fill_window()                                                     [Line  1484]
        deflate_stored()                                                  [Line  1646]
        deflate_fast()                                                    [Line  1827]
        deflate_slow()                                                    [Line  1929]
        deflate_huff()                                                    [Line  2133]

  File: gzclose.c
        gzclose()                                                         [Line    13]

  File: gzlib.c
        gzopen()                                                          [Line   273]
        gzopen64()                                                        [Line   281]
        gzdopen()                                                         [Line   289]
        gzbuffer()                                                        [Line   319]
        gzrewind..0()                                                     [Line   345]
        gzrewind()                                                        [Line   345]
        gzseek64()                                                        [Line   370]
        gzseek()                                                          [Line   447]
        gztell64()                                                        [Line   457]
        gztell()                                                          [Line   474]
        gzoffset64()                                                      [Line   484]
        gzoffset()                                                        [Line   507]
        gzeof()                                                           [Line   517]
        gzerror()                                                         [Line   535]
        gzclearerr()                                                      [Line   555]
        gz_error()                                                        [Line   583]

  File: gzread.c
        gz_look()                                                         [Line    93]
        gz_fetch()                                                        [Line   231]
        gz_skip()                                                         [Line   262]
        gzread()                                                          [Line   379]
        gzfread()                                                         [Line   416]
        gzgetc()                                                          [Line   449]
        gzgetc..0()                                                       [Line   449]
        gzgetc_()                                                         [Line   478]
        gzungetc()                                                        [Line   486]
        gzgets()                                                          [Line   547]
        gzdirect()                                                        [Line   609]
        gzclose_r(gzFile)                                                 [Line   629]
        gzclose_r..0(gzFile)                                              [Line   629]

  File: gzwrite.c
        gz_init()                                                         [Line    19]
        gz_comp..0()                                                      [Line    76]
        gz_zero()                                                         [Line   148]
        gz_write..0()                                                     [Line   182]
        gzwrite()                                                         [Line   250]
        gzfwrite()                                                        [Line   279]
        gzputc()                                                          [Line   307]
        gzputs()                                                          [Line   355]
        gzvprintf(gzFile, const char *, struct __va_list_tag *)           [Line   380]
        gzprintf(gzFile, const char *, ...)                               [Line   452]
        gzflush()                                                         [Line   556]
        gzsetparams()                                                     [Line   589]
        gzclose_w..0(gzFile)                                              [Line   629]
        gzclose_w(gzFile)                                                 [Line   629]

  File: infback.c
        inflateBackInit_()                                                [Line    34]
        inflateBack()                                                     [Line   256]
        inflateBackEnd()                                                  [Line   633]

  File: inffast.c
        inflate_fast(z_streamp, unsigned int)                             [Line    53]

  File: inflate.c
        inflateResetKeep()                                                [Line   121]
        inflateReset()                                                    [Line   146]
        inflateReset2()                                                   [Line   160]
        inflateInit2_()                                                   [Line   200]
        inflateInit_()                                                    [Line   243]
        inflatePrime()                                                    [Line   251]
        updatewindow()                                                    [Line   400]
        inflate()                                                         [Line   625]
        inflateEnd()                                                      [Line  1279]
        inflateGetDictionary()                                            [Line  1295]
        inflateSetDictionary()                                            [Line  1318]
        inflateGetHeader()                                                [Line  1352]
        inflateSync()                                                     [Line  1402]
        inflateSyncPoint()                                                [Line  1453]
        inflateCopy()                                                     [Line  1464]
        inflateUndermine()                                                [Line  1511]
        inflateValidate()                                                 [Line  1529]
        inflateMark()                                                     [Line  1543]
        inflateCodesUsed()                                                [Line  1556]

  File: inftrees.c
        inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *)[Line    39]

  File: trees.c
        _tr_init(deflate_state *)                                         [Line   381]
        init_block()                                                      [Line   409]
        _tr_stored_block(deflate_state *, charf *, ulg, int)              [Line   868]
        _tr_flush_bits(deflate_state *)                                   [Line   888]
        _tr_align(deflate_state *)                                        [Line   898]
        _tr_flush_block(deflate_state *, charf *, ulg, int)               [Line   916]
        _tr_tally()                                                       [Line  1018]
        bi_flush()                                                        [Line  1175]
        bi_windup()                                                       [Line  1192]

  File: uncompr.c
        uncompress2()                                                     [Line    32]
        uncompress()                                                      [Line    91]

  File: zutil.c
        zlibVersion()                                                     [Line    28]
        zlibCompileFlags()                                                [Line    33]
        zError()                                                          [Line   135]
        zcalloc(voidpf, unsigned int, unsigned int)                       [Line   309]
        zcfree(voidpf, voidpf)                                            [Line   318]


  0 out of 122 routine(s) used training profile data for PGO feedback
  0 out of 122 routine(s) were unable to use training profile data for PGO feedback
  0 out of 122 routine(s) were unable to find training profile data for PGO feedback
  122 out of 122 routine(s) used a static estimate profile for PGO feedback




    Report from: Interprocedural optimizations [ipo]

INLINING FOOTNOTES:

<1> The compiler's heuristics indicate that the function is not profitable to 
    inline.  Override this decision by adding "inline 
    __attribute__((always_inline))" to the declaration of the called function, 
    or add "#pragma forceinline" before the call site.

<2> The compiler's heuristics predict that it is not profitable to inline the
    call.  Add "inline __attribute__((always_inline))" to the declaration of
    the called function or add "#pragma forceinline" before the call site.

<3> The indirectly called function must be resolved to its targets before it 
can be inlined.  Consider compiling with -ipo or -prof-gen followed by 
-prof-use.

