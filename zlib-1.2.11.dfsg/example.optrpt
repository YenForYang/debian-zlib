Intel(R) Advisor can now assist with vectorization and show optimization
  report messages with your source code.
See "https://software.intel.com/en-us/intel-advisor-xe" for details.

Intel(R) C Intel(R) 64 Compiler for applications running on Intel(R) 64, Version 19.0.1.144 Build 20181018

Compiler options: -O3 -diag-disable=10013,10385,10237,10346 -fabi-version=13 -falign-functions -falign-loops -fbuiltin -fdata-sections -ffunction-sections -ffat-lto-objects -fpermissive -gcc-name=gcc.intel -gnu-prefix=x86_64-linux-gnu- -gxx-name=g++.intel -inline-level=2 -inline-min-caller-growth=0 -ipo -march=native -no-inline-max-per-compile -no-inline-max-per-routine -no-inline-max-size -no-inline-max-total-size -par-schedule-auto -parallel -qopt-matmul -qopt-mem-layout-trans -qopt-multi-version-aggressive -qopt-prefetch -qoverride-limits -static-intel -qopt-report=5 -qno-opt-report-embed -g -Wformat -Wformat-security -D_FORTIFY_SOURCE=2 -Wall -D_REENTRANT -O3 -DUNALIGNED_OK -D_LARGEFILE64_SOURCE=1 -oexample -qopt-report-file=example.optrpt -L. -Wl,--as-needed,--relax,--gc-sections,-O,2 -pipe

    Report from: Interprocedural optimizations [ipo]

  WHOLE PROGRAM (SAFE) [EITHER METHOD]: false
  WHOLE PROGRAM (SEEN) [TABLE METHOD]: false
  WHOLE PROGRAM (READ) [OBJECT READER METHOD]: false

INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: disabled (user-specified)
  -inline-max-total-size: disabled (user-specified)
  -inline-max-per-routine: disabled (user-specified)
  -inline-max-per-compile: disabled (user-specified)

In the inlining report below:
   "sz" refers to the "size" of the routine. The smaller a routine's size,
      the more likely it is to be inlined.
   "isz" refers to the "inlined size" of the routine. This is the amount
      the calling routine will grow if the called routine is inlined into it.
      The compiler generally limits the amount a routine can grow by having
      routines inlined into it.

Begin optimization report for: main()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (main()) [1/189=0.5%] test/example.c(548,1)
  -> INLINE: (554,9) zlibVersion(void) (isz = 1) (sz = 5)
  -> INLINE: (555,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (556,9) exit(int)
  -> EXTERN: (558,16) strcmp(const char *, const char *)
  -> INLINE: (558,23) zlibVersion(void) (isz = 1) (sz = 5)
  -> INLINE: (559,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> INLINE: (562,5) printf(const char *__restrict__, ...) (isz = 5) (sz = 12)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,10) __printf_chk(int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,56) __builtin_va_arg_pack(void)
  -> DELETED: (563,40) zlibCompileFlags(void) (isz = 0) (sz = 4)
  -> EXTERN: (565,23) calloc(size_t, size_t)
  -> EXTERN: (566,23) calloc(size_t, size_t)
  -> INLINE: (571,9) printf(const char *__restrict__, ...) (isz = 5) (sz = 12)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,10) __printf_chk(int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,56) __builtin_va_arg_pack(void)
  -> EXTERN: (572,9) exit(int)
  -> (579,5) test_compress() (isz = 69) (sz = 80)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (581,5) test_gzio() (isz = 9808) (sz = 9817)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (585,5) test_deflate() (isz = 9202) (sz = 9209)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> (586,5) test_inflate() (isz = 5597) (sz = 5608)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> (588,5) test_large_deflate() (isz = 9239) (sz = 9250)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (589,5) test_large_inflate() (isz = 5589) (sz = 5600)
    -> INLINE (MANUAL): (341,5) strcpy(char *__restrict__, const char *__restrict__) (isz = 6) (sz = 15)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(90,10) __builtin___strcpy_chk(char *, const char *, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(90,49) __builtin_object_size(const void *, int)
    -> (350,11) inflateInit_(z_streamp, const char *, int) (isz = 2) (sz = 13)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (351,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
    -> EXTERN: (351,5) exit(int)
    -> INLINE: (356,15) inflate(z_streamp, int) (isz = 5502) (sz = 5516)
      -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
      -> INLINE: inflate.c:(667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> INLINE: inflate.c:(722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: inflate.c:(769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
      -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
      -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
      -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
      -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
      -> INLINE: inflate.c:(1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> inflate.c:(1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (358,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
    -> EXTERN: (358,9) exit(int)
    -> (361,11) inflateEnd(z_streamp) (isz = 48) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (362,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
    -> EXTERN: (362,5) exit(int)
    -> INLINE: (365,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
    -> EXTERN: (366,9) exit(int)
    -> INLINE: (368,9) printf(const char *__restrict__, ...) (isz = 5) (sz = 12)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,10) __printf_chk(int, const char *__restrict__, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,56) __builtin_va_arg_pack(void)
  -> (591,5) test_flush() (isz = 9204) (sz = 9211)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (592,5) test_sync() (isz = 5802) (sz = 5813)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (595,5) test_dict_deflate() (isz = 9974) (sz = 9981)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (596,5) test_dict_inflate() (isz = 6022) (sz = 6033)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> EXTERN: (598,5) free(void *)
  -> EXTERN: (599,5) free(void *)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inflate.c(1223,17) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into test/example.c(589,5)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into test/example.c(589,5)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into test/example.c(589,5)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into test/example.c(589,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 8  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into test/example.c(589,5)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into test/example.c(589,5)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into test/example.c(589,5)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into test/example.c(589,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into test/example.c(589,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into test/example.c(589,5)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into test/example.c(589,5)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into test/example.c(589,5)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into test/example.c(589,5)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into test/example.c(589,5)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into test/example.c(589,5)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into test/example.c(589,5)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into test/example.c(589,5)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into test/example.c(589,5)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into test/example.c(589,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into test/example.c(589,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into test/example.c(589,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into test/example.c(589,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into test/example.c(589,5)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into test/example.c(589,5)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference d_stream.state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into test/example.c(589,5)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into test/example.c(589,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(589,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(589,5)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(589,5)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into test/example.c(589,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into test/example.c(589,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into test/example.c(589,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into test/example.c(589,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into test/example.c(589,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(589,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(589,5)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(589,5)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into test/example.c(589,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into test/example.c(589,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into test/example.c(589,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into test/example.c(589,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into test/example.c(589,5)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between d_stream.state->lens[order[state->have]] (945:17) and d_stream.state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between d_stream.state->lens[order[state->have]] (945:17) and d_stream.state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <d_stream.state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into test/example.c(589,5)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into test/example.c(589,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(589,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into test/example.c(589,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into test/example.c(589,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into test/example.c(589,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into test/example.c(589,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into test/example.c(589,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into test/example.c(589,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into test/example.c(589,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at test/example.c(358,9) inlined into test/example.c(589,5)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at inflate.c(1226,21) inlined into test/example.c(589,5)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1107,17) inlined into test/example.c(589,5)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inffast.c(290,19) inlined into test/example.c(589,5)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inffast.c(277,20) inlined into test/example.c(589,5)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END

      LOOP BEGIN at inflate.c(1057,17) inlined into test/example.c(589,5)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inflate.c(960,13) inlined into test/example.c(589,5)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into test/example.c(589,5)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into test/example.c(589,5)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inflate.c(939,13) inlined into test/example.c(589,5)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into test/example.c(589,5)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(90,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
test/example.c(548,1):remark #34051: REGISTER ALLOCATION : [main] test/example.c:548

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1762
            Global    :     391
            Local     :    1371
        Regenerable   :     130
        Spilled       :     103
        
    Routine stack
        Variables     :     340 bytes*
            Reads     :     154 [2.51e+01 ~ 3.6%]
            Writes    :     220 [2.85e+01 ~ 4.1%]
        Spills        :     728 bytes*
            Reads     :     513 [1.48e+01 ~ 2.1%]
            Writes    :     168 [1.87e+01 ~ 2.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: zlibCompileFlags(void)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (zlibCompileFlags(void)) [2/189=1.1%] zutil.c(33,1)


    Report from: Code generation optimizations [cg]

zutil.c(33,1):remark #34051: REGISTER ALLOCATION : [zlibCompileFlags] zutil.c:33

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rax]
        
    Routine temporaries
        Total         :       7
            Global    :       0
            Local     :       7
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: test_compress()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (test_compress()) [3/189=1.6%] test/example.c(91,1)
  -> EXTERN: (93,24) strlen(const char *)
  -> (95,11) compress(Bytef *, uLongf *, const Bytef *, uLong) (isz = 9165) (sz = 9178)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (96,5) exit(int)
  -> INLINE: (96,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> INLINE (MANUAL): (98,5) strcpy(char *__restrict__, const char *__restrict__) (isz = 6) (sz = 15)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(90,10) __builtin___strcpy_chk(char *, const char *, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(90,49) __builtin_object_size(const void *, int)
  -> (100,11) uncompress(Bytef *, uLongf *, const Bytef *, uLong) (isz = 5600) (sz = 5613)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (101,5) exit(int)
  -> INLINE: (101,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (103,9) strcmp(const char *, const char *)
  -> INLINE: (104,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (105,9) exit(int)
  -> INLINE: (107,9) printf(const char *__restrict__, ...) (isz = 5) (sz = 12)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,10) __printf_chk(int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,56) __builtin_va_arg_pack(void)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(90,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
test/example.c(91,1):remark #34051: REGISTER ALLOCATION : [test_compress] test/example.c:91

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rcx rbx rbp rsi rdi r8]
        
    Routine temporaries
        Total         :      71
            Global    :      15
            Local     :      56
        Regenerable   :      31
        Spilled       :       2
        
    Routine stack
        Variables     :      16 bytes*
            Reads     :       1 [9.50e-01 ~ 1.9%]
            Writes    :       2 [2.00e+00 ~ 3.9%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: compress(Bytef *, uLongf *, const Bytef *, uLong)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (compress(Bytef *, uLongf *, const Bytef *, uLong)) [4/189=2.1%] compress.c(73,1)
  -> INLINE: (74,12) compress2() (isz = 9163) (sz = 9179)
    -> (41,11) deflateInit_(z_streamp, int, const char *, int) (isz = 5) (sz = 18)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (58,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
      -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
        -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1786,9) read_buf() (isz = 46) (sz = 58)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1810,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
        -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
          -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
          -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
          -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
          -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
            -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
          -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
            -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
          -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
             [[ Callee not marked with inlining pragma  <1>]]
          -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2118,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.1880->level_V$3f))]
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
      -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (62,5) deflateEnd(z_streamp) (isz = 63) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(904,13) inlined into compress.c(74,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into compress.c(74,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into compress.c(74,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into compress.c(74,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into compress.c(74,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into compress.c(74,12)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into compress.c(74,12)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into compress.c(74,12)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into compress.c(74,12)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into compress.c(74,12)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into compress.c(74,12)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into compress.c(74,12)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into compress.c(74,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(74,12)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(74,12)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into compress.c(74,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into compress.c(74,12)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into compress.c(74,12)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(74,12)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(74,12)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into compress.c(74,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into compress.c(74,12)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into compress.c(74,12)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(74,12)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(74,12)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(74,12)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into compress.c(74,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into compress.c(74,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into compress.c(74,12)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into compress.c(74,12)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into compress.c(74,12)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into compress.c(74,12)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into compress.c(74,12)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into compress.c(74,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into compress.c(74,12)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into compress.c(74,12)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into compress.c(74,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into compress.c(74,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at compress.c(59,21) inlined into compress.c(74,12)
   remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into compress.c(74,12)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into compress.c(74,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
compress.c(73,1):remark #34051: REGISTER ALLOCATION : [compress] compress.c:73

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    3038
            Global    :     746
            Local     :    2292
        Regenerable   :      72
        Spilled       :      74
        
    Routine stack
        Variables     :     208 bytes*
            Reads     :      54 [2.54e+01 ~ 1.4%]
            Writes    :      80 [3.79e+01 ~ 2.1%]
        Spills        :     544 bytes*
            Reads     :     286 [3.63e+01 ~ 2.0%]
            Writes    :     187 [3.56e+01 ~ 2.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateEnd(z_streamp)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateEnd(z_streamp)) [5/189=2.6%] deflate.c(1078,1)
  -> (1081,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (1086,5)  strm_943_V$100.4.65->zfree_V$4d
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1087,5)  strm_943_V$100.4.65->zfree_V$4d
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1088,5)  strm_943_V$100.4.65->zfree_V$4d
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1089,5)  strm_943_V$100.4.65->zfree_V$4d
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1091,5)  strm_943_V$100.4.65->zfree_V$4d
     [[ Unable to inline indirect callsite  <3>]]


    Report from: Code generation optimizations [cg]

deflate.c(1078,1):remark #34051: REGISTER ALLOCATION : [deflateEnd] deflate.c:1078

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rbp rsi rdi r12]
        
    Routine temporaries
        Total         :      37
            Global    :      14
            Local     :      23
        Regenerable   :       3
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: uncompress(Bytef *, uLongf *, const Bytef *, uLong)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (uncompress(Bytef *, uLongf *, const Bytef *, uLong)) [6/189=3.2%] uncompr.c(91,1)
  -> INLINE: (92,12) uncompress2() (isz = 5598) (sz = 5612)
    -> (55,11) inflateInit_(z_streamp, const char *, int) (isz = 2) (sz = 13)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (70,15) inflate(z_streamp, int) (isz = 5502) (sz = 5516)
      -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
      -> INLINE: inflate.c:(667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> INLINE: inflate.c:(722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: inflate.c:(769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
      -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
      -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
      -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
      -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
      -> INLINE: inflate.c:(1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> inflate.c:(1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (79,5) inflateEnd(z_streamp) (isz = 48) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inflate.c(1223,17) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into uncompr.c(92,12)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into uncompr.c(92,12)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into uncompr.c(92,12)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 8  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into uncompr.c(92,12)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into uncompr.c(92,12)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into uncompr.c(92,12)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into uncompr.c(92,12)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into uncompr.c(92,12)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into uncompr.c(92,12)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into uncompr.c(92,12)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into uncompr.c(92,12)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into uncompr.c(92,12)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into uncompr.c(92,12)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into uncompr.c(92,12)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into uncompr.c(92,12)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into uncompr.c(92,12)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into uncompr.c(92,12)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference stream.state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into uncompr.c(92,12)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into uncompr.c(92,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(92,12)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(92,12)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(92,12)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into uncompr.c(92,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(92,12)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(92,12)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(92,12)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into uncompr.c(92,12)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between stream.state->lens[order[state->have]] (945:17) and stream.state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between stream.state->lens[order[state->have]] (945:17) and stream.state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <stream.state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into uncompr.c(92,12)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into uncompr.c(92,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(92,12)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into uncompr.c(92,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into uncompr.c(92,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into uncompr.c(92,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at uncompr.c(71,21) inlined into uncompr.c(92,12)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at inflate.c(1226,21) inlined into uncompr.c(92,12)
      remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1107,17) inlined into uncompr.c(92,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inffast.c(290,19) inlined into uncompr.c(92,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inffast.c(277,20) inlined into uncompr.c(92,12)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END

      LOOP BEGIN at inflate.c(1057,17) inlined into uncompr.c(92,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inflate.c(960,13) inlined into uncompr.c(92,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into uncompr.c(92,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into uncompr.c(92,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inflate.c(939,13) inlined into uncompr.c(92,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into uncompr.c(92,12)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
uncompr.c(91,1):remark #34051: REGISTER ALLOCATION : [uncompress] uncompr.c:91

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1661
            Global    :     385
            Local     :    1276
        Regenerable   :      71
        Spilled       :     112
        
    Routine stack
        Variables     :     329 bytes*
            Reads     :     151 [4.89e+01 ~ 3.3%]
            Writes    :     218 [5.88e+01 ~ 4.0%]
        Spills        :     752 bytes*
            Reads     :     517 [3.87e+01 ~ 2.6%]
            Writes    :     217 [4.26e+01 ~ 2.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateEnd(z_streamp)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateEnd(z_streamp)) [7/189=3.7%] inflate.c(1279,1)
  -> INLINE: (1281,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> INDIRECT-: (1284,34)  strm_1171_V$ad.3.31->zfree_V$4d
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1285,5)  strm_1171_V$ad.3.31->zfree_V$4d
     [[ Unable to inline indirect callsite  <3>]]


    Report from: Code generation optimizations [cg]

inflate.c(1279,1):remark #34051: REGISTER ALLOCATION : [inflateEnd] inflate.c:1279

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rsi rdi r15]
        
    Routine temporaries
        Total         :      20
            Global    :      11
            Local     :       9
        Regenerable   :       2
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: test_gzio()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (test_gzio()) [8/189=4.2%] test/example.c(118,1)
  -> EXTERN: (123,20) strlen(const char *)
  -> (127,12) gzopen(const char *, const char *) (isz = 259) (sz = 268)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (129,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (130,9) exit(int)
  -> INLINE: (132,5) gzputc(gzFile, int) (isz = 9401) (sz = 9415)
    -> INLINE: gzwrite.c:(326,13) gz_zero() (isz = 9326) (sz = 9337)
      -> INLINE: (154,27) gz_comp() (isz = 9270) (sz = 9284)
        -> (82,29) gz_init() (isz = 92) (sz = 102)
           [[ Callee not marked with inlining pragma  <1>]]
        -> EXTERN: (89,20) write(int, const void *, size_t)
        -> CP_CLONE (91,17) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> EXTERN: (91,42) __errno_location(void)
        -> EXTERN: (91,42) strerror(int)
        -> EXTERN: (110,24) write(int, const void *, size_t)
        -> CP_CLONE (112,21) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> EXTERN: (112,46) __errno_location(void)
        -> EXTERN: (112,46) strerror(int)
        -> INLINE: (126,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
          -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
             [[ Callee not marked with inlining pragma  <1>]]
          -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
          -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
          -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
          -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
            -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
          -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
            -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
              -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
                 [[ Callee not marked with inlining pragma  <1>]]
              -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
              -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
                -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                   [[ Callee not marked with inlining pragma  <1>]]
              -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
              -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
              -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
                 [[ Callee not marked with inlining pragma  <1>]]
              -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
                -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                   [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1786,9) read_buf() (isz = 46) (sz = 58)
               [[ Callee not marked with inlining pragma  <1>]]
            -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
               [[ Callee not marked with inlining pragma  <1>]]
            -> (1810,9) flush_pending() (isz = 45) (sz = 51)
               [[ Callee not marked with inlining pragma  <1>]]
          -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
            -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
              -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
              -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
              -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
                -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
                  -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
                  -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
                -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
                   [[ Callee not marked with inlining pragma  <1>]]
                -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
                  -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                     [[ Callee not marked with inlining pragma  <1>]]
              -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
              -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
            -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
              -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
              -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
                -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
                -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                  -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
              -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
                -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
                -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                  -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
              -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
                -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
                -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
                -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
                  -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
                  -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
                  -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
                  -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
                  -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                    -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
              -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
                 [[ Callee not marked with inlining pragma  <1>]]
              -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
              -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
                -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
                -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
              -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
              -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
                 [[ Callee not marked with inlining pragma  <1>]]
              -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
              -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
                -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                   [[ Callee not marked with inlining pragma  <1>]]
              -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
               [[ Inlining inhibited by overrideable criterion  <2>]]
            -> (2118,9) flush_pending() (isz = 45) (sz = 51)
               [[ Callee not marked with inlining pragma  <1>]]
            -> (2122,9) flush_pending() (isz = 45) (sz = 51)
               [[ Callee not marked with inlining pragma  <1>]]
            -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
               [[ Inlining inhibited by overrideable criterion  <2>]]
          -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.2888->level_V$3f))]
             [[ Callee not marked with inlining pragma  <1>]]
          -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
            -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
          -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
          -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (128,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
          -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
             [[ Callee not marked with inlining pragma  <1>]]
          -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (163,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> CP_CLONE (169,13) gz_comp..0() (isz = 9270) (sz = 9284)
         [[ Inlining inhibited by overrideable criterion  <2>]]
    -> CP_CLONE gzwrite.c:(346,9) gz_write..0() (isz = 9388) (sz = 9405)
       [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE (PARTIAL): (133,9) gzputs(gzFile, const char *) (isz = 12) (sz = 12)
    -> PI_CLONE gzwrite.c:(361,5) gzputs..0(gzFile, const char *) (isz = 0) (sz = 0)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (134,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> (134,45) gzerror(gzFile, int *) (isz = 27) (sz = 38)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (135,9) exit(int)
  -> (137,9) gzprintf(gzFile, const char *, ...) (isz = 13) (sz = 22)
     [[ Unable to inline callsite  <4>]]
  -> INLINE: (138,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> (138,47) gzerror(gzFile, int *) (isz = 27) (sz = 38)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (139,9) exit(int)
  -> INLINE: (141,5) gzseek(gzFile, off_t, int) (isz = 2) (sz = 13)
    -> gzlib.c:(450,11) gzseek64() (isz = 141) (sz = 161)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (142,5) gzclose(gzFile) (isz = 35) (sz = 43)
    -> INLINE (PARTIAL): gzclose.c:(21,37) gzclose_r() (isz = 10) (sz = 10)
      -> PI_CLONE gzread.c:(634,5) gzclose_r..0() (isz = 0) (sz = 0)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (PARTIAL): gzclose.c:(21,55) gzclose_w(gzFile) (isz = 12) (sz = 12)
      -> PI_CLONE gzwrite.c:(634,5) gzclose_w..0(gzFile) (isz = 0) (sz = 0)
         [[ Callee not marked with inlining pragma  <1>]]
  -> (144,12) gzopen(const char *, const char *) (isz = 259) (sz = 268)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (146,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (147,9) exit(int)
  -> INLINE (MANUAL): (149,5) strcpy(char *__restrict__, const char *__restrict__) (isz = 6) (sz = 15)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(90,10) __builtin___strcpy_chk(char *, const char *, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(90,49) __builtin_object_size(const void *, int)
  -> (151,9) gzread(gzFile, voidp, unsigned int) (isz = 5883) (sz = 5898)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (152,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> (152,45) gzerror(gzFile, int *) (isz = 27) (sz = 38)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (153,9) exit(int)
  -> EXTERN: (155,9) strcmp(const char *, const char *)
  -> INLINE: (156,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (157,9) exit(int)
  -> INLINE: (159,9) printf(const char *__restrict__, ...) (isz = 5) (sz = 12)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,10) __printf_chk(int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,56) __builtin_va_arg_pack(void)
  -> INLINE: (162,11) gzseek(gzFile, off_t, int) (isz = 2) (sz = 13)
    -> gzlib.c:(450,11) gzseek64() (isz = 141) (sz = 161)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (163,21) gztell(gzFile) (isz = 21) (sz = 28)
    -> INLINE: gzlib.c:(477,11) gztell64() (isz = 19) (sz = 28)
  -> INLINE: (164,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> INLINE: (165,34) gztell(gzFile) (isz = 21) (sz = 28)
    -> INLINE: gzlib.c:(477,11) gztell64() (isz = 19) (sz = 28)
  -> EXTERN: (166,9) exit(int)
  -> INLINE (PARTIAL): (169,9) gzgetc(gzFile) (isz = 10) (sz = 10)
    -> PI_CLONE gzread.c:(455,5) gzgetc..0(gzFile) (isz = 0) (sz = 0)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (170,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (171,9) exit(int)
  -> INLINE (PARTIAL): (174,9) gzungetc(int, gzFile) (isz = 12) (sz = 12)
    -> PI_CLONE gzread.c:(490,5) gzungetc..0(int, gzFile) (isz = 0) (sz = 0)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (175,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (176,9) exit(int)
  -> (179,5) gzgets(gzFile, char *, int) (isz = 6153) (sz = 6169)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> EXTERN: (180,9) strlen(const char *)
  -> INLINE: (181,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> (181,58) gzerror(gzFile, int *) (isz = 27) (sz = 38)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (182,9) exit(int)
  -> EXTERN: (184,9) strcmp(const char *, const char *)
  -> INLINE: (185,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (186,9) exit(int)
  -> INLINE: (188,9) printf(const char *__restrict__, ...) (isz = 5) (sz = 12)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,10) __printf_chk(int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,56) __builtin_va_arg_pack(void)
  -> INLINE: (191,5) gzclose(gzFile) (isz = 35) (sz = 43)
    -> INLINE (PARTIAL): gzclose.c:(21,37) gzclose_r() (isz = 10) (sz = 10)
      -> PI_CLONE gzread.c:(634,5) gzclose_r..0() (isz = 0) (sz = 0)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (PARTIAL): gzclose.c:(21,55) gzclose_w(gzFile) (isz = 12) (sz = 12)
      -> PI_CLONE gzwrite.c:(634,5) gzclose_w..0(gzFile) (isz = 0) (sz = 0)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(87,9) inlined into test/example.c(132,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into test/example.c(132,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into test/example.c(132,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into test/example.c(132,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into test/example.c(132,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into test/example.c(132,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into test/example.c(132,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(132,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(132,5)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(132,5)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(132,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(132,5)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(132,5)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into test/example.c(132,5)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into test/example.c(132,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(132,5)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(132,5)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(132,5)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(132,5)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(132,5)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(132,5)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(132,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(132,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(132,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into test/example.c(132,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into test/example.c(132,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into test/example.c(132,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into test/example.c(132,5)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into test/example.c(132,5)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(132,5)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(132,5)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(132,5)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(132,5)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(132,5)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(132,5)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(132,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(132,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(132,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into test/example.c(132,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into test/example.c(132,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into test/example.c(132,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into test/example.c(132,5)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into test/example.c(132,5)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(132,5)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(132,5)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(132,5)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(132,5)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(132,5)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(132,5)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(132,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(132,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(132,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into test/example.c(132,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into test/example.c(132,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into test/example.c(132,5)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into test/example.c(132,5)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into test/example.c(132,5)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into test/example.c(132,5)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(132,5)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(132,5)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into test/example.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(132,5)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(132,5)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into test/example.c(132,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into test/example.c(132,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at gzwrite.c(159,5) inlined into test/example.c(132,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into test/example.c(132,5)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into test/example.c(132,5)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into test/example.c(132,5)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(90,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
test/example.c(118,1):remark #34051: REGISTER ALLOCATION : [test_gzio] test/example.c:118

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    3217
            Global    :     793
            Local     :    2424
        Regenerable   :     165
        Spilled       :      79
        
    Routine stack
        Variables     :     101 bytes*
            Reads     :       3 [2.41e-03 ~ 0.0%]
            Writes    :      49 [1.56e-01 ~ 0.2%]
        Spills        :     584 bytes*
            Reads     :     312 [3.34e-01 ~ 0.3%]
            Writes    :     209 [3.56e-01 ~ 0.4%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_write..0()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_write..0()) [9/189=4.8%] gzwrite.c(182,1)
  CLONED FROM: gz_write()(X,X,0x00000001,0x00000000)
  -> (190,29) gz_init() (isz = 92) (sz = 102)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (196,13) gz_zero() (isz = 9326) (sz = 9337)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE (MANUAL): (213,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> CP_CLONE (218,24) gz_comp..0() (isz = 9270) (sz = 9284)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (224,37) gz_comp() (isz = 9270) (sz = 9284)
    -> (82,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (89,20) write(int, const void *, size_t)
    -> CP_CLONE (91,17) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (91,42) strerror(int)
    -> EXTERN: (91,42) __errno_location(void)
    -> EXTERN: (110,24) write(int, const void *, size_t)
    -> CP_CLONE (112,21) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (112,46) strerror(int)
    -> EXTERN: (112,46) __errno_location(void)
    -> INLINE: (126,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
      -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
        -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1786,9) read_buf() (isz = 46) (sz = 58)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1810,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
        -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
          -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
          -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
          -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
          -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
            -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
          -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
            -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
          -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
             [[ Callee not marked with inlining pragma  <1>]]
          -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
        -> (2118,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2122,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.3477->level_V$3f))]
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
      -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (128,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
      -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
         [[ Callee not marked with inlining pragma  <1>]]
  -> CP_CLONE (235,17) gz_comp..0() (isz = 9270) (sz = 9284)
     [[ Inlining inhibited by overrideable criterion  <2>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(201,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(224,37)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(224,37)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(224,37)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(224,37)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(224,37)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(224,37)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(224,37)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(224,37)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(224,37)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(224,37)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(224,37)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(224,37)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(224,37)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(224,37)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(224,37)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(224,37)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(224,37)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(224,37)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(224,37)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(224,37)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(224,37)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(224,37)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(224,37)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(224,37)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(224,37)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(224,37)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(224,37)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(224,37)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(224,37)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(224,37)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(224,37)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(224,37)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(224,37)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(224,37)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(182,1):remark #34051: REGISTER ALLOCATION : [gz_write..0] gzwrite.c:182

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2901
            Global    :     719
            Local     :    2182
        Regenerable   :      76
        Spilled       :      79
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [3.47e-03 ~ 0.0%]
            Writes    :      48 [5.08e-02 ~ 0.0%]
        Spills        :     576 bytes*
            Reads     :     230 [4.52e-01 ~ 0.3%]
            Writes    :     167 [5.26e-01 ~ 0.4%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_comp..0()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_comp..0()) [10/189=5.3%] gzwrite.c(76,1)
  CLONED FROM: gz_comp()(X,0)
  -> (82,29) gz_init() (isz = 92) (sz = 102)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (89,20) write(int, const void *, size_t)
  -> CP_CLONE (91,17) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (91,42) __errno_location(void)
  -> EXTERN: (91,42) strerror(int)
  -> EXTERN: (110,24) write(int, const void *, size_t)
  -> CP_CLONE (112,21) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (112,46) __errno_location(void)
  -> EXTERN: (112,46) strerror(int)
  -> INLINE: (126,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
    -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
      -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
        -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1786,9) read_buf() (isz = 46) (sz = 58)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1810,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
      -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
        -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
        -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
        -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
        -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
          -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
        -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
          -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
        -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
        -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
           [[ Callee not marked with inlining pragma  <1>]]
        -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> (2118,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (2122,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.3386->level_V$3f))]
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
      -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
    -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
  -> CP_CLONE (128,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
    -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(87,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(126,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(126,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(126,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(126,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(126,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(126,15)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(126,15)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(126,15)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(126,15)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(126,15)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(126,15)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(126,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(126,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(126,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(126,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(126,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(126,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(126,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(126,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(126,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(126,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(126,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(126,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(126,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(126,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(126,15)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(126,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(126,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(126,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(126,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(126,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(126,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(126,15)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(126,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(126,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(126,15)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(126,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(126,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(126,15)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(126,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(76,1):remark #34051: REGISTER ALLOCATION : [gz_comp..0] gzwrite.c:76

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2864
            Global    :     704
            Local     :    2160
        Regenerable   :      74
        Spilled       :      70
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [2.23e-01 ~ 0.0%]
            Writes    :      48 [3.27e+00 ~ 0.4%]
        Spills        :     512 bytes*
            Reads     :     170 [1.79e+01 ~ 2.2%]
            Writes    :     131 [2.20e+01 ~ 2.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: bi_flush()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (bi_flush()) [11/189=5.8%] trees.c(1175,1)


    Report from: Code generation optimizations [cg]

trees.c(1175,1):remark #34051: REGISTER ALLOCATION : [bi_flush] trees.c:1175

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rcx rsi rdi r8-r9]
        
    Routine temporaries
        Total         :      21
            Global    :       8
            Local     :      13
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: adler32(uLong, const Bytef *, uInt)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (adler32(uLong, const Bytef *, uInt)) [12/189=6.3%] adler32.c(138,1)
  -> INLINE: (139,12) adler32_z() (isz = 340) (sz = 354)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at adler32.c(103,5) inlined into adler32.c(139,12)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into adler32.c(139,12)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into adler32.c(139,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into adler32.c(139,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into adler32.c(139,12)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into adler32.c(139,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

    Report from: Code generation optimizations [cg]

adler32.c(138,1):remark #34051: REGISTER ALLOCATION : [adler32] adler32.c:138

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   11[ rax rdx rcx rbx rbp rsi rdi r8-r11]
        
    Routine temporaries
        Total         :     194
            Global    :      30
            Local     :     164
        Regenerable   :       4
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      16 bytes*
            Reads     :       2 [1.62e-01 ~ 0.0%]
            Writes    :       2 [1.62e-01 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: flush_pending()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (flush_pending()) [13/189=6.9%] deflate.c(732,1)
  -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
    -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(732,1):remark #34051: REGISTER ALLOCATION : [flush_pending] deflate.c:732

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rbx rbp rsi rdi r14-r15]
        
    Routine temporaries
        Total         :      22
            Global    :      11
            Local     :      11
        Regenerable   :       0
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateStateCheck()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateStateCheck()) [14/189=7.4%] deflate.c(355,1)


    Report from: Code generation optimizations [cg]

deflate.c(355,1):remark #34051: REGISTER ALLOCATION : [deflateStateCheck] deflate.c:355

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :      13
            Global    :       9
            Local     :       4
        Regenerable   :       3
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: _tr_flush_block..1(deflate_state *, charf *, ulg, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (_tr_flush_block..1(deflate_state *, charf *, ulg, int)) [15/189=7.9%] trees.c(916,1)
  CLONED FROM: _tr_flush_block(deflate_state *, charf *, ulg, int)(X,X,X,1)
  -> INLINE: (925,34) detect_data_type() (isz = 48) (sz = 58)
  -> INLINE: (928,9) build_tree() (isz = 834) (sz = 841)
    -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
    -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
      -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
  -> INLINE: (932,9) build_tree() (isz = 834) (sz = 841)
    -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
    -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
      -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
  -> INLINE: (942,23) build_bl_tree() (isz = 1068) (sz = 1075)
    -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
    -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
    -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
  -> (971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (979,9) compress_block() (isz = 546) (sz = 555)
  -> INLINE: (986,9) send_all_trees() (isz = 1701) (sz = 1712)
    -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
    -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
  -> INLINE: (988,9) compress_block() (isz = 546) (sz = 555)
  -> (998,5) init_block() (isz = 39) (sz = 44)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (1001,9) bi_windup() (isz = 51) (sz = 56)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at trees.c(1135,5) inlined into trees.c(925,34)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(928,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(928,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(928,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(928,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(928,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(928,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into trees.c(928,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into trees.c(928,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into trees.c(928,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(932,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(932,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(932,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(932,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(932,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(932,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into trees.c(932,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into trees.c(932,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into trees.c(932,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(942,23)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(942,23)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(942,23)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(942,23)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(942,23)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(942,23)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into trees.c(942,23)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into trees.c(942,23)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into trees.c(942,23)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into trees.c(986,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into trees.c(986,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into trees.c(986,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into trees.c(986,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into trees.c(986,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into trees.c(986,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into trees.c(986,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into trees.c(986,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into trees.c(988,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into trees.c(979,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at trees.c(1143,5) inlined into trees.c(925,34)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

trees.c(916,1):remark #34051: REGISTER ALLOCATION : [_tr_flush_block..1] trees.c:916

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    2023
            Global    :     511
            Local     :    1512
        Regenerable   :      31
        Spilled       :      59
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [2.77e+00 ~ 0.0%]
            Writes    :      48 [4.06e+01 ~ 0.6%]
        Spills        :     416 bytes*
            Reads     :     133 [2.10e+02 ~ 3.1%]
            Writes    :     107 [2.64e+02 ~ 3.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: _tr_flush_block..0(deflate_state *, charf *, ulg, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (_tr_flush_block..0(deflate_state *, charf *, ulg, int)) [16/189=8.5%] trees.c(916,1)
  CLONED FROM: _tr_flush_block(deflate_state *, charf *, ulg, int)(X,X,X,0)
  -> INLINE: (925,34) detect_data_type() (isz = 48) (sz = 58)
  -> INLINE: (928,9) build_tree() (isz = 834) (sz = 841)
    -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
    -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
      -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
  -> INLINE: (932,9) build_tree() (isz = 834) (sz = 841)
    -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
    -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
      -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
  -> INLINE: (942,23) build_bl_tree() (isz = 1068) (sz = 1075)
    -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
    -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
    -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
  -> (971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (979,9) compress_block() (isz = 546) (sz = 555)
  -> INLINE: (986,9) send_all_trees() (isz = 1701) (sz = 1712)
    -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
    -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
  -> INLINE: (988,9) compress_block() (isz = 546) (sz = 555)
  -> (998,5) init_block() (isz = 39) (sz = 44)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (1001,9) bi_windup() (isz = 51) (sz = 56)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at trees.c(1135,5) inlined into trees.c(925,34)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(928,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(928,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(928,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(928,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(928,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(928,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into trees.c(928,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into trees.c(928,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into trees.c(928,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(932,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(932,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(932,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(932,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(932,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(932,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into trees.c(932,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into trees.c(932,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into trees.c(932,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(942,23)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(942,23)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(942,23)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(942,23)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(942,23)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(942,23)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into trees.c(942,23)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into trees.c(942,23)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into trees.c(942,23)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into trees.c(986,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into trees.c(986,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into trees.c(986,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into trees.c(986,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into trees.c(986,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into trees.c(986,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into trees.c(986,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into trees.c(986,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into trees.c(988,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into trees.c(979,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at trees.c(1143,5) inlined into trees.c(925,34)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

trees.c(916,1):remark #34051: REGISTER ALLOCATION : [_tr_flush_block..0] trees.c:916

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    2022
            Global    :     511
            Local     :    1511
        Regenerable   :      31
        Spilled       :      60
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [2.77e+00 ~ 0.0%]
            Writes    :      48 [4.06e+01 ~ 0.6%]
        Spills        :     416 bytes*
            Reads     :     133 [2.10e+02 ~ 3.1%]
            Writes    :     107 [2.64e+02 ~ 3.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflate_huff()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflate_huff()) [17/189=9.0%] deflate.c(2133,1)
  -> (2139,13) fill_window() (isz = 308) (sz = 313)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (2153,21) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (2153,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
    -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
    -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
      -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
    -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
      -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
      -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
    -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
    -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
       [[ Callee not marked with inlining pragma  <1>]]
    -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (2157,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> CP_CLONE (2157,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (2161,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
    -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
    -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
      -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
    -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
      -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
      -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
    -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
    -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
       [[ Callee not marked with inlining pragma  <1>]]
    -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (2161,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at trees.c(1135,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2153,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2153,21)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2153,21)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2153,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2153,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2153,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2153,21)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2153,21)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2153,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2153,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2153,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2153,21)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2153,21)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2153,21)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2153,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2153,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2153,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(2153,21)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2153,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2153,21)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(2153,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2153,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2153,21)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(2153,21)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(2153,21)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2161,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2161,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2161,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2161,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2161,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2161,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2161,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->static_len (650:34) and s->static_len (650:34)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->static_len (650:34) and s->static_len (650:34)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2161,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2161,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(523,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2161,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2161,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2161,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2161,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2161,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2161,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2161,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2161,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2161,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(2161,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2161,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2161,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(2161,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2161,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2161,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(2161,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(2161,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at deflate.c(2153,9)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at trees.c(1143,5) inlined into deflate.c(2153,21)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1143,5) inlined into deflate.c(2161,9)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(2133,1):remark #34051: REGISTER ALLOCATION : [deflate_huff] deflate.c:2133

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    4108
            Global    :    1028
            Local     :    3080
        Regenerable   :      68
        Spilled       :     120
        
    Routine stack
        Variables     :     192 bytes*
            Reads     :       6 [9.87e+00 ~ 0.0%]
            Writes    :      96 [1.44e+02 ~ 0.6%]
        Spills        :     888 bytes*
            Reads     :     277 [7.53e+02 ~ 3.1%]
            Writes    :     226 [9.46e+02 ~ 3.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: fill_window()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (fill_window()) [18/189=9.5%] deflate.c(1484,1)
  -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
  -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
    -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(1492,48)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1516,13)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1516,13)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1516,13)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1516,13)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1516,13)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1516,13)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
deflate.c(1484,1):remark #34051: REGISTER ALLOCATION : [fill_window] deflate.c:1484

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :     212
            Global    :      61
            Local     :     151
        Regenerable   :       5
        Spilled       :      13
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      80 bytes*
            Reads     :      21 [1.46e+01 ~ 3.3%]
            Writes    :      10 [8.79e+00 ~ 2.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: _tr_stored_block(deflate_state *, charf *, ulg, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (_tr_stored_block(deflate_state *, charf *, ulg, int)) [19/189=10.1%] trees.c(868,1)
  -> (870,5) bi_windup() (isz = 51) (sz = 56)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
trees.c(868,1):remark #34051: REGISTER ALLOCATION : [_tr_stored_block] trees.c:868

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   12[ rax rdx rcx rsi rdi r8-r11 r13-r15]
        
    Routine temporaries
        Total         :      49
            Global    :      13
            Local     :      36
        Regenerable   :       0
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: read_buf()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (read_buf()) [20/189=10.6%] deflate.c(1168,1)
  -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(1168,1):remark #34051: REGISTER ALLOCATION : [read_buf] deflate.c:1168

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rbp rsi rdi r12-r14]
        
    Routine temporaries
        Total         :      36
            Global    :      14
            Local     :      22
        Regenerable   :       1
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: _tr_align(deflate_state *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (_tr_align(deflate_state *)) [21/189=11.1%] trees.c(898,1)
  -> (904,5) bi_flush() (isz = 61) (sz = 66)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

trees.c(898,1):remark #34051: REGISTER ALLOCATION : [_tr_align] trees.c:898

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rsi rdi r8]
        
    Routine temporaries
        Total         :      35
            Global    :      12
            Local     :      23
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: bi_windup()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (bi_windup()) [22/189=11.6%] trees.c(1192,1)


    Report from: Code generation optimizations [cg]

trees.c(1192,1):remark #34051: REGISTER ALLOCATION : [bi_windup] trees.c:1192

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rsi rdi r8]
        
    Routine temporaries
        Total         :      21
            Global    :       8
            Local     :      13
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateResetKeep()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateResetKeep()) [23/189=12.2%] deflate.c(469,1)
  -> (472,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (494,24) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (496,9) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> (499,5) _tr_init(deflate_state *) (isz = 26) (sz = 31)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

deflate.c(469,1):remark #34051: REGISTER ALLOCATION : [deflateResetKeep] deflate.c:469

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rcx rbx rsi rdi r15]
        
    Routine temporaries
        Total         :      31
            Global    :      12
            Local     :      19
        Regenerable   :       8
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_zero()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_zero()) [24/189=12.7%] gzwrite.c(148,1)
  -> INLINE: (154,27) gz_comp() (isz = 9270) (sz = 9284)
    -> (82,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (89,20) write(int, const void *, size_t)
    -> CP_CLONE (91,17) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (91,42) __errno_location(void)
    -> EXTERN: (91,42) strerror(int)
    -> EXTERN: (110,24) write(int, const void *, size_t)
    -> CP_CLONE (112,21) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (112,46) __errno_location(void)
    -> EXTERN: (112,46) strerror(int)
    -> INLINE: (126,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
      -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
        -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1786,9) read_buf() (isz = 46) (sz = 58)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1810,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
        -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
          -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
          -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
          -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
          -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
            -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
          -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
            -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
          -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
             [[ Callee not marked with inlining pragma  <1>]]
          -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2118,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.1970->level_V$3f))]
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
      -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (128,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
      -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
         [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (163,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
  -> CP_CLONE (169,13) gz_comp..0() (isz = 9270) (sz = 9284)
     [[ Inlining inhibited by overrideable criterion  <2>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(154,27)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(154,27)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(154,27)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(154,27)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(154,27)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(154,27)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(154,27)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(154,27)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(154,27)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(154,27)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(154,27)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(154,27)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(154,27)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(154,27)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(154,27)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(154,27)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(154,27)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(154,27)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(154,27)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(154,27)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(154,27)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(154,27)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(154,27)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(154,27)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(154,27)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(154,27)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(154,27)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(154,27)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(154,27)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(154,27)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(154,27)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at gzwrite.c(159,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(154,27)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(154,27)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(154,27)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(148,1):remark #34051: REGISTER ALLOCATION : [gz_zero] gzwrite.c:148

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2875
            Global    :     709
            Local     :    2166
        Regenerable   :      73
        Spilled       :      71
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [4.92e-02 ~ 0.0%]
            Writes    :      48 [7.20e-01 ~ 0.3%]
        Spills        :     528 bytes*
            Reads     :     177 [4.19e+00 ~ 1.6%]
            Writes    :     133 [5.48e+00 ~ 2.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzputs..0(gzFile, const char *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzputs..0(gzFile, const char *)) [25/189=13.2%] gzwrite.c(355,1)
  -> EXTERN: (370,11) strlen(const char *)
  -> INLINE: (371,11) gz_write() (isz = 9388) (sz = 9405)
    -> (190,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (196,13) gz_zero() (isz = 9326) (sz = 9337)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE (MANUAL): (213,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> CP_CLONE (218,24) gz_comp..0() (isz = 9270) (sz = 9284)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (224,37) gz_comp() (isz = 9270) (sz = 9284)
      -> (82,29) gz_init() (isz = 92) (sz = 102)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (89,20) write(int, const void *, size_t)
      -> CP_CLONE (91,17) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (91,42) __errno_location(void)
      -> EXTERN: (91,42) strerror(int)
      -> EXTERN: (110,24) write(int, const void *, size_t)
      -> CP_CLONE (112,21) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (112,46) __errno_location(void)
      -> EXTERN: (112,46) strerror(int)
      -> INLINE: (126,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
        -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
          -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
            -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1786,9) read_buf() (isz = 46) (sz = 58)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1810,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
          -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
            -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
            -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
              -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
              -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
                 [[ Callee not marked with inlining pragma  <1>]]
              -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
                -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                   [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
            -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
            -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
            -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
              -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
                -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
                -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                  -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
            -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
              -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
              -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
            -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
               [[ Callee not marked with inlining pragma  <1>]]
            -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> (2118,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (2122,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
          -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
        -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.3220->level_V$3f))]
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
        -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (128,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
        -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
           [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (235,17) gz_comp..0() (isz = 9270) (sz = 9284)
       [[ Inlining inhibited by overrideable criterion  <2>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(201,5) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(371,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(371,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(371,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(371,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(371,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(371,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(371,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(371,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(371,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(371,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(371,11)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(371,11)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at gzwrite.c(228,9) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(371,11)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(371,11)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(371,11)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(355,1):remark #34051: REGISTER ALLOCATION : [gzputs..0] gzwrite.c:355

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2903
            Global    :     724
            Local     :    2179
        Regenerable   :      72
        Spilled       :      74
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [4.56e-04 ~ 0.0%]
            Writes    :      48 [6.67e-03 ~ 0.0%]
        Spills        :     544 bytes*
            Reads     :     184 [3.95e-02 ~ 0.1%]
            Writes    :     128 [5.43e-02 ~ 0.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzprintf(gzFile, const char *, ...)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzprintf(gzFile, const char *, ...)) [26/189=13.8%] gzwrite.c(452,1)
  -> EXTERN: (456,5) __builtin_stdarg_start
  -> (457,11) gzvprintf(gzFile, const char *, struct __va_list_tag *) (isz = 9395) (sz = 9412)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (458,5) __builtin_va_end


    Report from: Code generation optimizations [cg]

gzwrite.c(452,1):remark #34051: REGISTER ALLOCATION : [gzprintf] gzwrite.c:452

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      19
            Global    :      10
            Local     :       9
        Regenerable   :       4
        Spilled       :       0
        
    Routine stack
        Variables     :     200 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       4 [4.00e+00 ~ 18.2%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzvprintf(gzFile, const char *, struct __va_list_tag *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzvprintf(gzFile, const char *, struct __va_list_tag *)) [27/189=14.3%] gzwrite.c(380,1)
  -> (398,29) gz_init() (isz = 92) (sz = 102)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (404,13) gz_zero() (isz = 9326) (sz = 9337)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE (MANUAL): (428,11) vsnprintf(char *__restrict__, size_t, const char *__restrict__, struct __va_list_tag *) (isz = 7) (sz = 20)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(80,10) __builtin___vsnprintf_chk(char *, unsigned long, int, unsigned long, const char *, struct __va_list_tag *)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(81,9) __builtin_object_size(const void *, int)
  -> INLINE: (442,13) gz_comp() (isz = 9270) (sz = 9284)
    -> (82,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (89,20) write(int, const void *, size_t)
    -> CP_CLONE (91,17) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (91,42) __errno_location(void)
    -> EXTERN: (91,42) strerror(int)
    -> EXTERN: (110,24) write(int, const void *, size_t)
    -> CP_CLONE (112,21) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (112,46) __errno_location(void)
    -> EXTERN: (112,46) strerror(int)
    -> INLINE: (126,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
      -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
        -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1786,9) read_buf() (isz = 46) (sz = 58)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1810,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
        -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
          -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
          -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
          -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
          -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
            -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
          -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
            -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
          -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
             [[ Callee not marked with inlining pragma  <1>]]
          -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2118,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.2150->level_V$3f))]
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
      -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (128,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
      -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
         [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (444,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(442,13)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(442,13)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(442,13)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(442,13)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(442,13)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(442,13)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(442,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(442,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(442,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(442,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(442,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(442,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(442,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(442,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(442,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(442,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(442,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(442,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(442,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(442,13)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(442,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(442,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(442,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(442,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(442,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(442,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(442,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(442,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(442,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(442,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(442,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(442,13)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(442,13)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(442,13)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(380,1):remark #34051: REGISTER ALLOCATION : [gzvprintf] gzwrite.c:380

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2909
            Global    :     718
            Local     :    2191
        Regenerable   :      73
        Spilled       :      76
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [7.74e-03 ~ 0.0%]
            Writes    :      48 [1.13e-01 ~ 0.2%]
        Spills        :     552 bytes*
            Reads     :     194 [8.12e-01 ~ 1.2%]
            Writes    :     148 [1.06e+00 ~ 1.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzopen(const char *, const char *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzopen(const char *, const char *)) [28/189=14.8%] gzlib.c(273,1)
  -> INLINE: (274,12) gz_open() (isz = 257) (sz = 275)
    -> EXTERN: (111,24) malloc(size_t)
    -> EXTERN: (140,17) free(void *)
    -> EXTERN: (177,9) free(void *)
    -> EXTERN: (184,13) free(void *)
    -> EXTERN: (199,15) strlen(const char *)
    -> EXTERN: (200,27) malloc(size_t)
    -> EXTERN: (202,9) free(void *)
    -> INLINE: (214,15) snprintf(char *__restrict__, size_t, const char *__restrict__, ...) (isz = 10) (sz = 21)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(67,10) __builtin___snprintf_chk(char *, unsigned long, int, unsigned long, const char *, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,8) __builtin_object_size(const void *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,28) __builtin_va_arg_pack(void)
    -> INLINE: (245,9) open(const char *, int, ...) (isz = 48) (sz = 60)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(43,7) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(44,5) __open_too_many_args(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(46,7) __builtin_constant_p(...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(48,42) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(50,4) __open_missing_mode(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(51,11) __open_2(const char *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(53,14) __open_alias(const char *, int, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(53,45) __builtin_va_arg_pack(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(56,7) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(57,12) __open_2(const char *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(59,10) __open_alias(const char *, int, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(59,41) __builtin_va_arg_pack(void)
    -> EXTERN: (247,9) free(void *)
    -> EXTERN: (248,9) free(void *)
    -> EXTERN: (252,9) lseek64(int, __off64_t, int)
    -> EXTERN: (258,24) lseek64(int, __off64_t, int)
    -> INLINE: (263,5) gz_reset() (isz = 19) (sz = 24)
      -> CP_CLONE (85,5) gz_error..5(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]



Non-optimizable loops:


LOOP BEGIN at gzlib.c(123,5) inlined into gzlib.c(274,12)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ gzlib.c(127,13) ]
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

gzlib.c(273,1):remark #34051: REGISTER ALLOCATION : [gzopen] gzlib.c:273

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   14[ rax rdx rcx rbx rbp rsi rdi r8-r11 r13-r15]
        
    Routine temporaries
        Total         :      76
            Global    :      31
            Local     :      45
        Regenerable   :      21
        Spilled       :       5
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzread(gzFile, voidp, unsigned int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzread(gzFile, voidp, unsigned int)) [29/189=15.3%] gzread.c(379,1)
  -> CP_CLONE (395,9) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (400,11) gz_read() (isz = 5842) (sz = 5858)
    -> (309,13) gz_skip() (isz = 6092) (sz = 6102)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE (MANUAL): (325,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (340,17) gz_fetch() (isz = 6046) (sz = 6058)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (349,17) gz_load() (isz = 42) (sz = 56)
      -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
      -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (41,34) strerror(int)
      -> EXTERN: (41,34) __errno_location(void)
    -> INLINE: (357,17) gz_decomp() (isz = 5691) (sz = 5702)
      -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
        -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
          -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
          -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
             [[ Callee not marked with inlining pragma  <1>]]
          -> EXTERN: (41,34) strerror(int)
          -> EXTERN: (41,34) __errno_location(void)
      -> CP_CLONE (189,13) gz_error..3(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (194,15) inflate(z_streamp, int) (isz = 5502) (sz = 5516)
        -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
        -> INLINE: inflate.c:(667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
        -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
        -> INLINE: inflate.c:(1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
           [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (196,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (201,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (205,13) gz_error..4(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(400,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(400,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(400,11)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(400,11)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(400,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(400,11)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(400,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(400,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(400,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(400,11)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(400,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(400,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(400,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(400,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(400,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(400,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(400,11)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(400,11)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(400,11)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(400,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(400,11)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(400,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(400,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(400,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(400,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(400,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(400,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(400,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(400,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(400,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(400,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(400,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(400,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(400,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(400,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(400,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(368,14) inlined into gzread.c(400,11)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(400,11)
      remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(400,11)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(400,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(400,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(400,11)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END

         LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(400,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(400,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(400,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(400,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(400,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(400,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(379,1):remark #34051: REGISTER ALLOCATION : [gzread] gzread.c:379

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1709
            Global    :     414
            Local     :    1295
        Regenerable   :      84
        Spilled       :     114
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :     131 [2.36e-01 ~ 0.3%]
            Writes    :     159 [3.24e-01 ~ 0.5%]
        Spills        :     832 bytes*
            Reads     :     573 [1.23e+00 ~ 1.7%]
            Writes    :     295 [1.59e+00 ~ 2.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_skip()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_skip()) [30/189=15.9%] gzread.c(262,1)
  -> INLINE: (284,17) gz_fetch() (isz = 6046) (sz = 6058)
    -> INLINE: (237,17) gz_look() (isz = 249) (sz = 262)
      -> EXTERN: (99,38) malloc(size_t)
      -> EXTERN: (100,39) malloc(size_t)
      -> EXTERN: (102,13) free(void *)
      -> EXTERN: (103,13) free(void *)
      -> CP_CLONE (104,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (115,13) inflateInit2_..0() (isz = 58) (sz = 74)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (116,13) free(void *)
      -> EXTERN: (117,13) free(void *)
      -> CP_CLONE (119,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (126,13) gz_avail() (isz = 103) (sz = 112)
        -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
          -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
          -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
             [[ Callee not marked with inlining pragma  <1>]]
          -> EXTERN: (41,34) strerror(int)
          -> EXTERN: (41,34) __errno_location(void)
      -> (141,9) inflateReset() (isz = 40) (sz = 48)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (161,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (243,17) gz_load() (isz = 42) (sz = 56)
      -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
      -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (41,34) strerror(int)
      -> EXTERN: (41,34) __errno_location(void)
    -> INLINE: (251,17) gz_decomp() (isz = 5691) (sz = 5702)
      -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
        -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
          -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
          -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
             [[ Callee not marked with inlining pragma  <1>]]
          -> EXTERN: (41,34) strerror(int)
          -> EXTERN: (41,34) __errno_location(void)
      -> CP_CLONE (189,13) gz_error..3(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (194,15) inflate(z_streamp, int) (isz = 5502) (sz = 5516)
        -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
        -> INLINE: inflate.c:(667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
        -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
        -> INLINE: inflate.c:(1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
           [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (196,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (201,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (205,13) gz_error..4(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(284,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(284,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(284,17)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(284,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(284,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(284,17)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(284,17)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(284,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(284,17)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(284,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(284,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(284,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(284,17)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(284,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(284,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(284,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(284,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(284,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(284,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(284,17)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(284,17)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(284,17)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(284,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(284,17)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(284,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(284,17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(284,17)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(284,17)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(284,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(284,17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(284,17)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(284,17)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(284,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(284,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(284,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(284,17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(284,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(284,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(284,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(266,5)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(254,31) inlined into gzread.c(284,17)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(284,17)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(284,17)
            remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(284,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(284,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate

               LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(284,17)
                  remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
                  remark #17102: loop was not parallelized: not a parallelization candidate
               LOOP END
            LOOP END

            LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(284,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(284,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(284,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(284,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(284,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(284,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(262,1):remark #34051: REGISTER ALLOCATION : [gz_skip] gzread.c:262

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    1794
            Global    :     450
            Local     :    1344
        Regenerable   :      98
        Spilled       :     107
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :     131 [0.00e+00 ~ 0.0%]
            Writes    :     159 [0.00e+00 ~ 0.0%]
        Spills        :     800 bytes*
            Reads     :     768 [3.28e+00 ~ 1.9%]
            Writes    :     313 [3.48e+00 ~ 2.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: crc32_z()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (crc32_z()) [31/189=16.4%] crc32.c(206,1)
  -> INLINE: (220,20) crc32_little() (isz = 274) (sz = 285)
  -> INLINE: (222,20) crc32_big() (isz = 274) (sz = 285)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at crc32.c(276,5) inlined into crc32.c(220,20)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c (277:9) and c (277:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (277:9) and c (277:9)
   remark #17106: parallel dependence: assumed ANTI dependence between c (277:9) and c (277:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (277:9) and c (277:9)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ crc32.c(278,9) ]
LOOP END

LOOP BEGIN at crc32.c(282,5) inlined into crc32.c(220,20)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c (283:9) and c (283:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (283:9) and c (283:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (283:9) and c (283:9)
   remark #17106: parallel dependence: assumed ANTI dependence between c (283:9) and c (283:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between c (283:9) and c (283:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (283:9) and c (283:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (283:9) and c (283:9)
   remark #15346: vector dependence: assumed ANTI dependence between c (283:9) and c (283:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at crc32.c(286,5) inlined into crc32.c(220,20)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c (287:9) and c (287:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (287:9) and c (287:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (287:9) and c (287:9)
   remark #17106: parallel dependence: assumed ANTI dependence between c (287:9) and c (287:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between c (287:9) and c (287:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (287:9) and c (287:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (287:9) and c (287:9)
   remark #15346: vector dependence: assumed ANTI dependence between c (287:9) and c (287:9)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at crc32.c(286,5) inlined into crc32.c(220,20)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at crc32.c(292,5) inlined into crc32.c(220,20)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c (293:9) and c (293:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (293:9) and c (293:9)
   remark #17106: parallel dependence: assumed ANTI dependence between c (293:9) and c (293:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (293:9) and c (293:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between c (293:9) and c (293:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (293:9) and c (293:9)
   remark #15346: vector dependence: assumed ANTI dependence between c (293:9) and c (293:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (293:9) and c (293:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at crc32.c(292,5) inlined into crc32.c(220,20)
<Remainder>
LOOP END

LOOP BEGIN at crc32.c(316,5) inlined into crc32.c(222,20)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c (317:9) and c (317:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (317:9) and c (317:9)
   remark #17106: parallel dependence: assumed ANTI dependence between c (317:9) and c (317:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (317:9) and c (317:9)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ crc32.c(318,9) ]
LOOP END

LOOP BEGIN at crc32.c(322,5) inlined into crc32.c(222,20)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c (323:9) and c (323:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (323:9) and c (323:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (323:9) and c (323:9)
   remark #17106: parallel dependence: assumed ANTI dependence between c (323:9) and c (323:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between c (323:9) and c (323:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (323:9) and c (323:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (323:9) and c (323:9)
   remark #15346: vector dependence: assumed ANTI dependence between c (323:9) and c (323:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at crc32.c(326,5) inlined into crc32.c(222,20)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c (327:9) and c (327:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (327:9) and c (327:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (327:9) and c (327:9)
   remark #17106: parallel dependence: assumed ANTI dependence between c (327:9) and c (327:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between c (327:9) and c (327:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (327:9) and c (327:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (327:9) and c (327:9)
   remark #15346: vector dependence: assumed ANTI dependence between c (327:9) and c (327:9)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at crc32.c(326,5) inlined into crc32.c(222,20)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at crc32.c(332,5) inlined into crc32.c(222,20)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between c (333:9) and c (333:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (333:9) and c (333:9)
   remark #17106: parallel dependence: assumed ANTI dependence between c (333:9) and c (333:9)
   remark #17106: parallel dependence: assumed FLOW dependence between c (333:9) and c (333:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between c (333:9) and c (333:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (333:9) and c (333:9)
   remark #15346: vector dependence: assumed ANTI dependence between c (333:9) and c (333:9)
   remark #15346: vector dependence: assumed FLOW dependence between c (333:9) and c (333:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at crc32.c(332,5) inlined into crc32.c(222,20)
<Remainder>
LOOP END

    Report from: Code generation optimizations [cg]

crc32.c(206,1):remark #34051: REGISTER ALLOCATION : [crc32_z] crc32.c:206

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r8-r11]
        
    Routine temporaries
        Total         :     219
            Global    :      23
            Local     :     196
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: updatewindow()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (updatewindow()) [32/189=16.9%] inflate.c(400,1)
  -> INDIRECT-: (409,25)  strm_665_V$61.3.29->zalloc_V$4c
     [[ Unable to inline indirect callsite  <3>]]
  -> INLINE (MANUAL): (423,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (430,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (433,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(400,1):remark #34051: REGISTER ALLOCATION : [updatewindow] inflate.c:400

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rbp rsi rdi r12-r14]
        
    Routine temporaries
        Total         :      60
            Global    :      18
            Local     :      42
        Regenerable   :       6
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateReset()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateReset()) [33/189=17.5%] inflate.c(146,1)
  -> INLINE: (149,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> (154,12) inflateResetKeep() (isz = 74) (sz = 82)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

inflate.c(146,1):remark #34051: REGISTER ALLOCATION : [inflateReset] inflate.c:146

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rax rdx rdi]
        
    Routine temporaries
        Total         :      13
            Global    :       9
            Local     :       4
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateResetKeep()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateResetKeep()) [34/189=18.0%] inflate.c(121,1)
  -> INLINE: (124,9) inflateStateCheck() (isz = 25) (sz = 34)


    Report from: Code generation optimizations [cg]

inflate.c(121,1):remark #34051: REGISTER ALLOCATION : [inflateResetKeep] inflate.c:121

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rcx rdi]
        
    Routine temporaries
        Total         :      18
            Global    :      11
            Local     :       7
        Regenerable   :       4
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzseek64()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzseek64()) [35/189=18.5%] gzlib.c(370,1)
  -> EXTERN: (400,15) lseek64(int, __off64_t, int)
  -> CP_CLONE (407,9) gz_error..5(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (PARTIAL): (420,13) gzrewind() (isz = 10) (sz = 10)
    -> PI_CLONE (349,5) gzrewind..0() (isz = 0) (sz = 0)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzlib.c(370,1):remark #34051: REGISTER ALLOCATION : [gzseek64] gzlib.c:370

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rcx rbp rsi rdi r12]
        
    Routine temporaries
        Total         :      50
            Global    :      16
            Local     :      34
        Regenerable   :      12
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzrewind..0()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzrewind..0()) [36/189=19.0%] gzlib.c(345,1)
  -> EXTERN: (359,9) lseek64(int, __off64_t, int)
  -> INLINE: (361,5) gz_reset() (isz = 19) (sz = 24)
    -> CP_CLONE (85,5) gz_error..5(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzlib.c(345,1):remark #34051: REGISTER ALLOCATION : [gzrewind..0] gzlib.c:345

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    5[ rax rdx rsi rdi r14]
        
    Routine temporaries
        Total         :      23
            Global    :      10
            Local     :      13
        Regenerable   :       7
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzgetc..0(gzFile)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzgetc..0(gzFile)) [37/189=19.6%] gzread.c(449,1)
  -> INLINE: (472,11) gz_read() (isz = 5842) (sz = 5858)
    -> (309,13) gz_skip() (isz = 6092) (sz = 6102)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE (MANUAL): (325,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (340,17) gz_fetch() (isz = 6046) (sz = 6058)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (349,17) gz_load() (isz = 42) (sz = 56)
      -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
      -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (41,34) __errno_location(void)
      -> EXTERN: (41,34) strerror(int)
    -> INLINE: (357,17) gz_decomp() (isz = 5691) (sz = 5702)
      -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
        -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
          -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
          -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
             [[ Callee not marked with inlining pragma  <1>]]
          -> EXTERN: (41,34) __errno_location(void)
          -> EXTERN: (41,34) strerror(int)
      -> CP_CLONE (189,13) gz_error..3(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (194,15) inflate(z_streamp, int) (isz = 5502) (sz = 5516)
        -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
        -> INLINE: inflate.c:(667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
        -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
        -> INLINE: inflate.c:(1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (196,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (201,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (205,13) gz_error..4(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(472,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(472,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(472,11)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(472,11)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(472,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(472,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(472,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(472,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(472,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(472,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(472,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(472,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(472,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(472,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(472,11)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(472,11)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(472,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(472,11)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(472,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(472,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(472,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(472,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(472,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(368,14) inlined into gzread.c(472,11)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(472,11)
      remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(472,11)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(472,11)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END

         LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(449,1):remark #34051: REGISTER ALLOCATION : [gzgetc..0] gzread.c:449

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1705
            Global    :     415
            Local     :    1290
        Regenerable   :      77
        Spilled       :     111
        
    Routine stack
        Variables     :     217 bytes*
            Reads     :     132 [1.43e-01 ~ 0.3%]
            Writes    :     159 [1.37e-01 ~ 0.3%]
        Spills        :     832 bytes*
            Reads     :     619 [5.32e-01 ~ 1.2%]
            Writes    :     294 [6.74e-01 ~ 1.6%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzungetc..0(int, gzFile)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzungetc..0(int, gzFile)) [38/189=20.1%] gzread.c(486,1)
  -> INLINE: (502,13) gz_skip() (isz = 6092) (sz = 6102)
    -> INLINE: (284,17) gz_fetch() (isz = 6046) (sz = 6058)
      -> INLINE: (237,17) gz_look() (isz = 249) (sz = 262)
        -> EXTERN: (99,38) malloc(size_t)
        -> EXTERN: (100,39) malloc(size_t)
        -> EXTERN: (102,13) free(void *)
        -> EXTERN: (103,13) free(void *)
        -> CP_CLONE (104,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (115,13) inflateInit2_..0() (isz = 58) (sz = 74)
           [[ Callee not marked with inlining pragma  <1>]]
        -> EXTERN: (116,13) free(void *)
        -> EXTERN: (117,13) free(void *)
        -> CP_CLONE (119,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (126,13) gz_avail() (isz = 103) (sz = 112)
          -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
            -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
            -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
               [[ Callee not marked with inlining pragma  <1>]]
            -> EXTERN: (41,34) strerror(int)
            -> EXTERN: (41,34) __errno_location(void)
        -> (141,9) inflateReset() (isz = 40) (sz = 48)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (161,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (243,17) gz_load() (isz = 42) (sz = 56)
        -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
        -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> EXTERN: (41,34) strerror(int)
        -> EXTERN: (41,34) __errno_location(void)
      -> INLINE: (251,17) gz_decomp() (isz = 5691) (sz = 5702)
        -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
          -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
            -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
            -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
               [[ Callee not marked with inlining pragma  <1>]]
            -> EXTERN: (41,34) strerror(int)
            -> EXTERN: (41,34) __errno_location(void)
        -> CP_CLONE (189,13) gz_error..3(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (194,15) inflate(z_streamp, int) (isz = 5502) (sz = 5516)
          -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
          -> INLINE: inflate.c:(667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
            -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
          -> INLINE: inflate.c:(722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: inflate.c:(769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
            -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
          -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
          -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
          -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
          -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
          -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
          -> INLINE: inflate.c:(1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
            -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
          -> INLINE: inflate.c:(1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
             [[ Callee not marked with inlining pragma  <1>]]
          -> inflate.c:(1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (196,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (201,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (205,13) gz_error..4(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
  -> CP_CLONE (522,9) gz_error..4(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(502,13)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(502,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(502,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(502,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(502,13)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(502,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(502,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(502,13)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(502,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(502,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(502,13)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(502,13)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(502,13)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(502,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(502,13)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(502,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(502,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(502,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(502,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(502,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(502,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(502,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(502,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(530,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable dest was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(266,5) inlined into gzread.c(502,13)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(254,31) inlined into gzread.c(502,13)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(502,13)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(502,13)
            remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate

               LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(502,13)
                  remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
                  remark #17102: loop was not parallelized: not a parallelization candidate
               LOOP END
            LOOP END

            LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(486,1):remark #34051: REGISTER ALLOCATION : [gzungetc..0] gzread.c:486

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    1830
            Global    :     463
            Local     :    1367
        Regenerable   :     103
        Spilled       :     108
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :     131 [0.00e+00 ~ 0.0%]
            Writes    :     159 [0.00e+00 ~ 0.0%]
        Spills        :     808 bytes*
            Reads     :     769 [1.90e-01 ~ 0.5%]
            Writes    :     304 [2.03e-01 ~ 0.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzgets(gzFile, char *, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzgets(gzFile, char *, int)) [39/189=20.6%] gzread.c(547,1)
  -> (566,13) gz_skip() (isz = 6092) (sz = 6102)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (577,35) gz_fetch() (isz = 6046) (sz = 6058)
    -> INLINE: (237,17) gz_look() (isz = 249) (sz = 262)
      -> EXTERN: (99,38) malloc(size_t)
      -> EXTERN: (100,39) malloc(size_t)
      -> EXTERN: (102,13) free(void *)
      -> EXTERN: (103,13) free(void *)
      -> CP_CLONE (104,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (115,13) inflateInit2_..0() (isz = 58) (sz = 74)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (116,13) free(void *)
      -> EXTERN: (117,13) free(void *)
      -> CP_CLONE (119,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (126,13) gz_avail() (isz = 103) (sz = 112)
        -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
          -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
          -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
             [[ Callee not marked with inlining pragma  <1>]]
          -> EXTERN: (41,34) strerror(int)
          -> EXTERN: (41,34) __errno_location(void)
      -> (141,9) inflateReset() (isz = 40) (sz = 48)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (161,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (243,17) gz_load() (isz = 42) (sz = 56)
      -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
      -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (41,34) strerror(int)
      -> EXTERN: (41,34) __errno_location(void)
    -> INLINE: (251,17) gz_decomp() (isz = 5691) (sz = 5702)
      -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
        -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
          -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
          -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
             [[ Callee not marked with inlining pragma  <1>]]
          -> EXTERN: (41,34) strerror(int)
          -> EXTERN: (41,34) __errno_location(void)
      -> CP_CLONE (189,13) gz_error..3(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (194,15) inflate(z_streamp, int) (isz = 5502) (sz = 5516)
        -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
        -> INLINE: inflate.c:(667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
        -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
        -> INLINE: inflate.c:(1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
           [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (196,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (201,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (205,13) gz_error..4(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (586,32) memchr(const void *, int, size_t)
  -> INLINE (MANUAL): (591,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(577,35)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(577,35)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(577,35)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(577,35)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(577,35)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(577,35)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(577,35)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(577,35)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(577,35)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(577,35)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(577,35)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(577,35)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(577,35)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(577,35)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(577,35)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(577,35)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(577,35)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(577,35)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(577,35)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(577,35)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(577,35)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(577,35)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(577,35)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(577,35)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(577,35)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(577,35)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(577,35)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(577,35)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(577,35)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(577,35)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(577,35)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(577,35)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(577,35)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(577,35)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(577,35)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(577,35)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(577,35)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(577,35)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(577,35)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(597,14)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(254,31) inlined into gzread.c(577,35)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(577,35)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(577,35)
            remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(577,35)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(577,35)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate

               LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(577,35)
                  remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
                  remark #17102: loop was not parallelized: not a parallelization candidate
               LOOP END
            LOOP END

            LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(577,35)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(577,35)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(577,35)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(577,35)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(577,35)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(577,35)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(547,1):remark #34051: REGISTER ALLOCATION : [gzgets] gzread.c:547

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    1818
            Global    :     460
            Local     :    1358
        Regenerable   :     101
        Spilled       :     108
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :     131 [0.00e+00 ~ 0.0%]
            Writes    :     159 [0.00e+00 ~ 0.0%]
        Spills        :     808 bytes*
            Reads     :     772 [4.15e-01 ~ 0.9%]
            Writes    :     308 [6.68e-01 ~ 1.4%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzclose_w..0(gzFile)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzclose_w..0(gzFile)) [40/189=21.2%] gzwrite.c(629,1)
  -> (645,13) gz_zero() (isz = 9326) (sz = 9337)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (650,9) gz_comp() (isz = 9270) (sz = 9284)
    -> (82,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (89,20) write(int, const void *, size_t)
    -> CP_CLONE (91,17) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (91,42) strerror(int)
    -> EXTERN: (91,42) __errno_location(void)
    -> EXTERN: (110,24) write(int, const void *, size_t)
    -> CP_CLONE (112,21) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (112,46) strerror(int)
    -> EXTERN: (112,46) __errno_location(void)
    -> INLINE: (126,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
      -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
        -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1786,9) read_buf() (isz = 46) (sz = 58)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1810,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
        -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
          -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
          -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
          -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
          -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
            -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
          -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
            -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
          -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
             [[ Callee not marked with inlining pragma  <1>]]
          -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
        -> (2118,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2122,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.3037->level_V$3f))]
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
      -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (128,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
      -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
         [[ Callee not marked with inlining pragma  <1>]]
  -> (654,19) deflateEnd(z_streamp) (isz = 63) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (655,13) free(void *)
  -> EXTERN: (657,9) free(void *)
  -> CP_CLONE (659,5) gz_error..5(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (660,5) free(void *)
  -> EXTERN: (661,9) close(int)
  -> EXTERN: (663,5) free(void *)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(650,9)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(650,9)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(650,9)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(650,9)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(650,9)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(650,9)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(650,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(650,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(650,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(650,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(650,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(650,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(650,9)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(650,9)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(650,9)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(629,1):remark #34051: REGISTER ALLOCATION : [gzclose_w..0] gzwrite.c:629

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :    2939
            Global    :     721
            Local     :    2218
        Regenerable   :      66
        Spilled       :      83
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [6.98e-02 ~ 0.0%]
            Writes    :      48 [1.02e+00 ~ 0.4%]
        Spills        :     624 bytes*
            Reads     :     227 [6.68e+00 ~ 2.4%]
            Writes    :     160 [8.08e+00 ~ 2.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzclose_r..0()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzclose_r..0()) [41/189=21.7%] gzread.c(629,1)
  -> (644,9) inflateEnd(z_streamp) (isz = 48) (sz = 56)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (645,9) free(void *)
  -> EXTERN: (646,9) free(void *)
  -> CP_CLONE (649,5) gz_error..5(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (650,5) free(void *)
  -> EXTERN: (651,11) close(int)
  -> EXTERN: (652,5) free(void *)


    Report from: Code generation optimizations [cg]

gzread.c(629,1):remark #34051: REGISTER ALLOCATION : [gzclose_r..0] gzread.c:629

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rcx rbx rsi rdi r14-r15]
        
    Routine temporaries
        Total         :      32
            Global    :      10
            Local     :      22
        Regenerable   :       6
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: test_deflate()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (test_deflate()) [42/189=22.2%] test/example.c(203,1)
  -> EXTERN: (206,24) strlen(const char *)
  -> (212,11) deflateInit_(z_streamp, int, const char *, int) (isz = 5) (sz = 18)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (213,5) exit(int)
  -> INLINE: (213,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> CP_CLONE (220,15) deflate..0(z_streamp, int) (isz = 9099) (sz = 9125)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> EXTERN: (221,9) exit(int)
  -> INLINE: (221,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> INLINE: (226,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
    -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
      -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
        -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1786,9) read_buf() (isz = 46) (sz = 58)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1810,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
      -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
        -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
        -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
        -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
        -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
          -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
        -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
          -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
        -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
        -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
           [[ Callee not marked with inlining pragma  <1>]]
        -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
      -> (2118,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> (2122,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.1263->level_V$3f))]
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
      -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
    -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (228,9) exit(int)
  -> INLINE: (228,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> (231,11) deflateEnd(z_streamp) (isz = 63) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (232,5) exit(int)
  -> INLINE: (232,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at test/example.c(218,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into test/example.c(226,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into test/example.c(226,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into test/example.c(226,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into test/example.c(226,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into test/example.c(226,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(226,15)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(226,15)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(226,15)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(226,15)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(226,15)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(226,15)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into test/example.c(226,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into test/example.c(226,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(226,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(226,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(226,15)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(226,15)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(226,15)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(226,15)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(226,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(226,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(226,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into test/example.c(226,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into test/example.c(226,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into test/example.c(226,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into test/example.c(226,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into test/example.c(226,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(226,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(226,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(226,15)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(226,15)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(226,15)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(226,15)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(226,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(226,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(226,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into test/example.c(226,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into test/example.c(226,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into test/example.c(226,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into test/example.c(226,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into test/example.c(226,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(226,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(226,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(226,15)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(226,15)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(226,15)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(226,15)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(226,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(226,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(226,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into test/example.c(226,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into test/example.c(226,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into test/example.c(226,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into test/example.c(226,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into test/example.c(226,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into test/example.c(226,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(226,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(226,15)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into test/example.c(226,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(226,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(226,15)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into test/example.c(226,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into test/example.c(226,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at test/example.c(228,9)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into test/example.c(226,15)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into test/example.c(226,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
test/example.c(203,1):remark #34051: REGISTER ALLOCATION : [test_deflate] test/example.c:203

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :    3055
            Global    :     744
            Local     :    2311
        Regenerable   :     107
        Spilled       :      69
        
    Routine stack
        Variables     :     208 bytes*
            Reads     :      55 [9.78e+00 ~ 1.6%]
            Writes    :      77 [1.39e+01 ~ 2.2%]
        Spills        :     504 bytes*
            Reads     :     235 [1.18e+01 ~ 1.9%]
            Writes    :     169 [1.14e+01 ~ 1.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflate..0(z_streamp, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflate..0(z_streamp, int)) [43/189=22.8%] deflate.c(766,1)
  CLONED FROM: deflate(z_streamp, int)(X,0)
  -> (770,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (787,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (831,9) putShortMSB() (isz = 23) (sz = 30)
  -> INLINE: (835,13) putShortMSB() (isz = 23) (sz = 30)
  -> INLINE: (836,13) putShortMSB() (isz = 23) (sz = 30)
  -> INLINE: (838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> (842,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (868,13) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (911,17) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (934,21) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (956,21) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (973,17) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (986,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1000,34) deflate_stored() (isz = 676) (sz = 687)
    -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
      -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
      -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (1786,9) read_buf() (isz = 46) (sz = 58)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (1810,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (1001,50) deflate_huff() (isz = 11827) (sz = 11841)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (1002,41) deflate_rle() (isz = 6524) (sz = 6538)
    -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
      -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
      -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
        -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
      -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
      -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
      -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
      -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
        -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
        -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
        -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
      -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
      -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
        -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
        -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
      -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
      -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
         [[ Callee not marked with inlining pragma  <1>]]
      -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (2118,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> (2122,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT: (1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.3593->level_V$3f))]
     [[ Callee not marked with inlining pragma  <1>]]
  -> (1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
    -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
  -> (1038,13) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1064,9) putShortMSB() (isz = 23) (sz = 30)
  -> INLINE: (1065,9) putShortMSB() (isz = 23) (sz = 30)
  -> (1067,5) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(904,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into deflate.c(1000,34)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into deflate.c(1002,41)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1002,41)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1002,41)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1002,41)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1002,41)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1002,41)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1002,41)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into deflate.c(1002,41)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1002,41)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1002,41)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1002,41)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(1002,41)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1002,41)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1002,41)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(1002,41)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(1002,41)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at deflate.c(2114,9) inlined into deflate.c(1002,41)
   remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at trees.c(1143,5) inlined into deflate.c(1002,41)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(766,1):remark #34051: REGISTER ALLOCATION : [deflate..0] deflate.c:766

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :    2816
            Global    :     683
            Local     :    2133
        Regenerable   :      77
        Spilled       :      66
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [1.28e-01 ~ 0.0%]
            Writes    :      48 [1.87e+00 ~ 0.5%]
        Spills        :     488 bytes*
            Reads     :     154 [1.00e+01 ~ 2.6%]
            Writes    :     121 [1.24e+01 ~ 3.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: test_inflate()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (test_inflate()) [44/189=23.3%] test/example.c(241,1)
  -> INLINE (MANUAL): (245,5) strcpy(char *__restrict__, const char *__restrict__) (isz = 6) (sz = 15)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(90,10) __builtin___strcpy_chk(char *, const char *, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(90,49) __builtin_object_size(const void *, int)
  -> (255,11) inflateInit_(z_streamp, const char *, int) (isz = 2) (sz = 13)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (256,5) exit(int)
  -> INLINE: (256,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> INLINE: (260,15) inflate(z_streamp, int) (isz = 5502) (sz = 5516)
    -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
    -> INLINE: inflate.c:(667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: inflate.c:(769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
    -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
    -> INLINE: inflate.c:(1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
       [[ Callee not marked with inlining pragma  <1>]]
    -> inflate.c:(1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (262,9) exit(int)
  -> INLINE: (262,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> (265,11) inflateEnd(z_streamp) (isz = 48) (sz = 56)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (266,5) exit(int)
  -> INLINE: (266,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (268,9) strcmp(const char *, const char *)
  -> INLINE: (269,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (270,9) exit(int)
  -> INLINE: (272,9) printf(const char *__restrict__, ...) (isz = 5) (sz = 12)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,10) __printf_chk(int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,56) __builtin_va_arg_pack(void)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inflate.c(1223,17) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into test/example.c(260,15)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into test/example.c(260,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into test/example.c(260,15)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into test/example.c(260,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 8  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into test/example.c(260,15)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into test/example.c(260,15)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into test/example.c(260,15)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into test/example.c(260,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into test/example.c(260,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into test/example.c(260,15)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into test/example.c(260,15)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into test/example.c(260,15)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into test/example.c(260,15)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into test/example.c(260,15)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into test/example.c(260,15)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into test/example.c(260,15)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into test/example.c(260,15)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into test/example.c(260,15)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into test/example.c(260,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into test/example.c(260,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into test/example.c(260,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into test/example.c(260,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into test/example.c(260,15)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into test/example.c(260,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference d_stream.state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into test/example.c(260,15)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into test/example.c(260,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(260,15)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(260,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(260,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into test/example.c(260,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into test/example.c(260,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into test/example.c(260,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into test/example.c(260,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into test/example.c(260,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(260,15)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(260,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(260,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into test/example.c(260,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into test/example.c(260,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into test/example.c(260,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into test/example.c(260,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into test/example.c(260,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between d_stream.state->lens[order[state->have]] (945:17) and d_stream.state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between d_stream.state->lens[order[state->have]] (945:17) and d_stream.state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <d_stream.state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into test/example.c(260,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into test/example.c(260,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(260,15)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into test/example.c(260,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into test/example.c(260,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into test/example.c(260,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into test/example.c(260,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into test/example.c(260,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into test/example.c(260,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into test/example.c(260,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at test/example.c(258,5)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at inflate.c(1226,21) inlined into test/example.c(260,15)
      remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1107,17) inlined into test/example.c(260,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inffast.c(290,19) inlined into test/example.c(260,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inffast.c(277,20) inlined into test/example.c(260,15)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END

      LOOP BEGIN at inflate.c(1057,17) inlined into test/example.c(260,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inflate.c(960,13) inlined into test/example.c(260,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into test/example.c(260,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into test/example.c(260,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inflate.c(939,13) inlined into test/example.c(260,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into test/example.c(260,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(90,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
test/example.c(241,1):remark #34051: REGISTER ALLOCATION : [test_inflate] test/example.c:241

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1695
            Global    :     385
            Local     :    1310
        Regenerable   :      93
        Spilled       :     111
        
    Routine stack
        Variables     :     328 bytes*
            Reads     :     146 [1.07e+01 ~ 3.0%]
            Writes    :     217 [1.64e+01 ~ 4.6%]
        Spills        :     792 bytes*
            Reads     :     571 [7.22e+00 ~ 2.0%]
            Writes    :     243 [1.13e+01 ~ 3.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: test_large_deflate()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (test_large_deflate()) [45/189=23.8%] test/example.c(282,1)
  -> (290,11) deflateInit_(z_streamp, int, const char *, int) (isz = 5) (sz = 18)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (291,5) exit(int)
  -> INLINE: (291,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> INLINE: (301,11) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
    -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
      -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
        -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1786,9) read_buf() (isz = 46) (sz = 58)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1810,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
      -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
        -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
        -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
        -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
        -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
          -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
        -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
          -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
        -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
        -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
           [[ Callee not marked with inlining pragma  <1>]]
        -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
      -> (2118,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> (2122,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.1351->level_V$3f))]
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
      -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
    -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (302,5) exit(int)
  -> INLINE: (302,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> INLINE: (304,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (305,9) exit(int)
  -> (309,5) deflateParams(z_streamp, int, int) (isz = 9246) (sz = 9261)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> CP_CLONE (312,11) deflate..0(z_streamp, int) (isz = 9099) (sz = 9125)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> EXTERN: (313,5) exit(int)
  -> INLINE: (313,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> (316,5) deflateParams(z_streamp, int, int) (isz = 9246) (sz = 9261)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> CP_CLONE (319,11) deflate..0(z_streamp, int) (isz = 9099) (sz = 9125)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> EXTERN: (320,5) exit(int)
  -> INLINE: (320,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> CP_CLONE (322,11) deflate..1(z_streamp, int) (isz = 9099) (sz = 9125)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (324,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (325,9) exit(int)
  -> (327,11) deflateEnd(z_streamp) (isz = 63) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (328,5) exit(int)
  -> INLINE: (328,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(904,13) inlined into test/example.c(301,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into test/example.c(301,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into test/example.c(301,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into test/example.c(301,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into test/example.c(301,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(301,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(301,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(301,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(301,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(301,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(301,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into test/example.c(301,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into test/example.c(301,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(301,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(301,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(301,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(301,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(301,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(301,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(301,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(301,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(301,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into test/example.c(301,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into test/example.c(301,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into test/example.c(301,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into test/example.c(301,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into test/example.c(301,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(301,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(301,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(301,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(301,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(301,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(301,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(301,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(301,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(301,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into test/example.c(301,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into test/example.c(301,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into test/example.c(301,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into test/example.c(301,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into test/example.c(301,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(301,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(301,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(301,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(301,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(301,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(301,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(301,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(301,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(301,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into test/example.c(301,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into test/example.c(301,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into test/example.c(301,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into test/example.c(301,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into test/example.c(301,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into test/example.c(301,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(301,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(301,11)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into test/example.c(301,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(301,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(301,11)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into test/example.c(301,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into test/example.c(301,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at deflate.c(2114,9) inlined into test/example.c(301,11)
   remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at trees.c(1143,5) inlined into test/example.c(301,11)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
test/example.c(282,1):remark #34051: REGISTER ALLOCATION : [test_large_deflate] test/example.c:282

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :    3038
            Global    :     740
            Local     :    2298
        Regenerable   :     131
        Spilled       :      76
        
    Routine stack
        Variables     :     208 bytes*
            Reads     :      52 [2.03e+00 ~ 0.6%]
            Writes    :      82 [1.25e+01 ~ 3.4%]
        Spills        :     536 bytes*
            Reads     :     274 [6.65e+00 ~ 1.8%]
            Writes    :     189 [6.22e+00 ~ 1.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateParams(z_streamp, int, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateParams(z_streamp, int, int)) [46/189=24.3%] deflate.c(572,1)
  -> (576,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (592,19) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
    -> (770,9) deflateStateCheck() (isz = 46) (sz = 55)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (787,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (831,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: (835,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: (836,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: (838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> (842,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (868,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (911,17) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (934,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (956,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (973,17) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (986,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (1000,34) deflate_stored() (isz = 676) (sz = 687)
      -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
        -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1786,9) read_buf() (isz = 46) (sz = 58)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1810,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (1001,50) deflate_huff() (isz = 11827) (sz = 11841)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (1002,41) deflate_rle() (isz = 6524) (sz = 6538)
      -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
        -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
        -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
        -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
        -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
          -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
        -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
          -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
        -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
        -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
           [[ Callee not marked with inlining pragma  <1>]]
        -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
      -> (2118,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> (2122,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INDIRECT: (1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.1615->level_V$3f))]
       [[ Callee not marked with inlining pragma  <1>]]
    -> (1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
      -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> (1038,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (1064,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: (1065,9) putShortMSB() (isz = 23) (sz = 30)
    -> (1067,5) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (601,17) slide_hash() (isz = 51) (sz = 56)
  -> INLINE (MANUAL): (603,17) memset(void *, int, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(904,13) inlined into deflate.c(592,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into deflate.c(592,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into deflate.c(592,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into deflate.c(592,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into deflate.c(592,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(592,19)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(592,19)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(592,19)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(592,19)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(592,19)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(592,19)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into deflate.c(592,19)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into deflate.c(592,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(592,19)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(592,19)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(592,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(592,19)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(592,19)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(592,19)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(592,19)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(592,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(592,19)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(592,19)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(592,19)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(592,19)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(592,19)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(592,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(592,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(592,19)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(592,19)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(592,19)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(592,19)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(592,19)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(592,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(592,19)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(592,19)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(592,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(592,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at deflate.c(600,13)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at deflate.c(600,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #25453: Loop Reversed
   remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
   remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 1.667
   remark #15301: REVERSED LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 8 
   remark #15477: vector cost: 1.500 
   remark #15478: estimated potential speedup: 4.370 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at deflate.c(600,13)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(601,17)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(601,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #25453: Loop Reversed
   remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
   remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 1.667
   remark #15301: REVERSED LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 8 
   remark #15477: vector cost: 1.500 
   remark #15478: estimated potential speedup: 4.370 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(601,17)
<Remainder loop for vectorization>
LOOP END


Non-optimizable loops:


LOOP BEGIN at deflate.c(2114,9) inlined into deflate.c(592,19)
   remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at trees.c(1143,5) inlined into deflate.c(592,19)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(572,1):remark #34051: REGISTER ALLOCATION : [deflateParams] deflate.c:572

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :    2939
            Global    :     718
            Local     :    2221
        Regenerable   :      72
        Spilled       :      78
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [9.18e-03 ~ 0.0%]
            Writes    :      48 [1.34e-01 ~ 0.2%]
        Spills        :     560 bytes*
            Reads     :     212 [9.42e-01 ~ 1.2%]
            Writes    :     157 [1.06e+00 ~ 1.4%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflate..1(z_streamp, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflate..1(z_streamp, int)) [47/189=24.9%] deflate.c(766,1)
  CLONED FROM: deflate(z_streamp, int)(X,4)
  -> (770,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (787,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (831,9) putShortMSB() (isz = 23) (sz = 30)
  -> INLINE: (835,13) putShortMSB() (isz = 23) (sz = 30)
  -> INLINE: (836,13) putShortMSB() (isz = 23) (sz = 30)
  -> INLINE: (838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> (842,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (868,13) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (911,17) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (934,21) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (956,21) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (973,17) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (986,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1000,34) deflate_stored() (isz = 676) (sz = 687)
    -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
      -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
      -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (1786,9) read_buf() (isz = 46) (sz = 58)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (1810,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (1001,50) deflate_huff() (isz = 11827) (sz = 11841)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (1002,41) deflate_rle() (isz = 6524) (sz = 6538)
    -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
      -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
      -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
        -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
      -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
      -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
      -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
      -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
        -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
        -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
        -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
      -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
      -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
        -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
        -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
      -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
      -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
         [[ Callee not marked with inlining pragma  <1>]]
      -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
    -> (2118,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> (2122,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT: (1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.3681->level_V$3f))]
     [[ Callee not marked with inlining pragma  <1>]]
  -> (1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
    -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
  -> (1038,13) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1064,9) putShortMSB() (isz = 23) (sz = 30)
  -> INLINE: (1065,9) putShortMSB() (isz = 23) (sz = 30)
  -> (1067,5) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(904,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into deflate.c(1000,34)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into deflate.c(1002,41)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1002,41)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1002,41)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1002,41)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1002,41)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1002,41)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1002,41)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into deflate.c(1002,41)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1002,41)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1002,41)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1002,41)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(1002,41)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1002,41)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1002,41)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(1002,41)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(1002,41)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at deflate.c(2114,9) inlined into deflate.c(1002,41)
   remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at trees.c(1143,5) inlined into deflate.c(1002,41)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(766,1):remark #34051: REGISTER ALLOCATION : [deflate..1] deflate.c:766

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :    2873
            Global    :     692
            Local     :    2181
        Regenerable   :      76
        Spilled       :      70
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [1.28e-01 ~ 0.0%]
            Writes    :      48 [1.87e+00 ~ 0.5%]
        Spills        :     520 bytes*
            Reads     :     162 [9.99e+00 ~ 2.6%]
            Writes    :     125 [1.25e+01 ~ 3.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: test_flush()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (test_flush()) [48/189=25.4%] test/example.c(378,1)
  -> EXTERN: (381,22) strlen(const char *)
  -> (387,11) deflateInit_(z_streamp, int, const char *, int) (isz = 5) (sz = 18)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (388,5) exit(int)
  -> INLINE: (388,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> INLINE: (394,11) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
    -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
      -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
        -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1786,9) read_buf() (isz = 46) (sz = 58)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1810,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
      -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
        -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
        -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
        -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
        -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
          -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
        -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
          -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
        -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
        -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
           [[ Callee not marked with inlining pragma  <1>]]
        -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
      -> (2118,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> (2122,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.1439->level_V$3f))]
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
      -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
    -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (395,5) exit(int)
  -> INLINE: (395,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> CP_CLONE (400,11) deflate..1(z_streamp, int) (isz = 9099) (sz = 9125)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> EXTERN: (402,9) exit(int)
  -> INLINE: (402,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> (404,11) deflateEnd(z_streamp) (isz = 63) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (405,5) exit(int)
  -> INLINE: (405,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(904,13) inlined into test/example.c(394,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into test/example.c(394,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into test/example.c(394,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into test/example.c(394,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into test/example.c(394,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(394,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(394,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(394,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(394,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(394,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(394,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into test/example.c(394,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into test/example.c(394,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(394,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(394,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(394,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(394,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(394,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(394,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(394,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(394,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(394,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into test/example.c(394,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into test/example.c(394,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into test/example.c(394,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into test/example.c(394,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into test/example.c(394,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(394,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(394,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(394,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(394,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(394,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(394,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(394,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(394,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(394,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into test/example.c(394,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into test/example.c(394,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into test/example.c(394,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into test/example.c(394,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into test/example.c(394,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(394,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(394,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(394,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(394,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(394,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(394,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(394,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(394,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(394,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into test/example.c(394,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into test/example.c(394,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into test/example.c(394,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into test/example.c(394,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into test/example.c(394,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into test/example.c(394,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(394,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(394,11)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into test/example.c(394,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(394,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(394,11)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into test/example.c(394,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into test/example.c(394,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at deflate.c(2114,9) inlined into test/example.c(394,11)
   remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at trees.c(1143,5) inlined into test/example.c(394,11)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
test/example.c(378,1):remark #34051: REGISTER ALLOCATION : [test_flush] test/example.c:378

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :    3019
            Global    :     738
            Local     :    2281
        Regenerable   :     107
        Spilled       :      74
        
    Routine stack
        Variables     :     208 bytes*
            Reads     :      40 [2.58e+00 ~ 0.8%]
            Writes    :      78 [9.38e+00 ~ 2.7%]
        Spills        :     520 bytes*
            Reads     :     267 [6.42e+00 ~ 1.9%]
            Writes    :     183 [6.08e+00 ~ 1.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: test_sync()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (test_sync()) [49/189=25.9%] test/example.c(416,1)
  -> INLINE (MANUAL): (420,5) strcpy(char *__restrict__, const char *__restrict__) (isz = 6) (sz = 15)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(90,10) __builtin___strcpy_chk(char *, const char *, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(90,49) __builtin_object_size(const void *, int)
  -> (429,11) inflateInit_(z_streamp, const char *, int) (isz = 2) (sz = 13)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (430,5) exit(int)
  -> INLINE: (430,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> INLINE: (435,11) inflate(z_streamp, int) (isz = 5502) (sz = 5516)
    -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
    -> INLINE: inflate.c:(667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: inflate.c:(769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
    -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
    -> INLINE: inflate.c:(1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
       [[ Callee not marked with inlining pragma  <1>]]
    -> inflate.c:(1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (436,5) exit(int)
  -> INLINE: (436,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> INLINE: (439,11) inflateSync(z_streamp) (isz = 196) (sz = 206)
    -> INLINE: inflate.c:(1409,9) inflateStateCheck() (isz = 25) (sz = 34)
    -> INLINE: inflate.c:(1425,9) syncsearch() (isz = 32) (sz = 43)
    -> INLINE: inflate.c:(1429,11) syncsearch() (isz = 32) (sz = 43)
    -> inflate.c:(1437,5) inflateReset() (isz = 40) (sz = 48)
       [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (440,5) exit(int)
  -> INLINE: (440,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> CP_CLONE (442,11) inflate..0(z_streamp, int) (isz = 5502) (sz = 5516)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (444,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (446,9) exit(int)
  -> (448,11) inflateEnd(z_streamp) (isz = 48) (sz = 56)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (449,5) exit(int)
  -> INLINE: (449,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> INLINE: (451,5) printf(const char *__restrict__, ...) (isz = 5) (sz = 12)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,10) __printf_chk(int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,56) __builtin_va_arg_pack(void)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inflate.c(1223,17) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into test/example.c(435,11)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into test/example.c(435,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into test/example.c(435,11)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into test/example.c(435,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 8  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into test/example.c(435,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into test/example.c(435,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into test/example.c(435,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into test/example.c(435,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into test/example.c(435,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between out (205:34) and out (205:34)
   remark #17106: parallel dependence: assumed FLOW dependence between out (205:34) and out (205:34)
   remark #15389: vectorization support: reference *out has unaligned access   [ inffast.c(205,34) ]
   remark #15389: vectorization support: reference *from has unaligned access   [ inffast.c(205,43) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.750
   remark #15300: LOOP WAS VECTORIZED
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 4.000 
   remark #15478: estimated potential speedup: 1.230 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into test/example.c(435,11)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into test/example.c(435,11)
   remark #25399: memcopy generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between *out (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed OUTPUT dependence between *out (216:34) and *out (213:25)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at inffast.c(213,25) inlined into test/example.c(435,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15389: vectorization support: reference *out has unaligned access   [ inffast.c(216,34) ]
      remark #15389: vectorization support: reference *from has unaligned access   [ inffast.c(216,43) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 16
      remark #15309: vectorization support: normalized vectorization overhead 1.222
      remark #15300: LOOP WAS VECTORIZED
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 0.560 
      remark #15478: estimated potential speedup: 5.900 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=6
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into test/example.c(435,11)
   <Remainder loop for vectorization>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      remark #25015: Estimate of max trip count of loop=96
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into test/example.c(435,11)
   remark #25399: memcopy generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between *out (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed OUTPUT dependence between *out (223:38) and *out (219:29)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at inffast.c(219,29) inlined into test/example.c(435,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15389: vectorization support: reference *out has unaligned access   [ inffast.c(223,38) ]
      remark #15389: vectorization support: reference *from has unaligned access   [ inffast.c(223,47) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 16
      remark #15309: vectorization support: normalized vectorization overhead 1.222
      remark #15300: LOOP WAS VECTORIZED
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 0.560 
      remark #15478: estimated potential speedup: 5.900 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=6
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into test/example.c(435,11)
   <Remainder loop for vectorization>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      remark #25015: Estimate of max trip count of loop=96
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between out (234:34) and out (234:34)
   remark #17106: parallel dependence: assumed FLOW dependence between out (234:34) and out (234:34)
   remark #15389: vectorization support: reference *out has unaligned access   [ inffast.c(234,34) ]
   remark #15389: vectorization support: reference *from has unaligned access   [ inffast.c(234,43) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.750
   remark #15300: LOOP WAS VECTORIZED
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 4.000 
   remark #15478: estimated potential speedup: 1.230 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into test/example.c(435,11)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into test/example.c(435,11)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into test/example.c(435,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into test/example.c(435,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into test/example.c(435,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into test/example.c(435,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into test/example.c(435,11)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into test/example.c(435,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference d_stream.state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into test/example.c(435,11)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into test/example.c(435,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(435,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(435,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(435,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into test/example.c(435,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into test/example.c(435,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into test/example.c(435,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into test/example.c(435,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into test/example.c(435,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(435,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(435,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(435,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into test/example.c(435,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into test/example.c(435,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into test/example.c(435,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into test/example.c(435,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into test/example.c(435,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between d_stream.state->lens[order[state->have]] (945:17) and d_stream.state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between d_stream.state->lens[order[state->have]] (945:17) and d_stream.state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <d_stream.state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into test/example.c(435,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into test/example.c(435,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(435,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
   remark #25015: Estimate of max trip count of loop=15
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into test/example.c(435,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into test/example.c(435,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into test/example.c(435,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into test/example.c(435,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into test/example.c(435,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into test/example.c(435,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into test/example.c(435,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1419,9) inlined into test/example.c(439,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1421,13) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1422,13) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between d_stream.state->hold (1420:13) and d_stream.state->hold (1421:13)
   remark #17106: parallel dependence: assumed FLOW dependence between d_stream.state->hold (1421:13) and d_stream.state->hold (1420:13)
   remark #17106: parallel dependence: assumed FLOW dependence between d_stream.state->hold (1421:13) and d_stream.state->hold (1420:13)
   remark #17106: parallel dependence: assumed ANTI dependence between d_stream.state->hold (1420:13) and d_stream.state->hold (1421:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between d_stream.state->hold (1420:13) and d_stream.state->hold (1421:13)
   remark #15346: vector dependence: assumed FLOW dependence between d_stream.state->hold (1421:13) and d_stream.state->hold (1420:13)
   remark #15346: vector dependence: assumed FLOW dependence between d_stream.state->hold (1421:13) and d_stream.state->hold (1420:13)
   remark #15346: vector dependence: assumed ANTI dependence between d_stream.state->hold (1420:13) and d_stream.state->hold (1421:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
   remark #25457: Number of partial sums replaced: 1
   remark #25015: Estimate of max trip count of loop=4
LOOP END

LOOP BEGIN at inflate.c(1419,9) inlined into test/example.c(439,11)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=4
LOOP END

LOOP BEGIN at inflate.c(1387,5) inlined into test/example.c(439,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1389:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1389:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1389:13)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1391:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1391:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1391:13)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1393:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1393:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1393:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inflate.c(1388,9) ]
   remark #25015: Estimate of max trip count of loop=4
LOOP END

LOOP BEGIN at inflate.c(1387,5) inlined into test/example.c(439,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1389:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1389:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1389:13)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1391:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1391:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1391:13)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1393:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1393:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1393:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inflate.c(1394,9) ]
LOOP END


Non-optimizable loops:


LOOP BEGIN at inflate.c(1226,21) inlined into test/example.c(435,11)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at inflate.c(1107,17) inlined into test/example.c(435,11)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inffast.c(290,19) inlined into test/example.c(435,11)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inffast.c(277,20) inlined into test/example.c(435,11)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END

   LOOP BEGIN at inflate.c(1057,17) inlined into test/example.c(435,11)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inflate.c(960,13) inlined into test/example.c(435,11)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inftrees.c(132,5) inlined into test/example.c(435,11)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inftrees.c(132,5) inlined into test/example.c(435,11)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inflate.c(939,13) inlined into test/example.c(435,11)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inftrees.c(132,5) inlined into test/example.c(435,11)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(90,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
test/example.c(416,1):remark #34051: REGISTER ALLOCATION : [test_sync] test/example.c:416

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1739
            Global    :     411
            Local     :    1328
        Regenerable   :     107
        Spilled       :     101
        
    Routine stack
        Variables     :     332 bytes*
            Reads     :     152 [1.20e+01 ~ 3.3%]
            Writes    :     225 [1.78e+01 ~ 4.9%]
        Spills        :     752 bytes*
            Reads     :     530 [3.69e+00 ~ 1.0%]
            Writes    :     172 [6.97e+00 ~ 1.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflate..0(z_streamp, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflate..0(z_streamp, int)) [50/189=26.5%] inflate.c(625,1)
  CLONED FROM: inflate(z_streamp, int)(X,4)
  -> INLINE: (645,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> INLINE: (667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> INLINE: (722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> INLINE: (867,17) fixedtables() (isz = 10) (sz = 15)
  -> INLINE (MANUAL): (909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
  -> INLINE: (1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
  -> INLINE: (1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
  -> INLINE: (1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
  -> INLINE: (1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> INLINE: (1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (1257,13) updatewindow() (isz = 101) (sz = 113)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inflate.c(1223,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into inflate.c(1205,25)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into inflate.c(1205,25)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into inflate.c(1205,25)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into inflate.c(1205,25)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into inflate.c(1205,25)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into inflate.c(1205,25)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into inflate.c(1047,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into inflate.c(1047,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into inflate.c(1047,17)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into inflate.c(1047,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into inflate.c(1047,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into inflate.c(1047,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into inflate.c(1047,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into inflate.c(1047,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into inflate.c(1047,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into inflate.c(1047,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into inflate.c(1047,17)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into inflate.c(1047,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into inflate.c(1047,17)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into inflate.c(1047,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into inflate.c(1023,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into inflate.c(1023,19)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into inflate.c(1023,19)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into inflate.c(1023,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into inflate.c(1023,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into inflate.c(1023,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into inflate.c(1023,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into inflate.c(1023,19)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into inflate.c(1023,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into inflate.c(1023,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into inflate.c(1023,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into inflate.c(1023,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into inflate.c(1032,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into inflate.c(1032,19)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into inflate.c(1032,19)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into inflate.c(1032,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into inflate.c(1032,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into inflate.c(1032,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into inflate.c(1032,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into inflate.c(1032,19)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into inflate.c(1032,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into inflate.c(1032,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into inflate.c(1032,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into inflate.c(1032,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into inflate.c(949,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into inflate.c(949,19)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into inflate.c(949,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
   remark #25015: Estimate of max trip count of loop=15
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into inflate.c(949,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into inflate.c(949,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into inflate.c(949,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into inflate.c(949,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into inflate.c(949,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into inflate.c(949,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into inflate.c(949,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at inflate.c(1226,21)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at inflate.c(1107,17)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inffast.c(290,19) inlined into inflate.c(1047,17)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inffast.c(277,20) inlined into inflate.c(1047,17)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END

   LOOP BEGIN at inflate.c(1057,17)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inflate.c(960,13)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inftrees.c(132,5) inlined into inflate.c(1023,19)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inftrees.c(132,5) inlined into inflate.c(1032,19)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inflate.c(939,13)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inftrees.c(132,5) inlined into inflate.c(949,19)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(625,1):remark #34051: REGISTER ALLOCATION : [inflate..0] inflate.c:625

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1604
            Global    :     377
            Local     :    1227
        Regenerable   :      66
        Spilled       :      99
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :     131 [2.94e+00 ~ 1.1%]
            Writes    :     159 [4.04e+00 ~ 1.5%]
        Spills        :     712 bytes*
            Reads     :     481 [4.05e+00 ~ 1.5%]
            Writes    :     161 [6.17e+00 ~ 2.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: test_dict_deflate()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (test_dict_deflate()) [51/189=27.0%] test/example.c(460,1)
  -> (468,11) deflateInit_(z_streamp, int, const char *, int) (isz = 5) (sz = 18)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (469,5) exit(int)
  -> INLINE: (469,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> INLINE: (471,11) deflateSetDictionary(z_streamp, const Bytef *, uInt) (isz = 784) (sz = 797)
    -> deflate.c:(387,9) deflateStateCheck() (isz = 46) (sz = 55)
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(396,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): deflate.c:(402,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(416,5) fill_window() (isz = 308) (sz = 313)
      -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
      -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
        -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(430,9) fill_window() (isz = 308) (sz = 313)
      -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
      -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
        -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
  -> EXTERN: (473,5) exit(int)
  -> INLINE: (473,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (480,31) strlen(const char *)
  -> INLINE: (482,11) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
    -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
      -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
        -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1786,9) read_buf() (isz = 46) (sz = 58)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1810,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
      -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
        -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
        -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
        -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
        -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
          -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
        -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
          -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
        -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
        -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
           [[ Callee not marked with inlining pragma  <1>]]
        -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
      -> (2118,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> (2122,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.1527->level_V$3f))]
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
      -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
    -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (484,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (485,9) exit(int)
  -> (487,11) deflateEnd(z_streamp) (isz = 63) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (488,5) exit(int)
  -> INLINE: (488,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(1492,67) inlined into test/example.c(471,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(471,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(471,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(471,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(471,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(471,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(471,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into test/example.c(471,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and c_stream.state->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between c_stream.state->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(417,5) inlined into test/example.c(471,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(423,40) inlined into test/example.c(471,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at deflate.c(1487,18) inlined into test/example.c(471,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(471,11)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=7
      LOOP END

      LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(471,11)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #25453: Loop Reversed
         remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
         remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 1.667
         remark #15301: REVERSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 8 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 4.370 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(471,11)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(471,11)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=7
      LOOP END

      LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(471,11)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #25453: Loop Reversed
         remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
         remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 1.667
         remark #15301: REVERSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 8 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 4.370 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(471,11)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at deflate.c(1545,13) inlined into test/example.c(471,11)
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and c_stream.state->insert (1552:17)
         remark #17106: parallel dependence: assumed FLOW dependence between c_stream.state->insert (1552:17) and s->window[str+2] (1546:17)
         remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into test/example.c(482,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into test/example.c(482,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into test/example.c(482,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into test/example.c(482,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into test/example.c(482,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(482,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(482,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into test/example.c(482,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(482,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(482,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into test/example.c(482,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into test/example.c(482,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into test/example.c(482,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(482,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(482,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(482,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(482,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(482,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(482,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(482,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(482,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(482,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into test/example.c(482,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into test/example.c(482,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into test/example.c(482,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into test/example.c(482,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into test/example.c(482,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(482,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(482,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(482,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(482,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(482,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(482,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(482,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(482,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(482,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into test/example.c(482,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into test/example.c(482,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into test/example.c(482,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into test/example.c(482,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into test/example.c(482,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(482,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into test/example.c(482,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(482,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(482,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(482,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into test/example.c(482,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(482,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(482,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into test/example.c(482,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into test/example.c(482,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into test/example.c(482,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into test/example.c(482,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into test/example.c(482,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into test/example.c(482,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into test/example.c(482,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(482,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(482,11)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into test/example.c(482,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(482,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into test/example.c(482,11)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into test/example.c(482,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into test/example.c(482,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at deflate.c(2114,9) inlined into test/example.c(482,11)
   remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at trees.c(1143,5) inlined into test/example.c(482,11)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
test/example.c(460,1):remark #34051: REGISTER ALLOCATION : [test_dict_deflate] test/example.c:460

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :    3563
            Global    :     879
            Local     :    2684
        Regenerable   :     107
        Spilled       :      98
        
    Routine stack
        Variables     :     208 bytes*
            Reads     :      53 [2.90e+00 ~ 0.3%]
            Writes    :      81 [6.67e+00 ~ 0.8%]
        Spills        :     728 bytes*
            Reads     :     306 [2.09e+01 ~ 2.4%]
            Writes    :     203 [1.50e+01 ~ 1.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: test_dict_inflate()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (test_dict_inflate()) [52/189=27.5%] test/example.c(497,1)
  -> INLINE (MANUAL): (501,5) strcpy(char *__restrict__, const char *__restrict__) (isz = 6) (sz = 15)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(90,10) __builtin___strcpy_chk(char *, const char *, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(90,49) __builtin_object_size(const void *, int)
  -> (510,11) inflateInit_(z_streamp, const char *, int) (isz = 2) (sz = 13)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (511,5) exit(int)
  -> INLINE: (511,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> INLINE: (517,15) inflate(z_streamp, int) (isz = 5502) (sz = 5516)
    -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
    -> INLINE: inflate.c:(667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: inflate.c:(769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
    -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
    -> INLINE: inflate.c:(1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
       [[ Callee not marked with inlining pragma  <1>]]
    -> inflate.c:(1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (521,17) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (522,17) exit(int)
  -> INLINE: (524,19) inflateSetDictionary(z_streamp, const Bytef *, uInt) (isz = 410) (sz = 425)
    -> INLINE: inflate.c:(1324,9) inflateStateCheck() (isz = 25) (sz = 34)
    -> INLINE: inflate.c:(1331,18) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> inflate.c:(1332,18) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
       [[ Callee not marked with inlining pragma  <1>]]
    -> inflate.c:(1339,11) updatewindow() (isz = 101) (sz = 113)
       [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (527,9) exit(int)
  -> INLINE: (527,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> (530,11) inflateEnd(z_streamp) (isz = 48) (sz = 56)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (531,5) exit(int)
  -> INLINE: (531,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (533,9) strcmp(const char *, const char *)
  -> INLINE: (534,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (535,9) exit(int)
  -> INLINE: (537,9) printf(const char *__restrict__, ...) (isz = 5) (sz = 12)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,10) __printf_chk(int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,56) __builtin_va_arg_pack(void)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inflate.c(1223,17) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into test/example.c(517,15)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into test/example.c(517,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into test/example.c(517,15)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into test/example.c(517,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 8  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into test/example.c(517,15)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into test/example.c(517,15)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into test/example.c(517,15)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into test/example.c(517,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into test/example.c(517,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into test/example.c(517,15)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into test/example.c(517,15)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into test/example.c(517,15)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into test/example.c(517,15)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into test/example.c(517,15)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into test/example.c(517,15)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into test/example.c(517,15)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into test/example.c(517,15)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into test/example.c(517,15)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into test/example.c(517,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into test/example.c(517,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into test/example.c(517,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into test/example.c(517,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into test/example.c(517,15)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into test/example.c(517,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference d_stream.state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into test/example.c(517,15)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into test/example.c(517,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(517,15)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(517,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(517,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into test/example.c(517,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into test/example.c(517,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into test/example.c(517,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into test/example.c(517,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into test/example.c(517,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(517,15)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(517,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(517,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into test/example.c(517,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into test/example.c(517,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into test/example.c(517,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into test/example.c(517,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into test/example.c(517,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between d_stream.state->lens[order[state->have]] (945:17) and d_stream.state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between d_stream.state->lens[order[state->have]] (945:17) and d_stream.state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <d_stream.state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into test/example.c(517,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into test/example.c(517,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(517,15)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into test/example.c(517,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into test/example.c(517,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into test/example.c(517,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into test/example.c(517,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into test/example.c(517,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into test/example.c(517,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into test/example.c(517,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at test/example.c(527,9)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at inflate.c(1226,21) inlined into test/example.c(517,15)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1107,17) inlined into test/example.c(517,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inffast.c(290,19) inlined into test/example.c(517,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inffast.c(277,20) inlined into test/example.c(517,15)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END

      LOOP BEGIN at inflate.c(1057,17) inlined into test/example.c(517,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inflate.c(960,13) inlined into test/example.c(517,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into test/example.c(517,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into test/example.c(517,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inflate.c(939,13) inlined into test/example.c(517,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into test/example.c(517,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(90,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
test/example.c(497,1):remark #34051: REGISTER ALLOCATION : [test_dict_inflate] test/example.c:497

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1719
            Global    :     391
            Local     :    1328
        Regenerable   :     111
        Spilled       :      96
        
    Routine stack
        Variables     :     328 bytes*
            Reads     :     150 [2.27e+01 ~ 3.5%]
            Writes    :     216 [2.40e+01 ~ 3.7%]
        Spills        :     704 bytes*
            Reads     :     448 [9.70e+00 ~ 1.5%]
            Writes    :     154 [1.73e+01 ~ 2.6%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: zlibVersion(void)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (zlibVersion(void)) [53/189=28.0%] zutil.c(28,1)


    Report from: Code generation optimizations [cg]

zutil.c(28,1):remark #34051: REGISTER ALLOCATION : [zlibVersion] zutil.c:28

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rax]
        
    Routine temporaries
        Total         :       8
            Global    :       0
            Local     :       8
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflate(z_streamp, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflate(z_streamp, int)) [54/189=28.6%] deflate.c(766,1)
  -> (770,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (787,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (831,9) putShortMSB() (isz = 23) (sz = 30)
  -> INLINE: (835,13) putShortMSB() (isz = 23) (sz = 30)
  -> INLINE: (836,13) putShortMSB() (isz = 23) (sz = 30)
  -> INLINE: (838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> (842,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (868,13) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (911,17) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (934,21) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (956,21) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (973,17) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (986,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1000,34) deflate_stored() (isz = 676) (sz = 687)
    -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
      -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
      -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (1786,9) read_buf() (isz = 46) (sz = 58)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (1810,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (1001,50) deflate_huff() (isz = 11827) (sz = 11841)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (1002,41) deflate_rle() (isz = 6524) (sz = 6538)
    -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
      -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
      -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
        -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
      -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
      -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
      -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
      -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
        -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
        -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
        -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
      -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
      -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
        -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
        -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
      -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
      -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
         [[ Callee not marked with inlining pragma  <1>]]
      -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> (2118,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (2122,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
       [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INDIRECT: (1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64->level_V$3f))]
     [[ Callee not marked with inlining pragma  <1>]]
  -> (1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
    -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
  -> (1038,13) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1064,9) putShortMSB() (isz = 23) (sz = 30)
  -> INLINE: (1065,9) putShortMSB() (isz = 23) (sz = 30)
  -> (1067,5) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(904,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into deflate.c(1000,34)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into deflate.c(1002,41)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1002,41)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1002,41)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1002,41)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1002,41)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1002,41)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1002,41)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into deflate.c(1002,41)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1002,41)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1002,41)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1002,41)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1002,41)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1002,41)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1002,41)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1002,41)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(1002,41)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1002,41)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(1002,41)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1002,41)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1002,41)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(1002,41)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(1002,41)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at deflate.c(2114,9) inlined into deflate.c(1002,41)
   remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at trees.c(1143,5) inlined into deflate.c(1002,41)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(766,1):remark #34051: REGISTER ALLOCATION : [deflate] deflate.c:766

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :    2915
            Global    :     699
            Local     :    2216
        Regenerable   :      82
        Spilled       :      74
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [1.28e-01 ~ 0.0%]
            Writes    :      48 [1.87e+00 ~ 0.5%]
        Spills        :     520 bytes*
            Reads     :     176 [1.01e+01 ~ 2.6%]
            Writes    :     124 [1.25e+01 ~ 3.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflate(z_streamp, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflate(z_streamp, int)) [55/189=29.1%] inflate.c(625,1)
  -> INLINE: (645,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> INLINE: (667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> INLINE: (722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> INLINE: (867,17) fixedtables() (isz = 10) (sz = 15)
  -> INLINE (MANUAL): (909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
  -> INLINE: (1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
  -> INLINE: (1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
  -> INLINE: (1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
  -> INLINE: (1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> (1257,13) updatewindow() (isz = 101) (sz = 113)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
    -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inflate.c(1223,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into inflate.c(1205,25)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into inflate.c(1205,25)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into inflate.c(1205,25)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into inflate.c(1205,25)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into inflate.c(1205,25)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into inflate.c(1205,25)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into inflate.c(1047,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into inflate.c(1047,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into inflate.c(1047,17)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into inflate.c(1047,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into inflate.c(1047,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into inflate.c(1047,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into inflate.c(1047,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into inflate.c(1047,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into inflate.c(1047,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into inflate.c(1047,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into inflate.c(1047,17)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into inflate.c(1047,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into inflate.c(1047,17)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into inflate.c(1047,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into inflate.c(1023,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into inflate.c(1023,19)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into inflate.c(1023,19)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into inflate.c(1023,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into inflate.c(1023,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into inflate.c(1023,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into inflate.c(1023,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into inflate.c(1023,19)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into inflate.c(1023,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into inflate.c(1023,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into inflate.c(1023,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into inflate.c(1023,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into inflate.c(1032,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into inflate.c(1032,19)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into inflate.c(1032,19)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into inflate.c(1032,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into inflate.c(1032,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into inflate.c(1032,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into inflate.c(1032,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into inflate.c(1032,19)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into inflate.c(1032,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into inflate.c(1032,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into inflate.c(1032,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into inflate.c(1032,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into inflate.c(949,19)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into inflate.c(949,19)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into inflate.c(949,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
   remark #25015: Estimate of max trip count of loop=15
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into inflate.c(949,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into inflate.c(949,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into inflate.c(949,19)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into inflate.c(949,19)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into inflate.c(949,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into inflate.c(949,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into inflate.c(949,19)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at inflate.c(1226,21)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at inflate.c(1107,17)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inffast.c(290,19) inlined into inflate.c(1047,17)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inffast.c(277,20) inlined into inflate.c(1047,17)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END

   LOOP BEGIN at inflate.c(1057,17)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inflate.c(960,13)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inftrees.c(132,5) inlined into inflate.c(1023,19)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inftrees.c(132,5) inlined into inflate.c(1032,19)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inflate.c(939,13)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END

   LOOP BEGIN at inftrees.c(132,5) inlined into inflate.c(949,19)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(625,1):remark #34051: REGISTER ALLOCATION : [inflate] inflate.c:625

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1605
            Global    :     380
            Local     :    1225
        Regenerable   :      66
        Spilled       :      98
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :     131 [2.94e+00 ~ 1.1%]
            Writes    :     159 [4.04e+00 ~ 1.4%]
        Spills        :     720 bytes*
            Reads     :     546 [4.77e+00 ~ 1.7%]
            Writes    :     170 [7.62e+00 ~ 2.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateSetDictionary(z_streamp, const Bytef *, uInt)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateSetDictionary(z_streamp, const Bytef *, uInt)) [56/189=29.6%] deflate.c(380,1)
  -> (387,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (396,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (402,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
  -> INLINE: (416,5) fill_window() (isz = 308) (sz = 313)
    -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
    -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
      -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
  -> INLINE: (430,9) fill_window() (isz = 308) (sz = 313)
    -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
    -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
      -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(1492,67) inlined into deflate.c(416,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(416,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(416,5)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(416,5)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(416,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(416,5)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(416,5)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into deflate.c(416,5)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(417,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(423,40)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at deflate.c(1487,18) inlined into deflate.c(430,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(430,9)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=7
      LOOP END

      LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(430,9)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #25453: Loop Reversed
         remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
         remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 1.667
         remark #15301: REVERSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 8 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 4.370 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(430,9)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(430,9)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=7
      LOOP END

      LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(430,9)
         remark #17108: loop was not parallelized: insufficient computational work
         remark #25453: Loop Reversed
         remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
         remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 1.667
         remark #15301: REVERSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 8 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 4.370 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(430,9)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at deflate.c(1545,13) inlined into deflate.c(430,9)
         remark #17104: loop was not parallelized: existence of parallel dependence
         remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
         remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
         remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
deflate.c(380,1):remark #34051: REGISTER ALLOCATION : [deflateSetDictionary] deflate.c:380

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :     479
            Global    :     133
            Local     :     346
        Regenerable   :      13
        Spilled       :      23
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :     136 bytes*
            Reads     :      34 [1.73e+01 ~ 2.5%]
            Writes    :      21 [1.39e+01 ~ 2.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateSetDictionary(z_streamp, const Bytef *, uInt)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateSetDictionary(z_streamp, const Bytef *, uInt)) [57/189=30.2%] inflate.c(1318,1)
  -> INLINE: (1324,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> INLINE: (1331,18) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
    -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
  -> (1332,18) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (1339,11) updatewindow() (isz = 101) (sz = 113)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

inflate.c(1318,1):remark #34051: REGISTER ALLOCATION : [inflateSetDictionary] inflate.c:1318

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rbx rbp rsi rdi r12-r13]
        
    Routine temporaries
        Total         :      31
            Global    :      15
            Local     :      16
        Regenerable   :       4
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateSync(z_streamp)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateSync(z_streamp)) [58/189=30.7%] inflate.c(1402,1)
  -> INLINE: (1409,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> INLINE: (1425,9) syncsearch() (isz = 32) (sz = 43)
  -> INLINE: (1429,11) syncsearch() (isz = 32) (sz = 43)
  -> (1437,5) inflateReset() (isz = 40) (sz = 48)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inflate.c(1419,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1421,13) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1422,13) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between state->hold (1420:13) and state->hold (1421:13)
   remark #17106: parallel dependence: assumed FLOW dependence between state->hold (1421:13) and state->hold (1420:13)
   remark #17106: parallel dependence: assumed FLOW dependence between state->hold (1421:13) and state->hold (1420:13)
   remark #17106: parallel dependence: assumed ANTI dependence between state->hold (1420:13) and state->hold (1421:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between state->hold (1420:13) and state->hold (1421:13)
   remark #15346: vector dependence: assumed FLOW dependence between state->hold (1421:13) and state->hold (1420:13)
   remark #15346: vector dependence: assumed FLOW dependence between state->hold (1421:13) and state->hold (1420:13)
   remark #15346: vector dependence: assumed ANTI dependence between state->hold (1420:13) and state->hold (1421:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
   remark #25457: Number of partial sums replaced: 1
   remark #25015: Estimate of max trip count of loop=4
LOOP END

LOOP BEGIN at inflate.c(1419,9)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=4
LOOP END

LOOP BEGIN at inflate.c(1387,5) inlined into inflate.c(1425,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1389:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1389:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1389:13)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1391:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1391:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1391:13)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1393:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1393:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1393:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inflate.c(1388,9) ]
   remark #25015: Estimate of max trip count of loop=4
LOOP END

LOOP BEGIN at inflate.c(1387,5) inlined into inflate.c(1429,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1389:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1389:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1389:13)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1391:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1391:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1391:13)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1393:13)
   remark #17106: parallel dependence: assumed FLOW dependence between got (1393:13) and got (1387:5)
   remark #17106: parallel dependence: assumed ANTI dependence between got (1387:5) and got (1393:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inflate.c(1394,9) ]
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1402,1):remark #34051: REGISTER ALLOCATION : [inflateSync] inflate.c:1402

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   13[ rax rdx rcx rbx rbp rsi rdi r8-r11 r14-r15]
        
    Routine temporaries
        Total         :      63
            Global    :      32
            Local     :      31
        Regenerable   :       5
        Spilled       :       4
        
    Routine stack
        Variables     :       4 bytes*
            Reads     :       1 [6.48e-01 ~ 0.6%]
            Writes    :       3 [1.83e+00 ~ 1.7%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzputs(gzFile, const char *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzputs(gzFile, const char *)) [59/189=31.2%] gzwrite.c(355,1)
  -> EXTERN: (370,11) strlen(const char *)
  -> INLINE: (371,11) gz_write() (isz = 9388) (sz = 9405)
    -> (190,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (196,13) gz_zero() (isz = 9326) (sz = 9337)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE (MANUAL): (213,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> CP_CLONE (218,24) gz_comp..0() (isz = 9270) (sz = 9284)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (224,37) gz_comp() (isz = 9270) (sz = 9284)
      -> (82,29) gz_init() (isz = 92) (sz = 102)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (89,20) write(int, const void *, size_t)
      -> CP_CLONE (91,17) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (91,42) strerror(int)
      -> EXTERN: (91,42) __errno_location(void)
      -> EXTERN: (110,24) write(int, const void *, size_t)
      -> CP_CLONE (112,21) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (112,46) strerror(int)
      -> EXTERN: (112,46) __errno_location(void)
      -> INLINE: (126,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
        -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
          -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
            -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1786,9) read_buf() (isz = 46) (sz = 58)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1810,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
          -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
            -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
            -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
              -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
              -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
                 [[ Callee not marked with inlining pragma  <1>]]
              -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
                -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                   [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
            -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
            -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
            -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
              -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
                -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
                -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                  -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
            -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
              -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
              -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
            -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
               [[ Callee not marked with inlining pragma  <1>]]
            -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
          -> (2118,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
          -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> (2122,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.2789->level_V$3f))]
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
        -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (128,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
        -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
           [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (235,17) gz_comp..0() (isz = 9270) (sz = 9284)
       [[ Inlining inhibited by overrideable criterion  <2>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(201,5) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(371,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(371,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(371,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(371,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(371,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(371,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(371,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(371,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(371,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(371,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(371,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(371,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(371,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(371,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(371,11)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(371,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(371,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(371,11)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at gzwrite.c(228,9) inlined into gzwrite.c(371,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(371,11)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(371,11)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(371,11)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(355,1):remark #34051: REGISTER ALLOCATION : [gzputs] gzwrite.c:355

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2904
            Global    :     724
            Local     :    2180
        Regenerable   :      73
        Spilled       :      75
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [4.56e-04 ~ 0.0%]
            Writes    :      48 [6.67e-03 ~ 0.0%]
        Spills        :     552 bytes*
            Reads     :     182 [3.92e-02 ~ 0.1%]
            Writes    :     127 [5.41e-02 ~ 0.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzputc(gzFile, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzputc(gzFile, int)) [60/189=31.7%] gzwrite.c(307,1)
  -> INLINE: (326,13) gz_zero() (isz = 9326) (sz = 9337)
    -> INLINE: (154,27) gz_comp() (isz = 9270) (sz = 9284)
      -> (82,29) gz_init() (isz = 92) (sz = 102)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (89,20) write(int, const void *, size_t)
      -> CP_CLONE (91,17) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (91,42) strerror(int)
      -> EXTERN: (91,42) __errno_location(void)
      -> EXTERN: (110,24) write(int, const void *, size_t)
      -> CP_CLONE (112,21) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (112,46) strerror(int)
      -> EXTERN: (112,46) __errno_location(void)
      -> INLINE: (126,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
        -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
          -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
            -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1786,9) read_buf() (isz = 46) (sz = 58)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1810,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
          -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
            -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
            -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
              -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
              -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
                 [[ Callee not marked with inlining pragma  <1>]]
              -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
                -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                   [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
            -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
            -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
            -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
              -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
                -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
                -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                  -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
            -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
              -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
              -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
            -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
               [[ Callee not marked with inlining pragma  <1>]]
            -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
          -> (2118,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
          -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> (2122,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.2511->level_V$3f))]
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
        -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (128,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
        -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
           [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (163,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> CP_CLONE (169,13) gz_comp..0() (isz = 9270) (sz = 9284)
       [[ Inlining inhibited by overrideable criterion  <2>]]
  -> CP_CLONE (346,9) gz_write..0() (isz = 9388) (sz = 9405)
     [[ Inlining inhibited by overrideable criterion  <2>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(326,13)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(326,13)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(326,13)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(326,13)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(326,13)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(326,13)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(326,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(326,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(326,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(326,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(326,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(326,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(326,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(326,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(326,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(326,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(326,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(326,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(326,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(326,13)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(326,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(326,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(326,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(326,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(326,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(326,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(326,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(326,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(326,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(326,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at gzwrite.c(159,5) inlined into gzwrite.c(326,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(326,13)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(326,13)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(326,13)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(307,1):remark #34051: REGISTER ALLOCATION : [gzputc] gzwrite.c:307

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2896
            Global    :     717
            Local     :    2179
        Regenerable   :      77
        Spilled       :      75
        
    Routine stack
        Variables     :      97 bytes*
            Reads     :       3 [2.43e-03 ~ 0.0%]
            Writes    :      49 [1.57e-01 ~ 0.3%]
        Spills        :     560 bytes*
            Reads     :     224 [4.08e-01 ~ 0.8%]
            Writes    :     166 [4.86e-01 ~ 1.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzgetc(gzFile)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzgetc(gzFile)) [61/189=32.3%] gzread.c(449,1)
  -> INLINE: (472,11) gz_read() (isz = 5842) (sz = 5858)
    -> (309,13) gz_skip() (isz = 6092) (sz = 6102)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE (MANUAL): (325,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (340,17) gz_fetch() (isz = 6046) (sz = 6058)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (349,17) gz_load() (isz = 42) (sz = 56)
      -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
      -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (41,34) strerror(int)
      -> EXTERN: (41,34) __errno_location(void)
    -> INLINE: (357,17) gz_decomp() (isz = 5691) (sz = 5702)
      -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
        -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
          -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
          -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
             [[ Callee not marked with inlining pragma  <1>]]
          -> EXTERN: (41,34) strerror(int)
          -> EXTERN: (41,34) __errno_location(void)
      -> CP_CLONE (189,13) gz_error..3(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (194,15) inflate(z_streamp, int) (isz = 5502) (sz = 5516)
        -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
        -> INLINE: inflate.c:(667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
        -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
        -> INLINE: inflate.c:(1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
           [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (196,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (201,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (205,13) gz_error..4(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(472,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(472,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(472,11)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(472,11)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(472,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(472,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(472,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(472,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(472,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(472,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(472,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(472,11)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(472,11)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(472,11)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(472,11)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(472,11)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(472,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(472,11)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(472,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(472,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(472,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(472,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(472,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(472,11)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(472,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(472,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(472,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(368,14) inlined into gzread.c(472,11)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(472,11)
      remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(472,11)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(472,11)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END

         LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(472,11)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(449,1):remark #34051: REGISTER ALLOCATION : [gzgetc] gzread.c:449

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1706
            Global    :     415
            Local     :    1291
        Regenerable   :      78
        Spilled       :     112
        
    Routine stack
        Variables     :     217 bytes*
            Reads     :     132 [1.43e-01 ~ 0.3%]
            Writes    :     159 [1.37e-01 ~ 0.3%]
        Spills        :     832 bytes*
            Reads     :     627 [5.86e-01 ~ 1.3%]
            Writes    :     314 [7.24e-01 ~ 1.6%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzungetc(int, gzFile)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzungetc(int, gzFile)) [62/189=32.8%] gzread.c(486,1)
  -> INLINE: (502,13) gz_skip() (isz = 6092) (sz = 6102)
    -> INLINE: (284,17) gz_fetch() (isz = 6046) (sz = 6058)
      -> INLINE: (237,17) gz_look() (isz = 249) (sz = 262)
        -> EXTERN: (99,38) malloc(size_t)
        -> EXTERN: (100,39) malloc(size_t)
        -> EXTERN: (102,13) free(void *)
        -> EXTERN: (103,13) free(void *)
        -> CP_CLONE (104,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (115,13) inflateInit2_..0() (isz = 58) (sz = 74)
           [[ Callee not marked with inlining pragma  <1>]]
        -> EXTERN: (116,13) free(void *)
        -> EXTERN: (117,13) free(void *)
        -> CP_CLONE (119,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (126,13) gz_avail() (isz = 103) (sz = 112)
          -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
            -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
            -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
               [[ Callee not marked with inlining pragma  <1>]]
            -> EXTERN: (41,34) __errno_location(void)
            -> EXTERN: (41,34) strerror(int)
        -> (141,9) inflateReset() (isz = 40) (sz = 48)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (161,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (243,17) gz_load() (isz = 42) (sz = 56)
        -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
        -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> EXTERN: (41,34) __errno_location(void)
        -> EXTERN: (41,34) strerror(int)
      -> INLINE: (251,17) gz_decomp() (isz = 5691) (sz = 5702)
        -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
          -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
            -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
            -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
               [[ Callee not marked with inlining pragma  <1>]]
            -> EXTERN: (41,34) __errno_location(void)
            -> EXTERN: (41,34) strerror(int)
        -> CP_CLONE (189,13) gz_error..3(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (194,15) inflate(z_streamp, int) (isz = 5502) (sz = 5516)
          -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
          -> INLINE: inflate.c:(667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
            -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
          -> INLINE: inflate.c:(722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: inflate.c:(769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
            -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
          -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
          -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
          -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
          -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
          -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
          -> INLINE: inflate.c:(1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
            -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
          -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: inflate.c:(1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
          -> inflate.c:(1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (196,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (201,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (205,13) gz_error..4(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
  -> CP_CLONE (522,9) gz_error..4(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(502,13)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(502,13)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(502,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(502,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(502,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(502,13)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(502,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(502,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(502,13)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(502,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(502,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(502,13)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(502,13)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(502,13)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(502,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(502,13)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(502,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(502,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(502,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(502,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(502,13)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(502,13)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(502,13)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(502,13)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(502,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(502,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(502,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(502,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(530,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable dest was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(266,5) inlined into gzread.c(502,13)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(254,31) inlined into gzread.c(502,13)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(502,13)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(502,13)
            remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate

               LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(502,13)
                  remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
                  remark #17102: loop was not parallelized: not a parallelization candidate
               LOOP END
            LOOP END

            LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END

            LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(502,13)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(486,1):remark #34051: REGISTER ALLOCATION : [gzungetc] gzread.c:486

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    1831
            Global    :     463
            Local     :    1368
        Regenerable   :     104
        Spilled       :     108
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :     131 [0.00e+00 ~ 0.0%]
            Writes    :     159 [0.00e+00 ~ 0.0%]
        Spills        :     808 bytes*
            Reads     :     769 [1.90e-01 ~ 0.5%]
            Writes    :     304 [2.03e-01 ~ 0.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzclose(gzFile)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzclose(gzFile)) [63/189=33.3%] gzclose.c(13,1)
  -> INLINE (PARTIAL): (21,37) gzclose_r() (isz = 10) (sz = 10)
    -> PI_CLONE gzread.c:(634,5) gzclose_r..0() (isz = 0) (sz = 0)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (PARTIAL): (21,55) gzclose_w(gzFile) (isz = 12) (sz = 12)
    -> PI_CLONE gzwrite.c:(634,5) gzclose_w..0(gzFile) (isz = 0) (sz = 0)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzclose.c(13,1):remark #34051: REGISTER ALLOCATION : [gzclose] gzclose.c:13

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :      11
            Global    :       7
            Local     :       4
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzseek(gzFile, off_t, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzseek(gzFile, off_t, int)) [64/189=33.9%] gzlib.c(447,1)
  -> (450,11) gzseek64() (isz = 141) (sz = 161)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzlib.c(447,1):remark #34051: REGISTER ALLOCATION : [gzseek] gzlib.c:447

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rdx rsi rdi]
        
    Routine temporaries
        Total         :      15
            Global    :       0
            Local     :      15
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gztell(gzFile)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gztell(gzFile)) [65/189=34.4%] gzlib.c(474,1)
  -> INLINE: (477,11) gztell64() (isz = 19) (sz = 28)


    Report from: Code generation optimizations [cg]

gzlib.c(474,1):remark #34051: REGISTER ALLOCATION : [gztell] gzlib.c:474

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :      12
            Global    :      10
            Local     :       2
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: fprintf(FILE *__restrict__, const char *__restrict__, ...)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (fprintf(FILE *__restrict__, const char *__restrict__, ...))/usr/include/x86_64-linux-gnu/bits/stdio2.h(99,1)

===========================================================================

Begin optimization report for: printf(const char *__restrict__, ...)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (printf(const char *__restrict__, ...))/usr/include/x86_64-linux-gnu/bits/stdio2.h(106,1)

===========================================================================

Begin optimization report for: strcpy(char *__restrict__, const char *__restrict__)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (strcpy(char *__restrict__, const char *__restrict__))/usr/include/x86_64-linux-gnu/bits/string_fortified.h(89,1)

===========================================================================

Begin optimization report for: test_large_inflate()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (test_large_inflate()) [69/189=36.5%] test/example.c(337,1)
  -> INLINE (MANUAL): (341,5) strcpy(char *__restrict__, const char *__restrict__) (isz = 6) (sz = 15)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(90,10) __builtin___strcpy_chk(char *, const char *, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(90,49) __builtin_object_size(const void *, int)
  -> (350,11) inflateInit_(z_streamp, const char *, int) (isz = 2) (sz = 13)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (351,5) exit(int)
  -> INLINE: (351,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> INLINE: (356,15) inflate(z_streamp, int) (isz = 5502) (sz = 5516)
    -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
    -> INLINE: inflate.c:(667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: inflate.c:(769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
    -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
    -> INLINE: inflate.c:(1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
       [[ Callee not marked with inlining pragma  <1>]]
    -> inflate.c:(1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (358,9) exit(int)
  -> INLINE: (358,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> (361,11) inflateEnd(z_streamp) (isz = 48) (sz = 56)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (362,5) exit(int)
  -> INLINE: (362,5) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> INLINE: (365,9) fprintf(FILE *__restrict__, const char *__restrict__, ...) (isz = 5) (sz = 14)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(100,10) __fprintf_chk(FILE *__restrict__, int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(101,4) __builtin_va_arg_pack(void)
  -> EXTERN: (366,9) exit(int)
  -> INLINE: (368,9) printf(const char *__restrict__, ...) (isz = 5) (sz = 12)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,10) __printf_chk(int, const char *__restrict__, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(107,56) __builtin_va_arg_pack(void)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inflate.c(1223,17) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into test/example.c(356,15)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into test/example.c(356,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into test/example.c(356,15)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into test/example.c(356,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 8  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into test/example.c(356,15)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into test/example.c(356,15)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into test/example.c(356,15)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into test/example.c(356,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into test/example.c(356,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between out (205:34) and out (205:34)
   remark #17106: parallel dependence: assumed FLOW dependence between out (205:34) and out (205:34)
   remark #15389: vectorization support: reference *out has unaligned access   [ inffast.c(205,34) ]
   remark #15389: vectorization support: reference *from has unaligned access   [ inffast.c(205,43) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.750
   remark #15300: LOOP WAS VECTORIZED
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 4.000 
   remark #15478: estimated potential speedup: 1.230 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into test/example.c(356,15)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into test/example.c(356,15)
   remark #25399: memcopy generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between *out (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed OUTPUT dependence between *out (216:34) and *out (213:25)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at inffast.c(213,25) inlined into test/example.c(356,15)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15389: vectorization support: reference *out has unaligned access   [ inffast.c(216,34) ]
      remark #15389: vectorization support: reference *from has unaligned access   [ inffast.c(216,43) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 16
      remark #15309: vectorization support: normalized vectorization overhead 1.222
      remark #15300: LOOP WAS VECTORIZED
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 0.560 
      remark #15478: estimated potential speedup: 5.900 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=6
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into test/example.c(356,15)
   <Remainder loop for vectorization>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      remark #25015: Estimate of max trip count of loop=96
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into test/example.c(356,15)
   remark #25399: memcopy generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between *out (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed OUTPUT dependence between *out (223:38) and *out (219:29)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at inffast.c(219,29) inlined into test/example.c(356,15)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15389: vectorization support: reference *out has unaligned access   [ inffast.c(223,38) ]
      remark #15389: vectorization support: reference *from has unaligned access   [ inffast.c(223,47) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 16
      remark #15309: vectorization support: normalized vectorization overhead 1.222
      remark #15300: LOOP WAS VECTORIZED
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 0.560 
      remark #15478: estimated potential speedup: 5.900 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=6
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into test/example.c(356,15)
   <Remainder loop for vectorization>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      remark #25015: Estimate of max trip count of loop=96
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between out (234:34) and out (234:34)
   remark #17106: parallel dependence: assumed FLOW dependence between out (234:34) and out (234:34)
   remark #15389: vectorization support: reference *out has unaligned access   [ inffast.c(234,34) ]
   remark #15389: vectorization support: reference *from has unaligned access   [ inffast.c(234,43) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.750
   remark #15300: LOOP WAS VECTORIZED
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 4.000 
   remark #15478: estimated potential speedup: 1.230 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into test/example.c(356,15)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into test/example.c(356,15)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into test/example.c(356,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into test/example.c(356,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into test/example.c(356,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into test/example.c(356,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into test/example.c(356,15)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into test/example.c(356,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference d_stream.state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into test/example.c(356,15)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into test/example.c(356,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(356,15)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(356,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(356,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into test/example.c(356,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into test/example.c(356,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into test/example.c(356,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into test/example.c(356,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into test/example.c(356,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(356,15)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(356,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(356,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into test/example.c(356,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into test/example.c(356,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into test/example.c(356,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into test/example.c(356,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into test/example.c(356,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between d_stream.state->lens[order[state->have]] (945:17) and d_stream.state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between d_stream.state->lens[order[state->have]] (945:17) and d_stream.state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <d_stream.state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into test/example.c(356,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into test/example.c(356,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into test/example.c(356,15)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into test/example.c(356,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into test/example.c(356,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into test/example.c(356,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into test/example.c(356,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into test/example.c(356,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into test/example.c(356,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into test/example.c(356,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at test/example.c(358,9)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at inflate.c(1226,21) inlined into test/example.c(356,15)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1107,17) inlined into test/example.c(356,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inffast.c(290,19) inlined into test/example.c(356,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inffast.c(277,20) inlined into test/example.c(356,15)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END

      LOOP BEGIN at inflate.c(1057,17) inlined into test/example.c(356,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inflate.c(960,13) inlined into test/example.c(356,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into test/example.c(356,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into test/example.c(356,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inflate.c(939,13) inlined into test/example.c(356,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into test/example.c(356,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(90,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
test/example.c(337,1):remark #34051: REGISTER ALLOCATION : [test_large_inflate] test/example.c:337

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1674
            Global    :     382
            Local     :    1292
        Regenerable   :      96
        Spilled       :      99
        
    Routine stack
        Variables     :     328 bytes*
            Reads     :     145 [2.14e+01 ~ 3.1%]
            Writes    :     216 [2.83e+01 ~ 4.1%]
        Spills        :     728 bytes*
            Reads     :     458 [1.52e+01 ~ 2.2%]
            Writes    :     156 [1.99e+01 ~ 2.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: zcalloc()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (zcalloc()) [70/189=37.0%] zutil.c(309,1)
  -> EXTERN: (311,39) malloc(size_t)


    Report from: Code generation optimizations [cg]

zutil.c(309,1):remark #34051: REGISTER ALLOCATION : [zcalloc] zutil.c:309

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rdx rsi rdi]
        
    Routine temporaries
        Total         :      14
            Global    :       0
            Local     :      14
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: zcfree()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (zcfree()) [71/189=37.6%] zutil.c(318,1)
  -> EXTERN: (320,5) free(void *)


    Report from: Code generation optimizations [cg]

zutil.c(318,1):remark #34051: REGISTER ALLOCATION : [zcfree] zutil.c:318

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rsi rdi]
        
    Routine temporaries
        Total         :      10
            Global    :       0
            Local     :      10
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: crc32(uLong, const Bytef *, uInt)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (crc32(uLong, const Bytef *, uInt)) [72/189=38.1%] crc32.c(241,1)
  -> (242,12) crc32_z() (isz = 564) (sz = 577)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

crc32.c(241,1):remark #34051: REGISTER ALLOCATION : [crc32] crc32.c:241

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rdx rsi rdi]
        
    Routine temporaries
        Total         :      16
            Global    :       0
            Local     :      16
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: memcpy(void *__restrict__, const void *__restrict__, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (memcpy(void *__restrict__, const void *__restrict__, size_t))/usr/include/x86_64-linux-gnu/bits/string_fortified.h(33,1)

===========================================================================

Begin optimization report for: inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *)) [74/189=39.2%] inftrees.c(39,1)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inftrees.c(107,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(109,5)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(114,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(132,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between left (134:9) and left (134:9)
   remark #17106: parallel dependence: assumed FLOW dependence between left (134:9) and left (134:9)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(135,30) ]
LOOP END

LOOP BEGIN at inftrees.c(142,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(146,5)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(209,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(39,1):remark #34051: REGISTER ALLOCATION : [inflate_table] inftrees.c:39

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :     216
            Global    :      77
            Local     :     139
        Regenerable   :      10
        Spilled       :      35
        
    Routine stack
        Variables     :      68 bytes*
            Reads     :      28 [1.91e+01 ~ 7.9%]
            Writes    :      37 [1.39e+01 ~ 5.7%]
        Spills        :     208 bytes*
            Reads     :      67 [8.14e+00 ~ 3.3%]
            Writes    :      41 [4.75e+00 ~ 2.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflate_fast(z_streamp, unsigned int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflate_fast(z_streamp, unsigned int)) [75/189=39.7%] inffast.c(53,1)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inffast.c(147,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at inffast.c(290,19)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at inffast.c(277,20)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(53,1):remark #34051: REGISTER ALLOCATION : [inflate_fast] inffast.c:53

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   15[ rax rdx rcx rbx rbp rsi rdi r8-r15]
        
    Routine temporaries
        Total         :     246
            Global    :      61
            Local     :     185
        Regenerable   :       6
        Spilled       :      26
        
    Routine stack
        Variables     :       4 bytes*
            Reads     :       7 [1.42e+01 ~ 4.6%]
            Writes    :       4 [7.02e+00 ~ 2.3%]
        Spills        :     152 bytes*
            Reads     :      49 [5.61e+00 ~ 1.8%]
            Writes    :      23 [1.41e+01 ~ 4.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateStateCheck()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (inflateStateCheck()) inflate.c(107,1)

===========================================================================

Begin optimization report for: inflatePrime()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflatePrime()) [77/189=40.7%] inflate.c(251,1)
  -> INLINE: (254,9) inflateStateCheck() (isz = 25) (sz = 34)


    Report from: Code generation optimizations [cg]

inflate.c(251,1):remark #34051: REGISTER ALLOCATION : [inflatePrime] inflate.c:251

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rcx rsi rdi r8-r9]
        
    Routine temporaries
        Total         :      30
            Global    :      13
            Local     :      17
        Regenerable   :       5
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: fixedtables()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (fixedtables()) inflate.c(280,1)

===========================================================================

Begin optimization report for: inflateGetDictionary()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateGetDictionary()) [79/189=41.8%] inflate.c(1295,1)
  -> INLINE: (1299,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> INLINE (MANUAL): (1304,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1306,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1295,1):remark #34051: REGISTER ALLOCATION : [inflateGetDictionary] inflate.c:1295

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rbp rsi rdi r12-r13]
        
    Routine temporaries
        Total         :      34
            Global    :      12
            Local     :      22
        Regenerable   :       2
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateGetHeader()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateGetHeader()) [80/189=42.3%] inflate.c(1352,1)
  -> INLINE: (1356,9) inflateStateCheck() (isz = 25) (sz = 34)


    Report from: Code generation optimizations [cg]

inflate.c(1352,1):remark #34051: REGISTER ALLOCATION : [inflateGetHeader] inflate.c:1352

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      15
            Global    :      11
            Local     :       4
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: syncsearch()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (syncsearch()) inflate.c(1381,1)

===========================================================================

Begin optimization report for: inflateSyncPoint()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateSyncPoint()) [82/189=43.4%] inflate.c(1453,1)
  -> INLINE: (1456,9) inflateStateCheck() (isz = 25) (sz = 34)


    Report from: Code generation optimizations [cg]

inflate.c(1453,1):remark #34051: REGISTER ALLOCATION : [inflateSyncPoint] inflate.c:1453

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rax rdx rdi]
        
    Routine temporaries
        Total         :      14
            Global    :      10
            Local     :       4
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateCopy()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateCopy()) [83/189=43.9%] inflate.c(1464,1)
  -> INLINE: (1471,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> INDIRECT-: (1477,12)  source_1222_V$ca.3.38->zalloc_V$4c
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1482,18)  source_1222_V$ca.3.38->zalloc_V$4c
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1484,13)  source_1222_V$ca.3.38->zfree_V$4d
     [[ Unable to inline indirect callsite  <3>]]
  -> INLINE (MANUAL): (1490,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1491,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1501,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to increase the width of loads
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1464,1):remark #34051: REGISTER ALLOCATION : [inflateCopy] inflate.c:1464

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   18[ rax rdx rcx rbp rsi rdi r8 r12-r15 zmm0-zmm6]
        
    Routine temporaries
        Total         :      69
            Global    :      17
            Local     :      52
        Regenerable   :      10
        Spilled       :       5
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateUndermine()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateUndermine()) [84/189=44.4%] inflate.c(1511,1)
  -> INLINE: (1514,9) inflateStateCheck() (isz = 25) (sz = 34)


    Report from: Code generation optimizations [cg]

inflate.c(1511,1):remark #34051: REGISTER ALLOCATION : [inflateUndermine] inflate.c:1511

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      13
            Global    :       9
            Local     :       4
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateValidate()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateValidate()) [85/189=45.0%] inflate.c(1529,1)
  -> INLINE: (1532,9) inflateStateCheck() (isz = 25) (sz = 34)


    Report from: Code generation optimizations [cg]

inflate.c(1529,1):remark #34051: REGISTER ALLOCATION : [inflateValidate] inflate.c:1529

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      17
            Global    :      11
            Local     :       6
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateMark()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateMark()) [86/189=45.5%] inflate.c(1543,1)
  -> INLINE: (1546,9) inflateStateCheck() (isz = 25) (sz = 34)


    Report from: Code generation optimizations [cg]

inflate.c(1543,1):remark #34051: REGISTER ALLOCATION : [inflateMark] inflate.c:1543

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rcx rdi]
        
    Routine temporaries
        Total         :      18
            Global    :      10
            Local     :       8
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateCodesUsed()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateCodesUsed()) [87/189=46.0%] inflate.c(1556,1)
  -> INLINE: (1558,9) inflateStateCheck() (isz = 25) (sz = 34)


    Report from: Code generation optimizations [cg]

inflate.c(1556,1):remark #34051: REGISTER ALLOCATION : [inflateCodesUsed] inflate.c:1556

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rcx rdi]
        
    Routine temporaries
        Total         :      16
            Global    :       9
            Local     :       7
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflate_stored()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflate_stored()) [88/189=46.6%] deflate.c(1646,1)
  -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
    -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
    -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> (1786,9) read_buf() (isz = 46) (sz = 58)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (1810,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(1658,21)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(1646,1):remark #34051: REGISTER ALLOCATION : [deflate_stored] deflate.c:1646

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   15[ rax rdx rcx rbx rbp rsi rdi r8-r15]
        
    Routine temporaries
        Total         :     220
            Global    :      58
            Local     :     162
        Regenerable   :       6
        Spilled       :      12
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      56 bytes*
            Reads     :      25 [7.45e+00 ~ 2.9%]
            Writes    :       7 [5.12e+00 ~ 2.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflate_fast()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflate_fast()) [89/189=47.1%] deflate.c(1827,1)
  -> (1838,13) fill_window() (isz = 308) (sz = 313)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> (1861,31) longest_match() (isz = 187) (sz = 197)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (1908,21) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (1908,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
    -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
    -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
      -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
    -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
      -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
      -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
    -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
    -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
       [[ Callee not marked with inlining pragma  <1>]]
    -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (1912,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> CP_CLONE (1912,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (1916,9) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
    -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
    -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
      -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
    -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
      -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
      -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
    -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
    -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
       [[ Callee not marked with inlining pragma  <1>]]
    -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (1916,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(1876,13)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between s->strstart (1880:21) and s->window[s->strstart+2] (1881:21)
   remark #17106: parallel dependence: assumed ANTI dependence between s->window[s->strstart+2] (1881:21) and s->strstart (1880:21)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between s->strstart (1880:21) and s->window[s->strstart+2] (1881:21)
   remark #15346: vector dependence: assumed ANTI dependence between s->window[s->strstart+2] (1881:21) and s->strstart (1880:21)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at deflate.c(1876,13)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1908,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1908,21)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1908,21)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1908,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1908,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1908,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1908,21)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1908,21)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1908,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1908,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1908,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1908,21)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1908,21)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1908,21)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1908,21)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1908,21)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1908,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(1908,21)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1908,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1908,21)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(1908,21)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1908,21)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1908,21)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(1908,21)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(1908,21)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1916,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1916,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1916,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1916,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1916,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1916,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1916,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->static_len (650:34) and s->static_len (650:34)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->static_len (650:34) and s->static_len (650:34)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1916,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1916,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(523,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1916,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1916,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1916,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(1916,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(1916,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(1916,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(1916,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(1916,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(1916,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(1916,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1916,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1916,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(1916,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1916,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(1916,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(1916,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(1916,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at deflate.c(1908,9)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at trees.c(1143,5) inlined into deflate.c(1908,21)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1143,5) inlined into deflate.c(1916,9)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(1827,1):remark #34051: REGISTER ALLOCATION : [deflate_fast] deflate.c:1827

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    4224
            Global    :    1054
            Local     :    3170
        Regenerable   :      67
        Spilled       :     126
        
    Routine stack
        Variables     :     192 bytes*
            Reads     :       6 [8.79e+00 ~ 0.0%]
            Writes    :      96 [1.29e+02 ~ 0.6%]
        Spills        :     928 bytes*
            Reads     :     285 [6.89e+02 ~ 3.1%]
            Writes    :     231 [8.51e+02 ~ 3.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: longest_match()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (longest_match()) [90/189=47.6%] deflate.c(1239,1)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(1279,42)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable

   LOOP BEGIN at deflate.c(1314,48)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable match was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

deflate.c(1239,1):remark #34051: REGISTER ALLOCATION : [longest_match] deflate.c:1239

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   15[ rax rdx rcx rbx rbp rsi rdi r8-r15]
        
    Routine temporaries
        Total         :      64
            Global    :      25
            Local     :      39
        Regenerable   :       1
        Spilled       :       9
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      24 bytes*
            Reads     :       5 [1.69e+00 ~ 1.3%]
            Writes    :       3 [3.00e+00 ~ 2.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflate_slow()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflate_slow()) [91/189=48.1%] deflate.c(1929,1)
  -> INLINE: (1941,13) fill_window() (isz = 308) (sz = 313)
    -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
    -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
      -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
  -> INLINE: (1967,31) longest_match() (isz = 187) (sz = 197)
  -> INLINE: (2011,25) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> CP_CLONE (2011,25) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (2021,17) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
    -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
    -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
      -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
      -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
        -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
        -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
        -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
          -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
    -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
    -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
      -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
      -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
    -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
    -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
       [[ Callee not marked with inlining pragma  <1>]]
    -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
       [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (2021,17) flush_pending() (isz = 45) (sz = 51)
    -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
      -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> (2043,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]
  -> CP_CLONE (2043,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> CP_CLONE (2047,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> (2047,9) flush_pending() (isz = 45) (sz = 51)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(1487,18) inlined into deflate.c(1941,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1941,13)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1941,13)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into deflate.c(1941,13)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1941,13)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1941,13)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into deflate.c(1941,13)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into deflate.c(1941,13)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(1279,42) inlined into deflate.c(1967,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable

   LOOP BEGIN at deflate.c(1314,48) inlined into deflate.c(1967,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable match was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2003,23)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2021,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2021,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2021,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2021,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2021,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2021,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2021,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2021,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2021,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2021,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2021,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into deflate.c(2021,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into deflate.c(2021,17)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into deflate.c(2021,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into deflate.c(2021,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into deflate.c(2021,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into deflate.c(2021,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into deflate.c(2021,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2021,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2021,17)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into deflate.c(2021,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2021,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into deflate.c(2021,17)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(2021,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into deflate.c(2021,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at deflate.c(2011,13)
   remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at trees.c(1143,5) inlined into deflate.c(2021,17)
      remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
      remark #17102: loop was not parallelized: not a parallelization candidate
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(1929,1):remark #34051: REGISTER ALLOCATION : [deflate_slow] deflate.c:1929

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :    2476
            Global    :     625
            Local     :    1851
        Regenerable   :      47
        Spilled       :      72
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [3.14e+00 ~ 0.0%]
            Writes    :      48 [4.59e+01 ~ 0.5%]
        Spills        :     528 bytes*
            Reads     :     161 [2.55e+02 ~ 2.9%]
            Writes    :     124 [3.09e+02 ~ 3.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: memcpy(void *__restrict__, const void *__restrict__, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (memcpy(void *__restrict__, const void *__restrict__, size_t))/usr/include/x86_64-linux-gnu/bits/string_fortified.h(33,1)

===========================================================================

Begin optimization report for: memset(void *, int, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (memset(void *, int, size_t))/usr/include/x86_64-linux-gnu/bits/string_fortified.h(60,1)

===========================================================================

Begin optimization report for: _tr_flush_block(deflate_state *, charf *, ulg, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (_tr_flush_block(deflate_state *, charf *, ulg, int)) [94/189=49.7%] trees.c(916,1)
  -> INLINE: (925,34) detect_data_type() (isz = 48) (sz = 58)
  -> INLINE: (928,9) build_tree() (isz = 834) (sz = 841)
    -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
    -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
      -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
  -> INLINE: (932,9) build_tree() (isz = 834) (sz = 841)
    -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
    -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
    -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
      -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
  -> INLINE: (942,23) build_bl_tree() (isz = 1068) (sz = 1075)
    -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
    -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
    -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
      -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
      -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
      -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
        -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
  -> (971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (979,9) compress_block() (isz = 546) (sz = 555)
  -> INLINE: (986,9) send_all_trees() (isz = 1701) (sz = 1712)
    -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
    -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
  -> INLINE: (988,9) compress_block() (isz = 546) (sz = 555)
  -> (998,5) init_block() (isz = 39) (sz = 44)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (1001,9) bi_windup() (isz = 51) (sz = 56)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at trees.c(1135,5) inlined into trees.c(925,34)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(928,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(928,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(928,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(928,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(928,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(928,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into trees.c(928,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into trees.c(928,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into trees.c(928,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into trees.c(928,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into trees.c(928,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(932,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(932,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(932,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(932,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(932,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(932,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into trees.c(932,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into trees.c(932,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into trees.c(932,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into trees.c(932,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into trees.c(932,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(942,23)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into trees.c(942,23)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(942,23)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(942,23)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(942,23)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into trees.c(942,23)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into trees.c(942,23)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into trees.c(942,23)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into trees.c(942,23)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into trees.c(942,23)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into trees.c(942,23)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into trees.c(986,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into trees.c(986,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into trees.c(986,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into trees.c(986,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into trees.c(986,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into trees.c(986,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into trees.c(986,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into trees.c(986,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into trees.c(988,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into trees.c(979,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at trees.c(1143,5) inlined into trees.c(925,34)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

trees.c(916,1):remark #34051: REGISTER ALLOCATION : [_tr_flush_block] trees.c:916

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    2026
            Global    :     512
            Local     :    1514
        Regenerable   :      28
        Spilled       :      61
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [2.77e+00 ~ 0.0%]
            Writes    :      48 [4.06e+01 ~ 0.6%]
        Spills        :     424 bytes*
            Reads     :     137 [2.12e+02 ~ 3.1%]
            Writes    :     108 [2.65e+02 ~ 3.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: _tr_flush_bits(deflate_state *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (_tr_flush_bits(deflate_state *)) [95/189=50.3%] trees.c(888,1)
  -> (889,5) bi_flush() (isz = 61) (sz = 66)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

trees.c(888,1):remark #34051: REGISTER ALLOCATION : [_tr_flush_bits] trees.c:888

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rdi]
        
    Routine temporaries
        Total         :       9
            Global    :       0
            Local     :       9
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: slide_hash()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (slide_hash()) deflate.c(203,1)

===========================================================================

Begin optimization report for: deflateGetDictionary()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateGetDictionary()) [97/189=51.3%] deflate.c(449,1)
  -> (453,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (460,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(449,1):remark #34051: REGISTER ALLOCATION : [deflateGetDictionary] deflate.c:449

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r8 r12-r14]
        
    Routine temporaries
        Total         :      32
            Global    :      14
            Local     :      18
        Regenerable   :       2
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateReset()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateReset()) [98/189=51.9%] deflate.c(507,1)
  -> (510,11) deflateResetKeep() (isz = 397) (sz = 405)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (512,9) lm_init() (isz = 55) (sz = 60)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

deflate.c(507,1):remark #34051: REGISTER ALLOCATION : [deflateReset] deflate.c:507

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdi r13-r14]
        
    Routine temporaries
        Total         :      14
            Global    :       9
            Local     :       5
        Regenerable   :       0
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateSetHeader()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateSetHeader()) [99/189=52.4%] deflate.c(520,1)
  -> (521,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

deflate.c(520,1):remark #34051: REGISTER ALLOCATION : [deflateSetHeader] deflate.c:520

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    5[ rax rbx rbp rsi rdi]
        
    Routine temporaries
        Total         :      16
            Global    :      10
            Local     :       6
        Regenerable   :       2
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflatePending()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflatePending()) [100/189=52.9%] deflate.c(532,1)
  -> (533,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

deflate.c(532,1):remark #34051: REGISTER ALLOCATION : [deflatePending] deflate.c:532

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rsi rdi r12-r14]
        
    Routine temporaries
        Total         :      21
            Global    :      10
            Local     :      11
        Regenerable   :       2
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflatePrime()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflatePrime()) [101/189=53.4%] deflate.c(546,1)
  -> (550,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (560,9) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
    -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(552,5)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

    Report from: Code generation optimizations [cg]

deflate.c(546,1):remark #34051: REGISTER ALLOCATION : [deflatePrime] deflate.c:546

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r12-r15]
        
    Routine temporaries
        Total         :      35
            Global    :      13
            Local     :      22
        Regenerable   :       4
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       8 bytes*
            Reads     :       1 [6.90e-01 ~ 0.6%]
            Writes    :       1 [6.90e-01 ~ 0.6%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateTune()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateTune()) [102/189=54.0%] deflate.c(623,1)
  -> (626,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

deflate.c(623,1):remark #34051: REGISTER ALLOCATION : [deflateTune] deflate.c:623

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   11[ rax rdx rcx rbx rbp rsi rdi r8 r13-r15]
        
    Routine temporaries
        Total         :      22
            Global    :      13
            Local     :       9
        Regenerable   :       0
        Spilled       :       5
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateBound()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateBound()) [103/189=54.5%] deflate.c(655,1)
  -> (664,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(684,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable str was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at deflate.c(689,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable str was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

    Report from: Code generation optimizations [cg]

deflate.c(655,1):remark #34051: REGISTER ALLOCATION : [deflateBound] deflate.c:655

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rbx rsi rdi r8 r14-r15]
        
    Routine temporaries
        Total         :      47
            Global    :      20
            Local     :      27
        Regenerable   :       2
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: putShortMSB()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (putShortMSB()) deflate.c(719,1)

===========================================================================

Begin optimization report for: deflateCopy()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateCopy()) [105/189=55.6%] deflate.c(1105,1)
  -> (1114,9) deflateStateCheck() (isz = 46) (sz = 55)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (1120,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INDIRECT-: (1122,28)  dest_958_V$102.4.66->zalloc_V$4c
     [[ Unable to inline indirect callsite  <3>]]
  -> INLINE (MANUAL): (1125,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INDIRECT-: (1128,28)  dest_958_V$102.4.66->zalloc_V$4c
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1129,28)  dest_958_V$102.4.66->zalloc_V$4c
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1130,28)  dest_958_V$102.4.66->zalloc_V$4c
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (1131,24)  dest_958_V$102.4.66->zalloc_V$4c
     [[ Unable to inline indirect callsite  <3>]]
  -> (1136,9) deflateEnd(z_streamp) (isz = 63) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (1140,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1141,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1142,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE (MANUAL): (1143,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to increase the width of loads
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to increase the width of stores
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
deflate.c(1105,1):remark #34051: REGISTER ALLOCATION : [deflateCopy] deflate.c:1105

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   18[ rax rdx rcx rsi rdi r8-r9 r12-r15 zmm0-zmm6]
        
    Routine temporaries
        Total         :     104
            Global    :      23
            Local     :      81
        Regenerable   :      11
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflate_rle()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (deflate_rle()) deflate.c(2060,1)

===========================================================================

Begin optimization report for: read(int, void *, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (read(int, void *, size_t))/usr/include/x86_64-linux-gnu/bits/unistd.h(35,1)

===========================================================================

Begin optimization report for: memcpy(void *__restrict__, const void *__restrict__, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (memcpy(void *__restrict__, const void *__restrict__, size_t))/usr/include/x86_64-linux-gnu/bits/string_fortified.h(33,1)

===========================================================================

Begin optimization report for: gz_load()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gz_load()) gzread.c(26,1)

===========================================================================

Begin optimization report for: gz_avail()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gz_avail()) gzread.c(58,1)

===========================================================================

Begin optimization report for: gz_decomp()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gz_decomp()) gzread.c(177,1)

===========================================================================

Begin optimization report for: gz_read()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gz_read()) gzread.c(298,1)

===========================================================================

Begin optimization report for: gz_fetch()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_fetch()) [113/189=59.8%] gzread.c(231,1)
  -> INLINE: (237,17) gz_look() (isz = 249) (sz = 262)
    -> EXTERN: (99,38) malloc(size_t)
    -> EXTERN: (100,39) malloc(size_t)
    -> EXTERN: (102,13) free(void *)
    -> EXTERN: (103,13) free(void *)
    -> CP_CLONE (104,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (115,13) inflateInit2_..0() (isz = 58) (sz = 74)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (116,13) free(void *)
    -> EXTERN: (117,13) free(void *)
    -> CP_CLONE (119,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (126,13) gz_avail() (isz = 103) (sz = 112)
      -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
        -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
        -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> EXTERN: (41,34) __errno_location(void)
        -> EXTERN: (41,34) strerror(int)
    -> (141,9) inflateReset() (isz = 40) (sz = 48)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): (161,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
  -> INLINE: (243,17) gz_load() (isz = 42) (sz = 56)
    -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
    -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (41,34) __errno_location(void)
    -> EXTERN: (41,34) strerror(int)
  -> INLINE: (251,17) gz_decomp() (isz = 5691) (sz = 5702)
    -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
      -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
        -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
        -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
           [[ Callee not marked with inlining pragma  <1>]]
        -> EXTERN: (41,34) __errno_location(void)
        -> EXTERN: (41,34) strerror(int)
    -> CP_CLONE (189,13) gz_error..3(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (194,15) inflate(z_streamp, int) (isz = 5502) (sz = 5516)
      -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
      -> INLINE: inflate.c:(667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> INLINE: inflate.c:(722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: inflate.c:(769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
      -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
      -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
      -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
      -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
      -> INLINE: inflate.c:(1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: inflate.c:(1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> inflate.c:(1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
         [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (196,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (201,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (205,13) gz_error..4(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(237,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(237,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(237,17)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(237,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(251,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(251,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(251,17)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(251,17)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(251,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(251,17)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(251,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(251,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(251,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(251,17)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(251,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(251,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(251,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(251,17)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(251,17)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(251,17)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(251,17)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(251,17)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(251,17)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(251,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(251,17)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(251,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(251,17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(251,17)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(251,17)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(251,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(251,17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(251,17)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(251,17)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(251,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(251,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(251,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(251,17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(251,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(251,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(251,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(243,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(254,31)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(251,17)
      remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(251,17)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(251,17)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(251,17)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(251,17)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END

         LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(251,17)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(251,17)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(251,17)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(251,17)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(251,17)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(251,17)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(231,1):remark #34051: REGISTER ALLOCATION : [gz_fetch] gzread.c:231

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :    1791
            Global    :     449
            Local     :    1342
        Regenerable   :     102
        Spilled       :     106
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :     131 [0.00e+00 ~ 0.0%]
            Writes    :     159 [0.00e+00 ~ 0.0%]
        Spills        :     800 bytes*
            Reads     :     767 [1.93e+00 ~ 2.0%]
            Writes    :     303 [2.42e+00 ~ 2.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzfread()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzfread()) [114/189=60.3%] gzread.c(416,1)
  -> CP_CLONE (433,9) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (438,18) gz_read() (isz = 5842) (sz = 5858)
    -> (309,13) gz_skip() (isz = 6092) (sz = 6102)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE (MANUAL): (325,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> (340,17) gz_fetch() (isz = 6046) (sz = 6058)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (349,17) gz_load() (isz = 42) (sz = 56)
      -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
      -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (41,34) strerror(int)
      -> EXTERN: (41,34) __errno_location(void)
    -> INLINE: (357,17) gz_decomp() (isz = 5691) (sz = 5702)
      -> INLINE: (186,36) gz_avail() (isz = 103) (sz = 112)
        -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
          -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
          -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
             [[ Callee not marked with inlining pragma  <1>]]
          -> EXTERN: (41,34) strerror(int)
          -> EXTERN: (41,34) __errno_location(void)
      -> CP_CLONE (189,13) gz_error..3(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (194,15) inflate(z_streamp, int) (isz = 5502) (sz = 5516)
        -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
        -> INLINE: inflate.c:(667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
        -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
        -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
        -> INLINE: inflate.c:(1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> INLINE: inflate.c:(1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
           [[ Callee not marked with inlining pragma  <1>]]
        -> inflate.c:(1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: inflate.c:(1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (196,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (201,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (205,13) gz_error..4(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(438,18)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(438,18)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(438,18)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1223,17) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into gzread.c(438,18)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into gzread.c(438,18)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into gzread.c(438,18)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(438,18)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(438,18)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into gzread.c(438,18)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into gzread.c(438,18)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(438,18)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(438,18)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into gzread.c(438,18)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(438,18)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(438,18)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into gzread.c(438,18)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into gzread.c(438,18)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into gzread.c(438,18)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(438,18)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(438,18)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into gzread.c(438,18)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(438,18)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(438,18)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(438,18)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(438,18)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(438,18)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(438,18)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(438,18)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(438,18)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(438,18)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between state->lens[order[state->have]] (945:17) and state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into gzread.c(438,18)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into gzread.c(438,18)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into gzread.c(438,18)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into gzread.c(438,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into gzread.c(438,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into gzread.c(438,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzread.c(368,14) inlined into gzread.c(438,18)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at gzread.c(209,14) inlined into gzread.c(438,18)
      remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1226,21) inlined into gzread.c(438,18)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inflate.c(1107,17) inlined into gzread.c(438,18)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inffast.c(290,19) inlined into gzread.c(438,18)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate

            LOOP BEGIN at inffast.c(277,20) inlined into gzread.c(438,18)
               remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
               remark #17102: loop was not parallelized: not a parallelization candidate
            LOOP END
         LOOP END

         LOOP BEGIN at inflate.c(1057,17) inlined into gzread.c(438,18)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(960,13) inlined into gzread.c(438,18)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(438,18)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(438,18)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inflate.c(939,13) inlined into gzread.c(438,18)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END

         LOOP BEGIN at inftrees.c(132,5) inlined into gzread.c(438,18)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
gzread.c(416,1):remark #34051: REGISTER ALLOCATION : [gzfread] gzread.c:416

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1716
            Global    :     414
            Local     :    1302
        Regenerable   :      85
        Spilled       :     108
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :     131 [5.17e-02 ~ 0.1%]
            Writes    :     159 [7.09e-02 ~ 0.2%]
        Spills        :     792 bytes*
            Reads     :     587 [2.82e-01 ~ 0.6%]
            Writes    :     279 [3.67e-01 ~ 0.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzgetc_()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzgetc_()) [115/189=60.8%] gzread.c(478,1)
  -> INLINE (PARTIAL): (479,12) gzgetc(gzFile) (isz = 10) (sz = 10)
    -> PI_CLONE (455,5) gzgetc..0(gzFile) (isz = 0) (sz = 0)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzread.c(478,1):remark #34051: REGISTER ALLOCATION : [gzgetc_] gzread.c:478

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzdirect()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzdirect()) [116/189=61.4%] gzread.c(609,1)
  -> (620,15) gz_look() (isz = 249) (sz = 262)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzread.c(609,1):remark #34051: REGISTER ALLOCATION : [gzdirect] gzread.c:609

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rax rdi r12]
        
    Routine temporaries
        Total         :      12
            Global    :       7
            Local     :       5
        Regenerable   :       1
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_look()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_look()) [117/189=61.9%] gzread.c(93,1)
  -> EXTERN: (99,38) malloc(size_t)
  -> EXTERN: (100,39) malloc(size_t)
  -> EXTERN: (102,13) free(void *)
  -> EXTERN: (103,13) free(void *)
  -> CP_CLONE (104,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> CP_CLONE (115,13) inflateInit2_..0() (isz = 58) (sz = 74)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (116,13) free(void *)
  -> EXTERN: (117,13) free(void *)
  -> CP_CLONE (119,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (126,13) gz_avail() (isz = 103) (sz = 112)
    -> INLINE: (73,13) gz_load() (isz = 42) (sz = 56)
      -> INLINE (MANUAL): (35,15) read(int, void *, size_t) (isz = 41) (sz = 54)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(36,7) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(38,12) __builtin_constant_p(...)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,9) __read_chk(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(39,44) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(41,22) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,9) __read_chk_warn(int, void *, size_t, size_t)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(42,49) __builtin_object_size(const void *, int)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/unistd.h:(44,10) __read_alias(int, void *, size_t)
      -> CP_CLONE (41,9) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (41,34) strerror(int)
      -> EXTERN: (41,34) __errno_location(void)
  -> (141,9) inflateReset() (isz = 40) (sz = 48)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE (MANUAL): (161,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(126,13)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *q (65:9) and *p (70:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (65:9)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(126,13)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *p (70:18) and *q (70:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *q (70:18) and *p (70:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at gzread.c(65,9) inlined into gzread.c(126,13)
   <Remainder, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at gzread.c(30,6) inlined into gzread.c(126,13)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzread.c(93,1):remark #34051: REGISTER ALLOCATION : [gz_look] gzread.c:93

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   14[ rax rdx rcx rbx rbp rsi rdi r8-r10 r12-r15]
        
    Routine temporaries
        Total         :     103
            Global    :      34
            Local     :      69
        Regenerable   :      22
        Spilled       :       6
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      24 bytes*
            Reads     :       6 [3.15e-01 ~ 0.7%]
            Writes    :       3 [3.15e-01 ~ 0.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzclose_r()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzclose_r()) [118/189=62.4%] gzread.c(629,1)
  -> (644,9) inflateEnd(z_streamp) (isz = 48) (sz = 56)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (645,9) free(void *)
  -> EXTERN: (646,9) free(void *)
  -> CP_CLONE (649,5) gz_error..5(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (650,5) free(void *)
  -> EXTERN: (651,11) close(int)
  -> EXTERN: (652,5) free(void *)


    Report from: Code generation optimizations [cg]

gzread.c(629,1):remark #34051: REGISTER ALLOCATION : [gzclose_r] gzread.c:629

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rcx rsi rdi r13-r15]
        
    Routine temporaries
        Total         :      33
            Global    :      10
            Local     :      23
        Regenerable   :       7
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: snprintf(char *__restrict__, size_t, const char *__restrict__, ...)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (snprintf(char *__restrict__, size_t, const char *__restrict__, ...))/usr/include/x86_64-linux-gnu/bits/stdio2.h(66,1)

===========================================================================

Begin optimization report for: open(const char *, int, ...)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (open(const char *, int, ...))/usr/include/x86_64-linux-gnu/bits/fcntl2.h(42,1)

===========================================================================

Begin optimization report for: gz_reset()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gz_reset()) gzlib.c(77,1)

===========================================================================

Begin optimization report for: gz_open()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gz_open()) gzlib.c(95,1)

===========================================================================

Begin optimization report for: gzopen64()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzopen64()) [123/189=65.1%] gzlib.c(281,1)
  -> INLINE: (282,12) gz_open() (isz = 257) (sz = 275)
    -> EXTERN: (111,24) malloc(size_t)
    -> EXTERN: (140,17) free(void *)
    -> EXTERN: (177,9) free(void *)
    -> EXTERN: (184,13) free(void *)
    -> EXTERN: (199,15) strlen(const char *)
    -> EXTERN: (200,27) malloc(size_t)
    -> EXTERN: (202,9) free(void *)
    -> INLINE: (214,15) snprintf(char *__restrict__, size_t, const char *__restrict__, ...) (isz = 10) (sz = 21)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(67,10) __builtin___snprintf_chk(char *, unsigned long, int, unsigned long, const char *, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,8) __builtin_object_size(const void *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,28) __builtin_va_arg_pack(void)
    -> INLINE: (245,9) open(const char *, int, ...) (isz = 48) (sz = 60)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(43,7) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(44,5) __open_too_many_args(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(46,7) __builtin_constant_p(...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(48,42) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(50,4) __open_missing_mode(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(51,11) __open_2(const char *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(53,14) __open_alias(const char *, int, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(53,45) __builtin_va_arg_pack(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(56,7) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(57,12) __open_2(const char *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(59,10) __open_alias(const char *, int, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(59,41) __builtin_va_arg_pack(void)
    -> EXTERN: (247,9) free(void *)
    -> EXTERN: (248,9) free(void *)
    -> EXTERN: (252,9) lseek64(int, __off64_t, int)
    -> EXTERN: (258,24) lseek64(int, __off64_t, int)
    -> INLINE: (263,5) gz_reset() (isz = 19) (sz = 24)
      -> CP_CLONE (85,5) gz_error..5(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]



Non-optimizable loops:


LOOP BEGIN at gzlib.c(123,5) inlined into gzlib.c(282,12)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ gzlib.c(127,13) ]
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

gzlib.c(281,1):remark #34051: REGISTER ALLOCATION : [gzopen64] gzlib.c:281

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   14[ rax rdx rcx rbx rbp rsi rdi r8-r11 r13-r15]
        
    Routine temporaries
        Total         :      76
            Global    :      31
            Local     :      45
        Regenerable   :      21
        Spilled       :       5
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzdopen()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzdopen()) [124/189=65.6%] gzlib.c(289,1)
  -> EXTERN: (293,37) malloc(size_t)
  -> INLINE: (296,11) snprintf(char *__restrict__, size_t, const char *__restrict__, ...) (isz = 10) (sz = 21)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(67,10) __builtin___snprintf_chk(char *, unsigned long, int, unsigned long, const char *, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,8) __builtin_object_size(const void *, int)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,28) __builtin_va_arg_pack(void)
  -> INLINE: (300,10) gz_open() (isz = 257) (sz = 275)
    -> EXTERN: (111,24) malloc(size_t)
    -> EXTERN: (140,17) free(void *)
    -> EXTERN: (177,9) free(void *)
    -> EXTERN: (184,13) free(void *)
    -> EXTERN: (199,15) strlen(const char *)
    -> EXTERN: (200,27) malloc(size_t)
    -> EXTERN: (202,9) free(void *)
    -> INLINE: (214,15) snprintf(char *__restrict__, size_t, const char *__restrict__, ...) (isz = 10) (sz = 21)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(67,10) __builtin___snprintf_chk(char *, unsigned long, int, unsigned long, const char *, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,8) __builtin_object_size(const void *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,28) __builtin_va_arg_pack(void)
    -> INLINE: (245,9) open(const char *, int, ...) (isz = 48) (sz = 60)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(43,7) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(44,5) __open_too_many_args(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(46,7) __builtin_constant_p(...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(48,42) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(50,4) __open_missing_mode(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(51,11) __open_2(const char *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(53,14) __open_alias(const char *, int, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(53,45) __builtin_va_arg_pack(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(56,7) __builtin_va_arg_pack_len(void)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(57,12) __open_2(const char *, int)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(59,10) __open_alias(const char *, int, ...)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/fcntl2.h:(59,41) __builtin_va_arg_pack(void)
    -> EXTERN: (247,9) free(void *)
    -> EXTERN: (248,9) free(void *)
    -> EXTERN: (252,9) lseek64(int, __off64_t, int)
    -> EXTERN: (258,24) lseek64(int, __off64_t, int)
    -> INLINE: (263,5) gz_reset() (isz = 19) (sz = 24)
      -> CP_CLONE (85,5) gz_error..5(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (301,5) free(void *)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]



Non-optimizable loops:


LOOP BEGIN at gzlib.c(123,5) inlined into gzlib.c(300,10)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ gzlib.c(127,13) ]
   remark #17102: loop was not parallelized: not a parallelization candidate
LOOP END

    Report from: Code generation optimizations [cg]

gzlib.c(289,1):remark #34051: REGISTER ALLOCATION : [gzdopen] gzlib.c:289

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   15[ rax rdx rcx rbx rbp rsi rdi r8-r15]
        
    Routine temporaries
        Total         :      88
            Global    :      32
            Local     :      56
        Regenerable   :      29
        Spilled       :       6
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzbuffer()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzbuffer()) [125/189=66.1%] gzlib.c(319,1)


    Report from: Code generation optimizations [cg]

gzlib.c(319,1):remark #34051: REGISTER ALLOCATION : [gzbuffer] gzlib.c:319

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rax rsi rdi]
        
    Routine temporaries
        Total         :      19
            Global    :      10
            Local     :       9
        Regenerable   :       4
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzrewind()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzrewind()) [126/189=66.7%] gzlib.c(345,1)
  -> EXTERN: (359,9) lseek64(int, __off64_t, int)
  -> INLINE: (361,5) gz_reset() (isz = 19) (sz = 24)
    -> CP_CLONE (85,5) gz_error..5(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzlib.c(345,1):remark #34051: REGISTER ALLOCATION : [gzrewind] gzlib.c:345

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    5[ rax rdx rsi rdi r13]
        
    Routine temporaries
        Total         :      24
            Global    :      10
            Local     :      14
        Regenerable   :       8
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gztell64()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gztell64()) [127/189=67.2%] gzlib.c(457,1)


    Report from: Code generation optimizations [cg]

gzlib.c(457,1):remark #34051: REGISTER ALLOCATION : [gztell64] gzlib.c:457

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :      14
            Global    :       9
            Local     :       5
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzoffset64()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzoffset64()) [128/189=67.7%] gzlib.c(484,1)
  -> EXTERN: (496,14) lseek64(int, __off64_t, int)


    Report from: Code generation optimizations [cg]

gzlib.c(484,1):remark #34051: REGISTER ALLOCATION : [gzoffset64] gzlib.c:484

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    5[ rax rdx rsi rdi r14]
        
    Routine temporaries
        Total         :      20
            Global    :      10
            Local     :      10
        Regenerable   :       5
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzoffset()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzoffset()) [129/189=68.3%] gzlib.c(507,1)
  -> INLINE: (510,11) gzoffset64() (isz = 26) (sz = 36)
    -> EXTERN: (496,14) lseek64(int, __off64_t, int)


    Report from: Code generation optimizations [cg]

gzlib.c(507,1):remark #34051: REGISTER ALLOCATION : [gzoffset] gzlib.c:507

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    5[ rax rdx rsi rdi r12]
        
    Routine temporaries
        Total         :      17
            Global    :      10
            Local     :       7
        Regenerable   :       2
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzeof()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzeof()) [130/189=68.8%] gzlib.c(517,1)


    Report from: Code generation optimizations [cg]

gzlib.c(517,1):remark #34051: REGISTER ALLOCATION : [gzeof] gzlib.c:517

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :      13
            Global    :       9
            Local     :       4
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzclose_w(gzFile)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzclose_w(gzFile)) [131/189=69.3%] gzwrite.c(629,1)
  -> (645,13) gz_zero() (isz = 9326) (sz = 9337)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (650,9) gz_comp() (isz = 9270) (sz = 9284)
    -> (82,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (89,20) write(int, const void *, size_t)
    -> CP_CLONE (91,17) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (91,42) __errno_location(void)
    -> EXTERN: (91,42) strerror(int)
    -> EXTERN: (110,24) write(int, const void *, size_t)
    -> CP_CLONE (112,21) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (112,46) __errno_location(void)
    -> EXTERN: (112,46) strerror(int)
    -> INLINE: (126,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
      -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
        -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1786,9) read_buf() (isz = 46) (sz = 58)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1810,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
        -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
          -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
          -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
          -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
          -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
            -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
          -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
            -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
          -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
             [[ Callee not marked with inlining pragma  <1>]]
          -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2118,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.2420->level_V$3f))]
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
      -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (128,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
      -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
         [[ Callee not marked with inlining pragma  <1>]]
  -> (654,19) deflateEnd(z_streamp) (isz = 63) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (655,13) free(void *)
  -> EXTERN: (657,9) free(void *)
  -> CP_CLONE (659,5) gz_error..5(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (660,5) free(void *)
  -> EXTERN: (661,9) close(int)
  -> EXTERN: (663,5) free(void *)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(650,9)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(650,9)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(650,9)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(650,9)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(650,9)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(650,9)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(650,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(650,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(650,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(650,9)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(650,9)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(650,9)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(650,9)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(650,9)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(650,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(650,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(650,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(650,9)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(650,9)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(650,9)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(650,9)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(650,9)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(629,1):remark #34051: REGISTER ALLOCATION : [gzclose_w] gzwrite.c:629

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm4]
        
    Routine temporaries
        Total         :    2940
            Global    :     721
            Local     :    2219
        Regenerable   :      67
        Spilled       :      81
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [6.98e-02 ~ 0.0%]
            Writes    :      48 [1.02e+00 ~ 0.4%]
        Spills        :     616 bytes*
            Reads     :     220 [6.30e+00 ~ 2.2%]
            Writes    :     149 [7.54e+00 ~ 2.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: vsnprintf(char *__restrict__, size_t, const char *__restrict__, struct __va_list_tag *)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (vsnprintf(char *__restrict__, size_t, const char *__restrict__, struct __va_list_tag *))/usr/include/x86_64-linux-gnu/bits/stdio2.h(79,1)

===========================================================================

Begin optimization report for: memcpy(void *__restrict__, const void *__restrict__, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (memcpy(void *__restrict__, const void *__restrict__, size_t))/usr/include/x86_64-linux-gnu/bits/string_fortified.h(33,1)

===========================================================================

Begin optimization report for: memset(void *, int, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (memset(void *, int, size_t))/usr/include/x86_64-linux-gnu/bits/string_fortified.h(60,1)

===========================================================================

Begin optimization report for: gz_comp()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gz_comp()) gzwrite.c(76,1)

===========================================================================

Begin optimization report for: gz_write()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gz_write()) gzwrite.c(182,1)

===========================================================================

Begin optimization report for: gzwrite()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzwrite()) [137/189=72.5%] gzwrite.c(250,1)
  -> CP_CLONE (265,9) gz_error..4(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (270,17) gz_write() (isz = 9388) (sz = 9405)
    -> (190,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (196,13) gz_zero() (isz = 9326) (sz = 9337)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE (MANUAL): (213,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> CP_CLONE (218,24) gz_comp..0() (isz = 9270) (sz = 9284)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (224,37) gz_comp() (isz = 9270) (sz = 9284)
      -> (82,29) gz_init() (isz = 92) (sz = 102)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (89,20) write(int, const void *, size_t)
      -> CP_CLONE (91,17) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (91,42) strerror(int)
      -> EXTERN: (91,42) __errno_location(void)
      -> EXTERN: (110,24) write(int, const void *, size_t)
      -> CP_CLONE (112,21) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (112,46) strerror(int)
      -> EXTERN: (112,46) __errno_location(void)
      -> INLINE: (126,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
        -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
          -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
            -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1786,9) read_buf() (isz = 46) (sz = 58)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1810,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
          -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
            -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
            -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
              -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
              -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
                 [[ Callee not marked with inlining pragma  <1>]]
              -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
                -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                   [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
            -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
            -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
            -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
              -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
                -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
                -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                  -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
            -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
              -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
              -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
            -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
               [[ Callee not marked with inlining pragma  <1>]]
            -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
          -> (2118,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
          -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> (2122,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.2605->level_V$3f))]
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
        -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (128,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
        -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
           [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (235,17) gz_comp..0() (isz = 9270) (sz = 9284)
       [[ Inlining inhibited by overrideable criterion  <2>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(201,5) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(270,17)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(270,17)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(270,17)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(270,17)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(270,17)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(270,17)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(270,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(270,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(270,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(270,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(270,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(270,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(270,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(270,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(270,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(270,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(270,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(270,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(270,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(270,17)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(270,17)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(270,17)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(270,17)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(270,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(270,17)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(270,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(270,17)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(270,17)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(270,17)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(270,17)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at gzwrite.c(228,9) inlined into gzwrite.c(270,17)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(270,17)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(270,17)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(270,17)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(250,1):remark #34051: REGISTER ALLOCATION : [gzwrite] gzwrite.c:250

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2909
            Global    :     723
            Local     :    2186
        Regenerable   :      77
        Spilled       :      75
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [7.73e-04 ~ 0.0%]
            Writes    :      48 [1.13e-02 ~ 0.0%]
        Spills        :     552 bytes*
            Reads     :     186 [6.74e-02 ~ 0.1%]
            Writes    :     130 [9.24e-02 ~ 0.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzfwrite()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzfwrite()) [138/189=73.0%] gzwrite.c(279,1)
  -> CP_CLONE (295,9) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (300,18) gz_write() (isz = 9388) (sz = 9405)
    -> (190,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (196,13) gz_zero() (isz = 9326) (sz = 9337)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE (MANUAL): (213,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> CP_CLONE (218,24) gz_comp..0() (isz = 9270) (sz = 9284)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: (224,37) gz_comp() (isz = 9270) (sz = 9284)
      -> (82,29) gz_init() (isz = 92) (sz = 102)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (89,20) write(int, const void *, size_t)
      -> CP_CLONE (91,17) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (91,42) strerror(int)
      -> EXTERN: (91,42) __errno_location(void)
      -> EXTERN: (110,24) write(int, const void *, size_t)
      -> CP_CLONE (112,21) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> EXTERN: (112,46) strerror(int)
      -> EXTERN: (112,46) __errno_location(void)
      -> INLINE: (126,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
        -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
          -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
        -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
          -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
            -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1786,9) read_buf() (isz = 46) (sz = 58)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> (1810,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
          -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
            -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
            -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
              -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
                -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
              -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
                 [[ Callee not marked with inlining pragma  <1>]]
              -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
                -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                   [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
            -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
            -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
              -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
                 [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
            -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
            -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
              -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
              -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
                -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
                -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
                -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                  -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
            -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
            -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
              -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
              -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
            -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
               [[ Callee not marked with inlining pragma  <1>]]
            -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
               [[ Callee not marked with inlining pragma  <1>]]
          -> (2118,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
          -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
             [[ Inlining inhibited by overrideable criterion  <2>]]
          -> (2122,9) flush_pending() (isz = 45) (sz = 51)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.2697->level_V$3f))]
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
        -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
        -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (128,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
        -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
           [[ Callee not marked with inlining pragma  <1>]]
        -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
           [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (235,17) gz_comp..0() (isz = 9270) (sz = 9284)
       [[ Inlining inhibited by overrideable criterion  <2>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(201,5) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(300,18)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(300,18)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(300,18)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(300,18)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(300,18)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(300,18)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(300,18)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(300,18)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(300,18)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(300,18)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(300,18)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(300,18)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(300,18)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(300,18)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(300,18)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(300,18)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(300,18)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(300,18)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(300,18)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(300,18)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(300,18)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(300,18)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(300,18)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(300,18)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(300,18)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(300,18)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(300,18)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(300,18)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(300,18)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(300,18)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at gzwrite.c(228,9) inlined into gzwrite.c(300,18)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(300,18)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(300,18)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(300,18)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(279,1):remark #34051: REGISTER ALLOCATION : [gzfwrite] gzwrite.c:279

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2918
            Global    :     725
            Local     :    2193
        Regenerable   :      79
        Spilled       :      83
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [1.70e-04 ~ 0.0%]
            Writes    :      48 [2.49e-03 ~ 0.0%]
        Spills        :     600 bytes*
            Reads     :     243 [1.94e-02 ~ 0.0%]
            Writes    :     174 [2.38e-02 ~ 0.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzflush()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzflush()) [139/189=73.5%] gzwrite.c(556,1)
  -> (575,13) gz_zero() (isz = 9326) (sz = 9337)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (580,11) gz_comp() (isz = 9270) (sz = 9284)
    -> (82,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (89,20) write(int, const void *, size_t)
    -> CP_CLONE (91,17) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (91,42) __errno_location(void)
    -> EXTERN: (91,42) strerror(int)
    -> EXTERN: (110,24) write(int, const void *, size_t)
    -> CP_CLONE (112,21) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (112,46) __errno_location(void)
    -> EXTERN: (112,46) strerror(int)
    -> INLINE: (126,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
      -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
        -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1786,9) read_buf() (isz = 46) (sz = 58)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1810,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
        -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
          -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
          -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
          -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
          -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
            -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
          -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
            -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
          -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
             [[ Callee not marked with inlining pragma  <1>]]
          -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2118,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.2240->level_V$3f))]
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
      -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (128,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
      -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
         [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(580,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(580,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(580,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(580,11)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(580,11)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(580,11)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(580,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(580,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(580,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(580,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(580,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(580,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(580,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(580,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(580,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(580,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(580,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(580,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(580,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(580,11)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(580,11)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(580,11)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(580,11)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(580,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(580,11)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(580,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(580,11)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(580,11)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(580,11)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(580,11)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(580,11)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(580,11)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(580,11)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(580,11)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(556,1):remark #34051: REGISTER ALLOCATION : [gzflush] gzwrite.c:556

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2968
            Global    :     724
            Local     :    2244
        Regenerable   :      66
        Spilled       :      79
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [2.57e-02 ~ 0.0%]
            Writes    :      48 [3.76e-01 ~ 0.3%]
        Spills        :     608 bytes*
            Reads     :     268 [3.12e+00 ~ 2.5%]
            Writes    :     164 [3.72e+00 ~ 2.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzsetparams()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzsetparams()) [140/189=74.1%] gzwrite.c(589,1)
  -> (610,13) gz_zero() (isz = 9326) (sz = 9337)
     [[ Inlining inhibited by overrideable criterion  <2>]]
  -> INLINE: (617,31) gz_comp() (isz = 9270) (sz = 9284)
    -> (82,29) gz_init() (isz = 92) (sz = 102)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (89,20) write(int, const void *, size_t)
    -> CP_CLONE (91,17) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (91,42) __errno_location(void)
    -> EXTERN: (91,42) strerror(int)
    -> EXTERN: (110,24) write(int, const void *, size_t)
    -> CP_CLONE (112,21) gz_error..1(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> EXTERN: (112,46) __errno_location(void)
    -> EXTERN: (112,46) strerror(int)
    -> INLINE: (126,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
      -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
        -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
      -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
        -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
        -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
          -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1786,9) read_buf() (isz = 46) (sz = 58)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (1810,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
        -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
          -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
          -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
            -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
              -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
            -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
               [[ Callee not marked with inlining pragma  <1>]]
            -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
              -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
                 [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
          -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
          -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
          -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
            -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
            -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
              -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
              -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
              -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
                -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
          -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
          -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
            -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
            -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
          -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
             [[ Callee not marked with inlining pragma  <1>]]
          -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
          -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
            -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
               [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
        -> (2118,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> (2122,9) flush_pending() (isz = 45) (sz = 51)
           [[ Callee not marked with inlining pragma  <1>]]
        -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
           [[ Inlining inhibited by overrideable criterion  <2>]]
      -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.2330->level_V$3f))]
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
      -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
      -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> CP_CLONE (128,13) gz_error..0(gz_statep, int, const char *) (isz = 59) (sz = 71)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: (137,9) deflateReset() (isz = 7) (sz = 14)
      -> deflate.c:(510,11) deflateResetKeep() (isz = 397) (sz = 405)
         [[ Callee not marked with inlining pragma  <1>]]
      -> deflate.c:(512,9) lm_init() (isz = 55) (sz = 60)
         [[ Callee not marked with inlining pragma  <1>]]
  -> (619,9) deflateParams(z_streamp, int, int) (isz = 9246) (sz = 9261)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at gzwrite.c(107,13) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(904,13) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(617,31)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(617,31)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into gzwrite.c(617,31)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(617,31)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(617,31)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into gzwrite.c(617,31)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into gzwrite.c(617,31)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(617,31)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(617,31)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(617,31)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(617,31)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(617,31)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(617,31)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(617,31)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(617,31)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(617,31)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(617,31)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(617,31)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into gzwrite.c(617,31)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into gzwrite.c(617,31)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into gzwrite.c(617,31)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into gzwrite.c(617,31)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into gzwrite.c(617,31)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into gzwrite.c(617,31)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (849:9) and s->bi_buf (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into gzwrite.c(617,31)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(617,31)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(617,31)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into gzwrite.c(617,31)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(617,31)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #17106: parallel dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #15346: vector dependence: assumed OUTPUT dependence between s->bi_buf (769:18) and s->bi_buf (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into gzwrite.c(617,31)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at gzwrite.c(87,9) inlined into gzwrite.c(617,31)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END


Non-optimizable loops:


LOOP BEGIN at gzwrite.c(133,14) inlined into gzwrite.c(617,31)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into gzwrite.c(617,31)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into gzwrite.c(617,31)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
gzwrite.c(589,1):remark #34051: REGISTER ALLOCATION : [gzsetparams] gzwrite.c:589

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    2868
            Global    :     706
            Local     :    2162
        Regenerable   :      66
        Spilled       :      74
        
    Routine stack
        Variables     :      96 bytes*
            Reads     :       3 [2.21e-02 ~ 0.0%]
            Writes    :      48 [3.23e-01 ~ 0.3%]
        Spills        :     552 bytes*
            Reads     :     186 [2.00e+00 ~ 1.7%]
            Writes    :     130 [2.62e+00 ~ 2.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: uncompress2()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (uncompress2()) [141/189=74.6%] uncompr.c(32,1)
  -> (55,11) inflateInit_(z_streamp, const char *, int) (isz = 2) (sz = 13)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (70,15) inflate(z_streamp, int) (isz = 5502) (sz = 5516)
    -> INLINE: inflate.c:(645,9) inflateStateCheck() (isz = 25) (sz = 34)
    -> INLINE: inflate.c:(667,32) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(668,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(701,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(722,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(730,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(740,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(750,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): inflate.c:(764,25) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: inflate.c:(769,40) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(790,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(811,36) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(833,42) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(847,42) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(867,17) fixedtables() (isz = 10) (sz = 15)
    -> INLINE (MANUAL): inflate.c:(909,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: inflate.c:(949,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1023,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1032,19) inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *) (isz = 430) (sz = 452)
    -> INLINE: inflate.c:(1047,17) inflate_fast(z_streamp, unsigned int) (isz = 537) (sz = 544)
    -> INLINE: inflate.c:(1205,25) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> INLINE: inflate.c:(1205,25) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> inflate.c:(1257,13) updatewindow() (isz = 101) (sz = 113)
       [[ Callee not marked with inlining pragma  <1>]]
    -> inflate.c:(1268,13) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: inflate.c:(1268,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
  -> (79,5) inflateEnd(z_streamp) (isz = 48) (sz = 56)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at inflate.c(1223,17) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1223:17) and hold (1223:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1223:17) and hold (1223:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1199,17) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1199:17) and hold (1199:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1199:17) and hold (1199:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at adler32.c(103,5) inlined into uncompr.c(70,15)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between buf (108:13) and buf (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between buf (107:13) and buf (108:13)

   LOOP BEGIN at adler32.c(105,9) inlined into uncompr.c(70,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed FLOW dependence between buf (108:13) and buf (108:13)
      remark #17106: parallel dependence: assumed ANTI dependence between buf (108:13) and buf (108:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9) inlined into uncompr.c(70,15)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(92,9) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable len was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 8  
LOOP END

LOOP BEGIN at inflate.c(1185,13) inlined into uncompr.c(70,15)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (1185:13) and *put (1187:18)
   remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1185:13)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inflate.c(1185,13) inlined into uncompr.c(70,15)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *put (1187:18) and *from (1187:18)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (1187:18) and *put (1187:18)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inflate.c(1185,13) inlined into uncompr.c(70,15)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(1132,17) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1132:17) and hold (1132:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1132:17) and hold (1132:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(1113,30) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(1095,17) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (1095:17) and hold (1095:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (1095:17) and hold (1095:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inffast.c(147,13) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (205:34) and *from (205:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (205:34) and *out (205:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(202,25) inlined into uncompr.c(70,15)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(213,25) inlined into uncompr.c(70,15)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (213:25) and *out (216:34)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (213:25)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(213,25) inlined into uncompr.c(70,15)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (216:34) and *from (216:34)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (216:34) and *out (216:34)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(213,25) inlined into uncompr.c(70,15)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(219,29) inlined into uncompr.c(70,15)
   remark #25401: memcopy(with guard) generated
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between *from (219:29) and *out (223:38)
   remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (219:29)
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy

   LOOP BEGIN at inffast.c(219,29) inlined into uncompr.c(70,15)
   <Multiversioned v2>
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed FLOW dependence between *out (223:38) and *from (223:38)
      remark #17106: parallel dependence: assumed ANTI dependence between *from (223:38) and *out (223:38)
      remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
      remark #25439: unrolled with remainder by 2  
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at inffast.c(219,29) inlined into uncompr.c(70,15)
   <Remainder, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #17106: parallel dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (234:34) and *from (234:34)
   remark #15346: vector dependence: assumed ANTI dependence between *from (234:34) and *out (234:34)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inffast.c(231,25) inlined into uncompr.c(70,15)
<Remainder>
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (240:26) and *(from+2) (242:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (242:26) and *out (240:26)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(239,21) inlined into uncompr.c(70,15)
<Remainder>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inffast.c(252,21) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #17106: parallel dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between *out (254:26) and *(from+2) (256:26)
   remark #15346: vector dependence: assumed ANTI dependence between *(from+2) (256:26) and *out (254:26)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at inflate.c(1063,30) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at inflate.c(972,25) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(984,25) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(991,25) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into uncompr.c(70,15)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=7
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into uncompr.c(70,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(1003,37) ]
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference stream.state->lens[state->have] has aligned access   [ inflate.c(1003,25) ]
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 4.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 0.500 
   remark #15478: estimated potential speedup: 4.840 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=40
LOOP END

LOOP BEGIN at inflate.c(1002,21) inlined into uncompr.c(70,15)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=320
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into uncompr.c(70,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(70,15)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(70,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(70,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into uncompr.c(70,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(70,15)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(70,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(70,15)
<Remainder>
LOOP END

LOOP BEGIN at inftrees.c(209,5) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(940,17) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (940:17) and hold (940:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (940:17) and hold (940:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into uncompr.c(70,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ inflate.c(945,35) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between stream.state->lens[order[state->have]] (945:17) and stream.state->lens[order[state->have]] (945:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between stream.state->lens[order[state->have]] (945:17) and stream.state->lens[order[state->have]] (945:17)
   remark #15389: vectorization support: reference order[state->have] has unaligned access   [ inflate.c(945,29) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: irregularly indexed store was emulated for the variable <stream.state->lens[order[state->have]]>, part of index is read from memory   [ inflate.c(945,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.115
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15463: unmasked indexed (or scatter) stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 13.000 
   remark #15478: estimated potential speedup: 0.390 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inflate.c(944,13) inlined into uncompr.c(70,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at inftrees.c(107,5) inlined into uncompr.c(70,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15388: vectorization support: reference count[len] has aligned access   [ inftrees.c(108,9) ]
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.370 
   remark #15478: estimated potential speedup: 5.330 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at inftrees.c(109,5) inlined into uncompr.c(70,15)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #15346: vector dependence: assumed ANTI dependence between count[*(lens+sym*2)] (110:9) and count[*(lens+sym*2)] (110:9)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(114,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(114,35) ]
LOOP END

LOOP BEGIN at inftrees.c(126,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ inftrees.c(126,30) ]
   remark #25015: Estimate of max trip count of loop=16
LOOP END

LOOP BEGIN at inftrees.c(142,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between offs[len+1] (143:9) and offs[len] (143:9)
   remark #25436: completely unrolled by 14  
LOOP END

LOOP BEGIN at inftrees.c(146,5) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #17106: parallel dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between lens[sym] (147:39) and work[offs[*(lens+sym*2)]] (147:29)
   remark #15346: vector dependence: assumed FLOW dependence between work[offs[*(lens+sym*2)]] (147:29) and lens[sym] (147:39)
   remark #25436: completely unrolled by 19  
LOOP END

LOOP BEGIN at inftrees.c(206,5) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at inftrees.c(233,9) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable fill was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END

   LOOP BEGIN at inftrees.c(241,9) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at inftrees.c(269,13) inlined into uncompr.c(70,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable curr was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END

LOOP BEGIN at inflate.c(921,13) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (921:13) and hold (921:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (921:13) and hold (921:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(889,13) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (889:13) and hold (889:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (889:13) and hold (889:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(857,13) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (857:13) and hold (857:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (857:13) and hold (857:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(838,13) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (838:13) and hold (838:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (838:13) and hold (838:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(821,17) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (821:17) and hold (821:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (821:17) and hold (821:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(802,17) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(781,17) inlined into uncompr.c(70,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15324: loop was not vectorized: unsigned types for induction variable and/or for lower/upper iteration bounds make loop uncountable
LOOP END

LOOP BEGIN at inflate.c(745,17) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (745:17) and hold (745:17)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (745:17) and hold (745:17)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(734,13) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (734:13) and hold (734:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (734:13) and hold (734:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(726,13) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (726:13) and hold (726:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (726:13) and hold (726:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(707,13) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (707:13) and hold (707:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (707:13) and hold (707:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END

LOOP BEGIN at inflate.c(662,13) inlined into uncompr.c(70,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed FLOW dependence between hold (662:13) and hold (662:13)
   remark #17106: parallel dependence: assumed ANTI dependence between hold (662:13) and hold (662:13)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria
LOOP END


Non-optimizable loops:


LOOP BEGIN at uncompr.c(71,21)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at inflate.c(1226,21) inlined into uncompr.c(70,15)
      remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ inflate.c(656,9) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at inflate.c(1107,17) inlined into uncompr.c(70,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inffast.c(290,19) inlined into uncompr.c(70,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate

         LOOP BEGIN at inffast.c(277,20) inlined into uncompr.c(70,15)
            remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
            remark #17102: loop was not parallelized: not a parallelization candidate
         LOOP END
      LOOP END

      LOOP BEGIN at inflate.c(1057,17) inlined into uncompr.c(70,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inflate.c(960,13) inlined into uncompr.c(70,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into uncompr.c(70,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into uncompr.c(70,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inflate.c(939,13) inlined into uncompr.c(70,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END

      LOOP BEGIN at inftrees.c(132,5) inlined into uncompr.c(70,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inflate.c(1185,13):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1105,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(110,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(277,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inflate.c(1055,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inflate.c(962,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1110,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1112,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(141,20):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(267,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(213,25):remark #34026: call to memcpy implemented as a call to optimized library version
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
inffast.c(219,29):remark #34026: call to memcpy implemented as a call to optimized library version
inflate.c(1060,24):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
inflate.c(1062,28):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (1, 0), and destination (alignment, offset): (16, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(236,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(121,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(122,12):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
inftrees.c(297,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
uncompr.c(32,1):remark #34051: REGISTER ALLOCATION : [uncompress2] uncompr.c:32

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1666
            Global    :     387
            Local     :    1279
        Regenerable   :      71
        Spilled       :     112
        
    Routine stack
        Variables     :     329 bytes*
            Reads     :     154 [5.10e+01 ~ 3.4%]
            Writes    :     218 [5.88e+01 ~ 3.9%]
        Spills        :     768 bytes*
            Reads     :     526 [4.18e+01 ~ 2.8%]
            Writes    :     220 [4.46e+01 ~ 3.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: compress2()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (compress2()) [142/189=75.1%] compress.c(28,1)
  -> (41,11) deflateInit_(z_streamp, int, const char *, int) (isz = 5) (sz = 18)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (58,15) deflate(z_streamp, int) (isz = 9099) (sz = 9125)
    -> deflate.c:(770,9) deflateStateCheck() (isz = 46) (sz = 55)
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(787,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(831,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(835,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(836,13) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(838,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
      -> INLINE: adler32.c:(139,12) adler32_z() (isz = 340) (sz = 354)
    -> deflate.c:(842,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(851,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(868,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(894,31) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE (MANUAL): deflate.c:(906,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(909,17) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(911,17) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): deflate.c:(919,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(922,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(933,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(934,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(944,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(955,21) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(956,21) flush_pending() (isz = 45) (sz = 51)
      -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
        -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
           [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE: deflate.c:(966,13) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(973,17) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(981,27) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
      -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(986,9) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1000,34) deflate_stored() (isz = 676) (sz = 687)
      -> INLINE: (1690,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
        -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1699,9) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1711,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (1723,13) read_buf() (isz = 46) (sz = 58)
        -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
          -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
             [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): (1743,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1750,17) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1754,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE (MANUAL): (1778,9) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> (1786,9) read_buf() (isz = 46) (sz = 58)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1808,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
         [[ Callee not marked with inlining pragma  <1>]]
      -> (1810,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(1001,50) deflate_huff() (isz = 11827) (sz = 11841)
       [[ Inlining inhibited by overrideable criterion  <2>]]
    -> INLINE: deflate.c:(1002,41) deflate_rle() (isz = 6524) (sz = 6538)
      -> INLINE: (2071,13) fill_window() (isz = 308) (sz = 313)
        -> INLINE (MANUAL): (1512,13) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
        -> INLINE: (1516,13) slide_hash() (isz = 51) (sz = 56)
        -> INLINE: (1534,13) read_buf() (isz = 46) (sz = 58)
          -> INLINE (MANUAL): (1176,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
            -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
          -> (1178,23) adler32(uLong, const Bytef *, uInt) (isz = 341) (sz = 352)
             [[ Callee not marked with inlining pragma  <1>]]
          -> INLINE: (1182,23) crc32(uLong, const Bytef *, uInt) (isz = 1) (sz = 12)
            -> crc32.c:(242,12) crc32_z() (isz = 564) (sz = 577)
               [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (1581,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
        -> INLINE (MANUAL): (1592,13) memset(void *, int, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) flush_pending() (isz = 45) (sz = 51)
        -> INLINE: (736,5) _tr_flush_bits(deflate_state *) (isz = 0) (sz = 5)
          -> trees.c:(889,5) bi_flush() (isz = 61) (sz = 66)
             [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE (MANUAL): (741,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
          -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
      -> INLINE: (2114,21) _tr_flush_block(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
        -> INLINE: trees.c:(925,34) detect_data_type() (isz = 48) (sz = 58)
        -> INLINE: trees.c:(928,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(932,9) build_tree() (isz = 834) (sz = 841)
          -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
          -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
          -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
            -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> INLINE: trees.c:(942,23) build_bl_tree() (isz = 1068) (sz = 1075)
          -> INLINE: (805,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (806,5) scan_tree() (isz = 98) (sz = 107)
          -> INLINE: (809,5) build_tree() (isz = 834) (sz = 841)
            -> INLINE: (658,42) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (665,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (684,9) pqdownheap() (isz = 108) (sz = 117)
            -> INLINE: (693,5) gen_bitlen() (isz = 217) (sz = 225)
            -> INLINE: (696,5) gen_codes() (isz = 68) (sz = 77)
              -> INLINE: (600,29) bi_reverse() (isz = 17) (sz = 26)
        -> trees.c:(971,9) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
           [[ Callee not marked with inlining pragma  <1>]]
        -> INLINE: trees.c:(979,9) compress_block() (isz = 546) (sz = 555)
        -> INLINE: trees.c:(986,9) send_all_trees() (isz = 1701) (sz = 1712)
          -> INLINE: (853,5) send_tree() (isz = 692) (sz = 701)
          -> INLINE: (856,5) send_tree() (isz = 692) (sz = 701)
        -> INLINE: trees.c:(988,9) compress_block() (isz = 546) (sz = 555)
        -> trees.c:(998,5) init_block() (isz = 39) (sz = 44)
           [[ Callee not marked with inlining pragma  <1>]]
        -> trees.c:(1001,9) bi_windup() (isz = 51) (sz = 56)
           [[ Callee not marked with inlining pragma  <1>]]
      -> (2118,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
      -> CP_CLONE (2118,9) _tr_flush_block..1(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> CP_CLONE (2122,9) _tr_flush_block..0(deflate_state *, charf *, ulg, int) (isz = 5810) (sz = 5821)
         [[ Inlining inhibited by overrideable criterion  <2>]]
      -> (2122,9) flush_pending() (isz = 45) (sz = 51)
         [[ Callee not marked with inlining pragma  <1>]]
    -> INDIRECT: deflate.c:(1003,18)  func_V$11_2.0.4[(EXPR_CONV.SI32.SI64(s.776_V$d4.4.64.1791->level_V$3f))]
       [[ Callee not marked with inlining pragma  <1>]]
    -> deflate.c:(1023,17) _tr_align(deflate_state *) (isz = 128) (sz = 133)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1025,17) _tr_stored_block(deflate_state *, charf *, ulg, int) (isz = 142) (sz = 153)
      -> trees.c:(870,5) bi_windup() (isz = 51) (sz = 56)
         [[ Callee not marked with inlining pragma  <1>]]
      -> INLINE (MANUAL): trees.c:(873,5) memcpy(void *__restrict__, const void *__restrict__, size_t) (isz = 6) (sz = 17)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,10) __builtin___memcpy_chk(void *, const void *, unsigned long, unsigned long)
        -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(34,56) __builtin_object_size(const void *, int)
    -> INLINE (MANUAL): deflate.c:(1030,21) memset(void *, int, size_t) (isz = 6) (sz = 17)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
      -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)
    -> deflate.c:(1038,13) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
    -> INLINE: deflate.c:(1064,9) putShortMSB() (isz = 23) (sz = 30)
    -> INLINE: deflate.c:(1065,9) putShortMSB() (isz = 23) (sz = 30)
    -> deflate.c:(1067,5) flush_pending() (isz = 45) (sz = 51)
       [[ Callee not marked with inlining pragma  <1>]]
  -> (62,5) deflateEnd(z_streamp) (isz = 63) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at deflate.c(904,13) inlined into compress.c(58,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(929,23) inlined into compress.c(58,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(951,23) inlined into compress.c(58,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1658,21) inlined into compress.c(58,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at deflate.c(1487,18) inlined into compress.c(58,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at deflate.c(209,5) inlined into compress.c(58,15)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into compress.c(58,15)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(212,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(211,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(209,5) inlined into compress.c(58,15)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into compress.c(58,15)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=7
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into compress.c(58,15)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #25453: Loop Reversed
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(219,10) ]
      remark #15388: vectorization support: reference *p has aligned access   [ deflate.c(218,16) ]
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: REVERSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 4.370 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at deflate.c(216,5) inlined into compress.c(58,15)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at deflate.c(1545,13) inlined into compress.c(58,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->window[str+2] (1546:17) and s->insert (1552:17)
      remark #17106: parallel dependence: assumed FLOW dependence between s->insert (1552:17) and s->window[str+2] (1546:17)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ deflate.c(1553,17) ]
   LOOP END
LOOP END

LOOP BEGIN at deflate.c(2086,37) inlined into compress.c(58,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable scan was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at trees.c(1135,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #17106: parallel dependence: assumed FLOW dependence between black_mask (1135:31) and black_mask (1136:9)
   remark #17106: parallel dependence: assumed ANTI dependence between black_mask (1136:9) and black_mask (1135:31)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(925,34) ]
   remark #25438: unrolled without remainder by 2  
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(58,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(58,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into compress.c(58,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into compress.c(58,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into compress.c(58,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(58,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(58,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25427: Loop Statements Reordered
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into compress.c(58,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->opt_len (556:17) and s->opt_len (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into compress.c(58,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into compress.c(58,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(719,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[curlen] (724:13) and s->freq[18] (731:13)
   remark #15346: vector dependence: assumed OUTPUT dependence between s->freq[18] (731:13) and s->freq[curlen] (724:13)
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(58,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(634,24) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->heap[:] (634:13) and s->heap[:] (634:13)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #15346: vector dependence: assumed ANTI dependence between s->heap_len (634:24) and s->heap_len (634:24)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(632,5) inlined into compress.c(58,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Predicate Optimized v1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,34) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(647,27) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(650,9) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between tree->freq[node] (648:9) and tree->freq[node] (648:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed OUTPUT dependence between s->depth[node] (649:9) and s->depth[node] (649:9)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #17106: parallel dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25422: Invariant Condition at line 650 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Remainder, Predicate Optimized v1>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Predicate Optimized v2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed FLOW dependence between max_code (647:61) and max_code (647:55)
   remark #15346: vector dependence: assumed ANTI dependence between max_code (647:55) and max_code (647:61)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(646,5) inlined into compress.c(58,15)
<Remainder, Predicate Optimized v2>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(658,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->heap[n] (456:13) and s->heap[k] (473:5)
   remark #15346: vector dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[n] (456:13)
   remark #25015: Estimate of max trip count of loop=573

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(663,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->heap[1] (665:9) and s->heap[k] (473:5)
   remark #17106: parallel dependence: assumed FLOW dependence between s->heap[k] (473:5) and s->heap[1] (665:9)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive
   remark #25015: Estimate of max trip count of loop=286

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END

   LOOP BEGIN at trees.c(458,5) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at trees.c(503,5) inlined into compress.c(58,15)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15389: vectorization support: reference s->bl_count[bits] has unaligned access   [ trees.c(503,46) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15427: loop was completely unrolled
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.620 
   remark #15478: estimated potential speedup: 2.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at trees.c(510,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[n] (512:9) and tree->dad[n] (514:9)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[n] (514:9) and tree->dad[n] (512:9)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=573
LOOP END

LOOP BEGIN at trees.c(526,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #17106: parallel dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->bl_count[bits] (534:9) and s->bl_count[max_length] (537:9)
   remark #15346: vector dependence: assumed FLOW dependence between s->bl_count[max_length] (537:9) and s->bl_count[bits] (534:9)

   LOOP BEGIN at trees.c(534,9) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable bits was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(549,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #17106: parallel dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between tree->dad[m] (556:17) and tree->dad[m] (557:17)
   remark #15346: vector dependence: assumed FLOW dependence between tree->dad[m] (557:17) and tree->dad[m] (556:17)
   remark #25015: Estimate of max trip count of loop=16

   LOOP BEGIN at trees.c(551,9) inlined into compress.c(58,15)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable h was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
   LOOP END
LOOP END

LOOP BEGIN at trees.c(585,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #17106: parallel dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between code (586:9) and code (586:9)
   remark #15346: vector dependence: assumed FLOW dependence between code (586:9) and code (586:9)
   remark #25436: completely unrolled by 15  
LOOP END

LOOP BEGIN at trees.c(596,5) inlined into compress.c(58,15)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ trees.c(597,19) ]
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #17106: parallel dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between next_code[len] (600:40) and next_code[len] (600:40)
   remark #15346: vector dependence: assumed FLOW dependence between next_code[len] (600:40) and next_code[len] (600:40)

   LOOP BEGIN at trees.c(598,9) inlined into compress.c(58,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #17106: parallel dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed FLOW dependence between code (1165:9) and code (1164:9)
      remark #15346: vector dependence: assumed ANTI dependence between code (1164:9) and code (1165:9)
   LOOP END
LOOP END

LOOP BEGIN at trees.c(818,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ trees.c(818,54) ]
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between s->dad[bl_order[rank]] (849:9) and *(s->pending_buf+s->pending) (849:9)
   remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (849:9) and s->dad[bl_order[rank]] (849:9)
   remark #25439: unrolled with remainder by 16  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(847,5) inlined into compress.c(58,15)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into compress.c(58,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into compress.c(58,15)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(764,5) inlined into compress.c(58,15)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between tree->dad[n+1] (765:27) and *(s->pending_buf+s->pending) (782:52)
   remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (782:52) and tree->dad[n+1] (765:27)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at trees.c(768,16) inlined into compress.c(58,15)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #17106: parallel dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between s->dad[curlen] (769:18) and *(s->pending_buf+s->pending) (769:18)
      remark #15346: vector dependence: assumed FLOW dependence between *(s->pending_buf+s->pending) (769:18) and s->dad[curlen] (769:18)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at trees.c(768,16) inlined into compress.c(58,15)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into compress.c(58,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at trees.c(1075,5) inlined into compress.c(58,15)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15523: loop was not vectorized: loop control variable lx was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END


Non-optimizable loops:


LOOP BEGIN at compress.c(59,21)
   remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
   remark #17102: loop was not parallelized: not a parallelization candidate

   LOOP BEGIN at deflate.c(2114,9) inlined into compress.c(58,15)
      remark #15536: loop was not vectorized: inner loop throttling prevents vectorization of this outer loop. Refer to inner loop message for more details.   [ trees.c(1143,5) ]
      remark #17102: loop was not parallelized: not a parallelization candidate

      LOOP BEGIN at trees.c(1143,5) inlined into compress.c(58,15)
         remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
         remark #17102: loop was not parallelized: not a parallelization candidate
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32768, 0), and destination (alignment, offset): (1, 0)
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(34,10):remark #34026: call to memcpy implemented as a call to optimized library version
compress.c(28,1):remark #34051: REGISTER ALLOCATION : [compress2] compress.c:28

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm5]
        
    Routine temporaries
        Total         :    3042
            Global    :     746
            Local     :    2296
        Regenerable   :      71
        Spilled       :      74
        
    Routine stack
        Variables     :     208 bytes*
            Reads     :      54 [2.54e+01 ~ 1.4%]
            Writes    :      80 [3.79e+01 ~ 2.1%]
        Spills        :     544 bytes*
            Reads     :     286 [3.63e+01 ~ 2.0%]
            Writes    :     187 [3.56e+01 ~ 2.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: compressBound()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (compressBound()) [143/189=75.7%] compress.c(83,1)


    Report from: Code generation optimizations [cg]

compress.c(83,1):remark #34051: REGISTER ALLOCATION : [compressBound] compress.c:83

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rax rdx rdi]
        
    Routine temporaries
        Total         :      15
            Global    :       0
            Local     :      15
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: get_crc_table()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (get_crc_table()) [144/189=76.2%] crc32.c(189,1)


    Report from: Code generation optimizations [cg]

crc32.c(189,1):remark #34051: REGISTER ALLOCATION : [get_crc_table] crc32.c:189

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rax]
        
    Routine temporaries
        Total         :       8
            Global    :       0
            Local     :       8
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: crc32_little()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (crc32_little()) crc32.c(270,1)

===========================================================================

Begin optimization report for: crc32_big()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (crc32_big()) crc32.c(310,1)

===========================================================================

Begin optimization report for: gf2_matrix_times()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gf2_matrix_times()) crc32.c(347,1)

===========================================================================

Begin optimization report for: gf2_matrix_square()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gf2_matrix_square()) crc32.c(364,1)

===========================================================================

Begin optimization report for: crc32_combine_()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (crc32_combine_()) crc32.c(376,1)

===========================================================================

Begin optimization report for: crc32_combine()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (crc32_combine()) [150/189=79.4%] crc32.c(432,1)
  -> INLINE: (433,12) crc32_combine_() (isz = 224) (sz = 236)
    -> INLINE: (395,5) gf2_matrix_square() (isz = 30) (sz = 37)
      -> INLINE: (368,21) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (398,5) gf2_matrix_square() (isz = 30) (sz = 37)
      -> INLINE: (368,21) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (404,9) gf2_matrix_square() (isz = 30) (sz = 37)
      -> INLINE: (368,21) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (406,20) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (414,9) gf2_matrix_square() (isz = 30) (sz = 37)
      -> INLINE: (368,21) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (416,20) gf2_matrix_times() (isz = 15) (sz = 24)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at crc32.c(389,5) inlined into crc32.c(433,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between row (390:9) and row (391:9)
   remark #17106: parallel dependence: assumed FLOW dependence between row (391:9) and row (390:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between row (390:9) and row (391:9)
   remark #15346: vector dependence: assumed FLOW dependence between row (391:9) and row (390:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at crc32.c(389,5) inlined into crc32.c(433,12)
<Remainder>
LOOP END

LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(433,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive   [ crc32.c(351,5) ]
   remark #25015: Estimate of max trip count of loop=32

   LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(433,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END
LOOP END

LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(433,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive   [ crc32.c(351,5) ]
   remark #25015: Estimate of max trip count of loop=32

   LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(433,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END
LOOP END

LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(433,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(433,12)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15541: outer loop was not auto-vectorized: consider using SIMD directive   [ crc32.c(351,5) ]
      remark #25015: Estimate of max trip count of loop=32

      LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(433,12)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
         remark #25478: While Loop Unrolled by 8  
         remark #25015: Estimate of max trip count of loop=4
      LOOP END
   LOOP END

   LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(433,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END

   LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(433,12)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15541: outer loop was not auto-vectorized: consider using SIMD directive   [ crc32.c(351,5) ]
      remark #25015: Estimate of max trip count of loop=32

      LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(433,12)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
         remark #25478: While Loop Unrolled by 8  
         remark #25015: Estimate of max trip count of loop=4
      LOOP END
   LOOP END

   LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(433,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

crc32.c(432,1):remark #34051: REGISTER ALLOCATION : [crc32_combine] crc32.c:432

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r8-r11]
        
    Routine temporaries
        Total         :     124
            Global    :      34
            Local     :      90
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :     512 bytes*
            Reads     :      52 [7.56e+02 ~ 10.7%]
            Writes    :       8 [2.46e+02 ~ 3.5%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: crc32_combine64()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (crc32_combine64()) [151/189=79.9%] crc32.c(440,1)
  -> INLINE: (441,12) crc32_combine_() (isz = 224) (sz = 236)
    -> INLINE: (395,5) gf2_matrix_square() (isz = 30) (sz = 37)
      -> INLINE: (368,21) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (398,5) gf2_matrix_square() (isz = 30) (sz = 37)
      -> INLINE: (368,21) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (404,9) gf2_matrix_square() (isz = 30) (sz = 37)
      -> INLINE: (368,21) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (406,20) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (414,9) gf2_matrix_square() (isz = 30) (sz = 37)
      -> INLINE: (368,21) gf2_matrix_times() (isz = 15) (sz = 24)
    -> INLINE: (416,20) gf2_matrix_times() (isz = 15) (sz = 24)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at crc32.c(389,5) inlined into crc32.c(441,12)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between row (390:9) and row (391:9)
   remark #17106: parallel dependence: assumed FLOW dependence between row (391:9) and row (390:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between row (390:9) and row (391:9)
   remark #15346: vector dependence: assumed FLOW dependence between row (391:9) and row (390:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at crc32.c(389,5) inlined into crc32.c(441,12)
<Remainder>
LOOP END

LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(441,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive   [ crc32.c(351,5) ]
   remark #25015: Estimate of max trip count of loop=32

   LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(441,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END
LOOP END

LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(441,12)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive   [ crc32.c(351,5) ]
   remark #25015: Estimate of max trip count of loop=32

   LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(441,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END
LOOP END

LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(441,12)
   remark #17102: loop was not parallelized: not a parallelization candidate
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(441,12)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15541: outer loop was not auto-vectorized: consider using SIMD directive   [ crc32.c(351,5) ]
      remark #25015: Estimate of max trip count of loop=32

      LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(441,12)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
         remark #25478: While Loop Unrolled by 8  
         remark #25015: Estimate of max trip count of loop=4
      LOOP END
   LOOP END

   LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(441,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END

   LOOP BEGIN at crc32.c(367,5) inlined into crc32.c(441,12)
      remark #17108: loop was not parallelized: insufficient computational work
      remark #15541: outer loop was not auto-vectorized: consider using SIMD directive   [ crc32.c(351,5) ]
      remark #25015: Estimate of max trip count of loop=32

      LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(441,12)
         remark #17102: loop was not parallelized: not a parallelization candidate
         remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
         remark #25478: While Loop Unrolled by 8  
         remark #25015: Estimate of max trip count of loop=4
      LOOP END
   LOOP END

   LOOP BEGIN at crc32.c(351,5) inlined into crc32.c(441,12)
      remark #17102: loop was not parallelized: not a parallelization candidate
      remark #15523: loop was not vectorized: loop control variable mat was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 8  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

crc32.c(440,1):remark #34051: REGISTER ALLOCATION : [crc32_combine64] crc32.c:440

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r8-r11]
        
    Routine temporaries
        Total         :     124
            Global    :      34
            Local     :      90
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :     512 bytes*
            Reads     :      52 [7.56e+02 ~ 10.7%]
            Writes    :       8 [2.46e+02 ~ 3.5%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: adler32_z()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (adler32_z()) [152/189=80.4%] adler32.c(67,1)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at adler32.c(92,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (93:13) and adler (93:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (93:13) and adler (93:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (93:13) and adler (93:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (93:13) and adler (93:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(92,9)
<Remainder>
LOOP END

LOOP BEGIN at adler32.c(103,5)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (107:13) and adler (110:9)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (110:9) and adler (107:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (110:9) and adler (107:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (107:13) and adler (110:9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (110:9)
   remark #15346: vector dependence: assumed FLOW dependence between adler (110:9) and adler (107:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (110:9) and adler (107:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (110:9)

   LOOP BEGIN at adler32.c(105,9)
      remark #17104: loop was not parallelized: existence of parallel dependence
      remark #17106: parallel dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #17106: parallel dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #17106: parallel dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #17106: parallel dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed FLOW dependence between adler (107:13) and adler (107:13)
      remark #15346: vector dependence: assumed ANTI dependence between adler (107:13) and adler (107:13)
   LOOP END
LOOP END

LOOP BEGIN at adler32.c(116,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #17106: parallel dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25427: Loop Statements Reordered
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (118:13) and adler (118:13)
   remark #15346: vector dependence: assumed ANTI dependence between adler (118:13) and adler (118:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at adler32.c(121,9)
   remark #17104: loop was not parallelized: existence of parallel dependence
   remark #17106: parallel dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #17106: parallel dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between adler (122:13) and adler (122:13)
   remark #15346: vector dependence: assumed FLOW dependence between adler (122:13) and adler (122:13)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at adler32.c(121,9)
<Remainder>
LOOP END

    Report from: Code generation optimizations [cg]

adler32.c(67,1):remark #34051: REGISTER ALLOCATION : [adler32_z] adler32.c:67

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   11[ rax rdx rcx rbx rbp rsi rdi r8-r11]
        
    Routine temporaries
        Total         :     202
            Global    :      31
            Local     :     171
        Regenerable   :       6
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      16 bytes*
            Reads     :       2 [1.62e-01 ~ 0.0%]
            Writes    :       2 [1.62e-01 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: adler32_combine()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (adler32_combine()) [153/189=81.0%] adler32.c(176,1)
  -> (177,12) adler32_combine_() (isz = 41) (sz = 53)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

adler32.c(176,1):remark #34051: REGISTER ALLOCATION : [adler32_combine] adler32.c:176

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rdx rsi rdi]
        
    Routine temporaries
        Total         :      15
            Global    :       0
            Local     :      15
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: adler32_combine_()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (adler32_combine_()) [154/189=81.5%] adler32.c(147,1)


    Report from: Code generation optimizations [cg]

adler32.c(147,1):remark #34051: REGISTER ALLOCATION : [adler32_combine_] adler32.c:147

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r8-r11]
        
    Routine temporaries
        Total         :      60
            Global    :      12
            Local     :      48
        Regenerable   :       7
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: adler32_combine64()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (adler32_combine64()) [155/189=82.0%] adler32.c(184,1)
  -> (185,12) adler32_combine_() (isz = 41) (sz = 53)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

adler32.c(184,1):remark #34051: REGISTER ALLOCATION : [adler32_combine64] adler32.c:184

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rdx rsi rdi]
        
    Routine temporaries
        Total         :      15
            Global    :       0
            Local     :      15
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: memcpy(void *__restrict__, const void *__restrict__, size_t)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (memcpy(void *__restrict__, const void *__restrict__, size_t))/usr/include/x86_64-linux-gnu/bits/string_fortified.h(33,1)

===========================================================================

Begin optimization report for: pqdownheap()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (pqdownheap()) trees.c(455,1)

===========================================================================

Begin optimization report for: gen_bitlen()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gen_bitlen()) trees.c(489,1)

===========================================================================

Begin optimization report for: gen_codes()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (gen_codes()) trees.c(576,1)

===========================================================================

Begin optimization report for: build_tree()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (build_tree()) trees.c(618,1)

===========================================================================

Begin optimization report for: scan_tree()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (scan_tree()) trees.c(707,1)

===========================================================================

Begin optimization report for: send_tree()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (send_tree()) trees.c(752,1)

===========================================================================

Begin optimization report for: build_bl_tree()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (build_bl_tree()) trees.c(801,1)

===========================================================================

Begin optimization report for: send_all_trees()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (send_all_trees()) trees.c(837,1)

===========================================================================

Begin optimization report for: _tr_tally()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (_tr_tally()) [165/189=87.3%] trees.c(1018,1)


    Report from: Code generation optimizations [cg]

trees.c(1018,1):remark #34051: REGISTER ALLOCATION : [_tr_tally] trees.c:1018

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rsi rdi r8]
        
    Routine temporaries
        Total         :      30
            Global    :      11
            Local     :      19
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: compress_block()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (compress_block()) trees.c(1068,1)

===========================================================================

Begin optimization report for: detect_data_type()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (detect_data_type()) trees.c(1126,1)

===========================================================================

Begin optimization report for: bi_reverse()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (bi_reverse()) trees.c(1161,1)

===========================================================================

Begin optimization report for: inflateReset2()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateReset2()) [169/189=89.4%] inflate.c(160,1)
  -> INLINE: (165,9) inflateStateCheck() (isz = 25) (sz = 34)
  -> INDIRECT-: (185,9)  strm_631_V$43.3.24->zfree_V$4d
     [[ Unable to inline indirect callsite  <3>]]
  -> (192,12) inflateReset() (isz = 40) (sz = 48)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

inflate.c(160,1):remark #34051: REGISTER ALLOCATION : [inflateReset2] inflate.c:160

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rsi rdi r12-r15]
        
    Routine temporaries
        Total         :      23
            Global    :      13
            Local     :      10
        Regenerable   :       2
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_error..5(gz_statep, int, const char *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_error..5(gz_statep, int, const char *)) [170/189=89.9%] gzlib.c(583,1)
  CLONED FROM: gz_error(gz_statep, int, const char *)(X,0,0x00000000,0x00000000)
  -> EXTERN: (587,13) free(void *)
  -> EXTERN: (605,31) malloc(size_t)
  -> EXTERN: (605,38) strlen(const char *)
  -> EXTERN: (605,60) strlen(const char *)
  -> INLINE: (611,11) snprintf(char *__restrict__, size_t, const char *__restrict__, ...) (isz = 10) (sz = 21)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(67,10) __builtin___snprintf_chk(char *, unsigned long, int, unsigned long, const char *, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,8) __builtin_object_size(const void *, int)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,28) __builtin_va_arg_pack(void)
  -> EXTERN: (611,32) strlen(const char *)
  -> EXTERN: (611,54) strlen(const char *)


    Report from: Code generation optimizations [cg]

gzlib.c(583,1):remark #34051: REGISTER ALLOCATION : [gz_error..5] gzlib.c:583

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rdx rbp rsi rdi]
        
    Routine temporaries
        Total         :      12
            Global    :       8
            Local     :       4
        Regenerable   :       0
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_error..4(gz_statep, int, const char *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_error..4(gz_statep, int, const char *)) [171/189=90.5%] gzlib.c(583,1)
  CLONED FROM: gz_error(gz_statep, int, const char *)(X,-3,X)
  -> EXTERN: (587,13) free(void *)
  -> EXTERN: (605,31) malloc(size_t)
  -> EXTERN: (605,38) strlen(const char *)
  -> EXTERN: (605,60) strlen(const char *)
  -> INLINE: (611,11) snprintf(char *__restrict__, size_t, const char *__restrict__, ...) (isz = 10) (sz = 21)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(67,10) __builtin___snprintf_chk(char *, unsigned long, int, unsigned long, const char *, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,8) __builtin_object_size(const void *, int)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,28) __builtin_va_arg_pack(void)
  -> EXTERN: (611,32) strlen(const char *)
  -> EXTERN: (611,54) strlen(const char *)


    Report from: Code generation optimizations [cg]

gzlib.c(583,1):remark #34051: REGISTER ALLOCATION : [gz_error..4] gzlib.c:583

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rbp rsi rdi r8-r9 r15]
        
    Routine temporaries
        Total         :      40
            Global    :      18
            Local     :      22
        Regenerable   :       5
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_error..3(gz_statep, int, const char *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_error..3(gz_statep, int, const char *)) [172/189=91.0%] gzlib.c(583,1)
  CLONED FROM: gz_error(gz_statep, int, const char *)(X,-5,X)
  -> EXTERN: (587,13) free(void *)
  -> EXTERN: (605,31) malloc(size_t)
  -> EXTERN: (605,38) strlen(const char *)
  -> EXTERN: (605,60) strlen(const char *)
  -> INLINE: (611,11) snprintf(char *__restrict__, size_t, const char *__restrict__, ...) (isz = 10) (sz = 21)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(67,10) __builtin___snprintf_chk(char *, unsigned long, int, unsigned long, const char *, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,8) __builtin_object_size(const void *, int)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,28) __builtin_va_arg_pack(void)
  -> EXTERN: (611,32) strlen(const char *)
  -> EXTERN: (611,54) strlen(const char *)


    Report from: Code generation optimizations [cg]

gzlib.c(583,1):remark #34051: REGISTER ALLOCATION : [gz_error..3] gzlib.c:583

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rbp rsi rdi r8-r9 r15]
        
    Routine temporaries
        Total         :      40
            Global    :      18
            Local     :      22
        Regenerable   :       5
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_error..2(gz_statep, int, const char *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_error..2(gz_statep, int, const char *)) [173/189=91.5%] gzlib.c(583,1)
  CLONED FROM: gz_error(gz_statep, int, const char *)(X,-4,X)
  -> EXTERN: (587,13) free(void *)
  -> EXTERN: (605,31) malloc(size_t)
  -> EXTERN: (605,38) strlen(const char *)
  -> EXTERN: (605,60) strlen(const char *)
  -> INLINE: (611,11) snprintf(char *__restrict__, size_t, const char *__restrict__, ...) (isz = 10) (sz = 21)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(67,10) __builtin___snprintf_chk(char *, unsigned long, int, unsigned long, const char *, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,8) __builtin_object_size(const void *, int)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,28) __builtin_va_arg_pack(void)
  -> EXTERN: (611,32) strlen(const char *)
  -> EXTERN: (611,54) strlen(const char *)


    Report from: Code generation optimizations [cg]

gzlib.c(583,1):remark #34051: REGISTER ALLOCATION : [gz_error..2] gzlib.c:583

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    5[ rdx rbp rsi rdi r12]
        
    Routine temporaries
        Total         :      13
            Global    :       9
            Local     :       4
        Regenerable   :       0
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_error..1(gz_statep, int, const char *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_error..1(gz_statep, int, const char *)) [174/189=92.1%] gzlib.c(583,1)
  CLONED FROM: gz_error(gz_statep, int, const char *)(X,-1,X)
  -> EXTERN: (587,13) free(void *)
  -> EXTERN: (605,31) malloc(size_t)
  -> EXTERN: (605,38) strlen(const char *)
  -> EXTERN: (605,60) strlen(const char *)
  -> INLINE: (611,11) snprintf(char *__restrict__, size_t, const char *__restrict__, ...) (isz = 10) (sz = 21)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(67,10) __builtin___snprintf_chk(char *, unsigned long, int, unsigned long, const char *, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,8) __builtin_object_size(const void *, int)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,28) __builtin_va_arg_pack(void)
  -> EXTERN: (611,32) strlen(const char *)
  -> EXTERN: (611,54) strlen(const char *)


    Report from: Code generation optimizations [cg]

gzlib.c(583,1):remark #34051: REGISTER ALLOCATION : [gz_error..1] gzlib.c:583

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rbp rsi rdi r8-r9 r15]
        
    Routine temporaries
        Total         :      40
            Global    :      18
            Local     :      22
        Regenerable   :       5
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_error..0(gz_statep, int, const char *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_error..0(gz_statep, int, const char *)) [175/189=92.6%] gzlib.c(583,1)
  CLONED FROM: gz_error(gz_statep, int, const char *)(X,-2,X)
  -> EXTERN: (587,13) free(void *)
  -> EXTERN: (605,31) malloc(size_t)
  -> EXTERN: (605,38) strlen(const char *)
  -> EXTERN: (605,60) strlen(const char *)
  -> INLINE: (611,11) snprintf(char *__restrict__, size_t, const char *__restrict__, ...) (isz = 10) (sz = 21)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(67,10) __builtin___snprintf_chk(char *, unsigned long, int, unsigned long, const char *, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,8) __builtin_object_size(const void *, int)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,28) __builtin_va_arg_pack(void)
  -> EXTERN: (611,32) strlen(const char *)
  -> EXTERN: (611,54) strlen(const char *)


    Report from: Code generation optimizations [cg]

gzlib.c(583,1):remark #34051: REGISTER ALLOCATION : [gz_error..0] gzlib.c:583

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rbp rsi rdi r8-r9 r15]
        
    Routine temporaries
        Total         :      40
            Global    :      18
            Local     :      22
        Regenerable   :       5
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateInit2_..0()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateInit2_..0()) [176/189=93.1%] inflate.c(200,1)
  CLONED FROM: inflateInit2_()(X,X,X,112)
  -> INDIRECT-: (224,13)  strm_643_V$47.3.25.3371->zalloc_V$4c
     [[ Unable to inline indirect callsite  <3>]]
  -> (231,11) inflateReset2() (isz = 74) (sz = 85)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (233,9)  strm_643_V$47.3.25.3371->zfree_V$4d
     [[ Unable to inline indirect callsite  <3>]]


    Report from: Code generation optimizations [cg]

inflate.c(200,1):remark #34051: REGISTER ALLOCATION : [inflateInit2_..0] inflate.c:200

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rcx rsi rdi r12-r14]
        
    Routine temporaries
        Total         :      31
            Global    :      15
            Local     :      16
        Regenerable   :       5
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: init_block()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (init_block()) [177/189=93.7%] trees.c(409,1)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at trees.c(413,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <s->freq[n]>, stride is 2   [ trees.c(413,36) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15453: unmasked strided stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 3.000 
   remark #15478: estimated potential speedup: 0.670 
   remark #15488: --- end vector cost summary ---
   remark #25438: unrolled without remainder by 2  
   remark #25015: Estimate of max trip count of loop=286
LOOP END

LOOP BEGIN at trees.c(414,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <s->freq[n]>, stride is 2   [ trees.c(414,36) ]
   remark #15305: vectorization support: vector length 2
   remark #15453: unmasked strided stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 3.000 
   remark #15478: estimated potential speedup: 0.660 
   remark #15488: --- end vector cost summary ---
   remark #25438: unrolled without remainder by 2  
   remark #25015: Estimate of max trip count of loop=30
LOOP END

LOOP BEGIN at trees.c(415,5)
   remark #17108: loop was not parallelized: insufficient computational work
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <s->freq[n]>, stride is 2   [ trees.c(415,36) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 9
   remark #15453: unmasked strided stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 3.000 
   remark #15478: estimated potential speedup: 0.670 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=19
LOOP END

LOOP BEGIN at trees.c(415,5)
<Remainder>
   remark #25015: Estimate of max trip count of loop=19
LOOP END

    Report from: Code generation optimizations [cg]

trees.c(409,1):remark #34051: REGISTER ALLOCATION : [init_block] trees.c:409

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rcx rdi]
        
    Routine temporaries
        Total         :      14
            Global    :      12
            Local     :       2
        Regenerable   :       3
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: tr_static_init()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (tr_static_init()) trees.c(233,1)

===========================================================================

Begin optimization report for: gz_init()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_init()) [179/189=94.7%] gzwrite.c(19,1)
  -> EXTERN: (24,34) malloc(size_t)
  -> CP_CLONE (26,9) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (33,39) malloc(size_t)
  -> EXTERN: (35,13) free(void *)
  -> CP_CLONE (36,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (44,15) deflateInit2_() (isz = 223) (sz = 249)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (47,13) free(void *)
  -> EXTERN: (48,13) free(void *)
  -> CP_CLONE (49,13) gz_error..2(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzwrite.c(19,1):remark #34051: REGISTER ALLOCATION : [gz_init] gzwrite.c:19

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r8-r9 r14-r15]
        
    Routine temporaries
        Total         :      55
            Global    :      15
            Local     :      40
        Regenerable   :      17
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzclearerr()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzclearerr()) [180/189=95.2%] gzlib.c(555,1)
  -> CP_CLONE (570,5) gz_error..5(gz_statep, int, const char *) (isz = 59) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

gzlib.c(555,1):remark #34051: REGISTER ALLOCATION : [gzclearerr] gzlib.c:555

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      13
            Global    :       8
            Local     :       5
        Regenerable   :       3
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gz_error(gz_statep, int, const char *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gz_error(gz_statep, int, const char *)) [181/189=95.8%] gzlib.c(583,1)
  -> EXTERN: (587,13) free(void *)
  -> EXTERN: (605,31) malloc(size_t)
  -> EXTERN: (605,38) strlen(const char *)
  -> EXTERN: (605,60) strlen(const char *)
  -> INLINE: (611,11) snprintf(char *__restrict__, size_t, const char *__restrict__, ...) (isz = 10) (sz = 21)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(67,10) __builtin___snprintf_chk(char *, unsigned long, int, unsigned long, const char *, ...)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,8) __builtin_object_size(const void *, int)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdio2.h:(68,28) __builtin_va_arg_pack(void)
  -> EXTERN: (611,32) strlen(const char *)
  -> EXTERN: (611,54) strlen(const char *)


    Report from: Code generation optimizations [cg]

gzlib.c(583,1):remark #34051: REGISTER ALLOCATION : [gz_error] gzlib.c:583

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   10[ rax rdx rcx rsi rdi r8-r9 r12-r13 r15]
        
    Routine temporaries
        Total         :      41
            Global    :      19
            Local     :      22
        Regenerable   :       5
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: lm_init()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (lm_init()) [182/189=96.3%] deflate.c(1196,1)
  -> INLINE (MANUAL): (1199,5) memset(void *, int, size_t) (isz = 6) (sz = 17)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,10) __builtin___memset_chk(void *, int, unsigned long, unsigned long)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/string_fortified.h:(71,55) __builtin_object_size(const void *, int)


    Report from: Code generation optimizations [cg]

/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
/usr/include/x86_64-linux-gnu/bits/string_fortified.h(71,10):remark #34026: call to memset implemented as a call to optimized library version
deflate.c(1196,1):remark #34051: REGISTER ALLOCATION : [lm_init] deflate.c:1196

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rcx rbp rsi rdi r8 r12]
        
    Routine temporaries
        Total         :      26
            Global    :       8
            Local     :      18
        Regenerable   :       3
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateInit2_()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateInit2_()) [183/189=96.8%] deflate.c(250,1)
  -> INDIRECT-: (304,27)  strm_642_V$72.4.50->zalloc_V$4c
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (321,27)  strm_642_V$72.4.50->zalloc_V$4c
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (322,27)  strm_642_V$72.4.50->zalloc_V$4c
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (323,27)  strm_642_V$72.4.50->zalloc_V$4c
     [[ Unable to inline indirect callsite  <3>]]
  -> INDIRECT-: (329,24)  strm_642_V$72.4.50->zalloc_V$4c
     [[ Unable to inline indirect callsite  <3>]]
  -> (337,9) deflateEnd(z_streamp) (isz = 63) (sz = 71)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INLINE: (347,12) deflateReset() (isz = 7) (sz = 14)
    -> (510,11) deflateResetKeep() (isz = 397) (sz = 405)
       [[ Callee not marked with inlining pragma  <1>]]
    -> (512,9) lm_init() (isz = 55) (sz = 60)
       [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

deflate.c(250,1):remark #34051: REGISTER ALLOCATION : [deflateInit2_] deflate.c:250

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   14[ rax rdx rcx rbx rbp rsi rdi r8-r10 r12-r15]
        
    Routine temporaries
        Total         :      97
            Global    :      32
            Local     :      65
        Regenerable   :      17
        Spilled       :       7
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       8 bytes*
            Reads     :       1 [5.40e-03 ~ 0.0%]
            Writes    :       1 [5.40e-03 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: _tr_init(deflate_state *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (_tr_init(deflate_state *)) [184/189=97.4%] trees.c(381,1)
  -> DELETED: (382,5) tr_static_init() (isz = 0) (sz = 2)
  -> (401,5) init_block() (isz = 39) (sz = 44)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

trees.c(381,1):remark #34051: REGISTER ALLOCATION : [_tr_init] trees.c:381

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    5[ rax rdx rcx rsi rdi]
        
    Routine temporaries
        Total         :      13
            Global    :       0
            Local     :      13
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateInit2_()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateInit2_()) [185/189=97.9%] inflate.c(200,1)
  -> INDIRECT-: (224,13)  strm_643_V$47.3.25->zalloc_V$4c
     [[ Unable to inline indirect callsite  <3>]]
  -> (231,11) inflateReset2() (isz = 74) (sz = 85)
     [[ Callee not marked with inlining pragma  <1>]]
  -> INDIRECT-: (233,9)  strm_643_V$47.3.25->zfree_V$4d
     [[ Unable to inline indirect callsite  <3>]]


    Report from: Code generation optimizations [cg]

inflate.c(200,1):remark #34051: REGISTER ALLOCATION : [inflateInit2_] inflate.c:200

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rcx rbp rsi rdi r12-r13]
        
    Routine temporaries
        Total         :      32
            Global    :      16
            Local     :      16
        Regenerable   :       5
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: zError()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (zError()) [186/189=98.4%] zutil.c(135,1)


    Report from: Code generation optimizations [cg]

zutil.c(135,1):remark #34051: REGISTER ALLOCATION : [zError] zutil.c:135

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :      12
            Global    :       0
            Local     :      12
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: inflateInit_(z_streamp, const char *, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (inflateInit_(z_streamp, const char *, int)) [187/189=98.9%] inflate.c(243,1)
  -> (244,12) inflateInit2_() (isz = 58) (sz = 74)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

inflate.c(243,1):remark #34051: REGISTER ALLOCATION : [inflateInit_] inflate.c:243

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rdx rcx rsi rdi]
        
    Routine temporaries
        Total         :      16
            Global    :       0
            Local     :      16
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: deflateInit_(z_streamp, int, const char *, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (deflateInit_(z_streamp, int, const char *, int)) [188/189=99.5%] deflate.c(233,1)
  -> (234,12) deflateInit2_() (isz = 223) (sz = 249)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Code generation optimizations [cg]

deflate.c(233,1):remark #34051: REGISTER ALLOCATION : [deflateInit_] deflate.c:233

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rcx rsi rdi r8-r9]
        
    Routine temporaries
        Total         :      24
            Global    :       8
            Local     :      16
        Regenerable   :       4
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gzerror(gzFile, int *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gzerror(gzFile, int *)) [189/189=100.0%] gzlib.c(535,1)


    Report from: Code generation optimizations [cg]

gzlib.c(535,1):remark #34051: REGISTER ALLOCATION : [gzerror] gzlib.c:535

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      18
            Global    :      10
            Local     :       8
        Regenerable   :       3
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

    Report from: Profile guided optimizations [pgo]



Profile feedback used a statically estimated profile for the following routines:

  File: adler32.c
        adler32_z()                                                       [Line    67]
        adler32(uLong, const Bytef *, uInt)                               [Line   138]
        adler32_combine_()                                                [Line   147]
        adler32_combine()                                                 [Line   176]
        adler32_combine64()                                               [Line   184]

  File: compress.c
        compress2()                                                       [Line    28]
        compress(Bytef *, uLongf *, const Bytef *, uLong)                 [Line    73]
        compressBound()                                                   [Line    83]

  File: crc32.c
        get_crc_table()                                                   [Line   189]
        crc32_z()                                                         [Line   206]
        crc32(uLong, const Bytef *, uInt)                                 [Line   241]
        crc32_combine()                                                   [Line   432]
        crc32_combine64()                                                 [Line   440]

  File: deflate.c
        deflateInit_(z_streamp, int, const char *, int)                   [Line   233]
        deflateInit2_()                                                   [Line   250]
        deflateStateCheck()                                               [Line   355]
        deflateSetDictionary(z_streamp, const Bytef *, uInt)              [Line   380]
        deflateGetDictionary()                                            [Line   449]
        deflateResetKeep()                                                [Line   469]
        deflateReset()                                                    [Line   507]
        deflateSetHeader()                                                [Line   520]
        deflatePending()                                                  [Line   532]
        deflatePrime()                                                    [Line   546]
        deflateParams(z_streamp, int, int)                                [Line   572]
        deflateTune()                                                     [Line   623]
        deflateBound()                                                    [Line   655]
        flush_pending()                                                   [Line   732]
        deflate(z_streamp, int)                                           [Line   766]
        deflate..1(z_streamp, int)                                        [Line   766]
        deflate..0(z_streamp, int)                                        [Line   766]
        deflateEnd(z_streamp)                                             [Line  1078]
        deflateCopy()                                                     [Line  1105]
        read_buf()                                                        [Line  1168]
        lm_init()                                                         [Line  1196]
        longest_match()                                                   [Line  1239]
        fill_window()                                                     [Line  1484]
        deflate_stored()                                                  [Line  1646]
        deflate_fast()                                                    [Line  1827]
        deflate_slow()                                                    [Line  1929]
        deflate_huff()                                                    [Line  2133]

  File: gzclose.c
        gzclose(gzFile)                                                   [Line    13]

  File: gzlib.c
        gzopen(const char *, const char *)                                [Line   273]
        gzopen64()                                                        [Line   281]
        gzdopen()                                                         [Line   289]
        gzbuffer()                                                        [Line   319]
        gzrewind()                                                        [Line   345]
        gzrewind..0()                                                     [Line   345]
        gzseek64()                                                        [Line   370]
        gzseek(gzFile, off_t, int)                                        [Line   447]
        gztell64()                                                        [Line   457]
        gztell(gzFile)                                                    [Line   474]
        gzoffset64()                                                      [Line   484]
        gzoffset()                                                        [Line   507]
        gzeof()                                                           [Line   517]
        gzerror(gzFile, int *)                                            [Line   535]
        gzclearerr()                                                      [Line   555]
        gz_error..4(gz_statep, int, const char *)                         [Line   583]
        gz_error..3(gz_statep, int, const char *)                         [Line   583]
        gz_error..5(gz_statep, int, const char *)                         [Line   583]
        gz_error..0(gz_statep, int, const char *)                         [Line   583]
        gz_error..1(gz_statep, int, const char *)                         [Line   583]
        gz_error..2(gz_statep, int, const char *)                         [Line   583]
        gz_error(gz_statep, int, const char *)                            [Line   583]

  File: gzread.c
        gz_look()                                                         [Line    93]
        gz_fetch()                                                        [Line   231]
        gz_skip()                                                         [Line   262]
        gzread(gzFile, voidp, unsigned int)                               [Line   379]
        gzfread()                                                         [Line   416]
        gzgetc(gzFile)                                                    [Line   449]
        gzgetc..0(gzFile)                                                 [Line   449]
        gzgetc_()                                                         [Line   478]
        gzungetc(int, gzFile)                                             [Line   486]
        gzungetc..0(int, gzFile)                                          [Line   486]
        gzgets(gzFile, char *, int)                                       [Line   547]
        gzdirect()                                                        [Line   609]
        gzclose_r()                                                       [Line   629]
        gzclose_r..0()                                                    [Line   629]

  File: gzwrite.c
        gz_init()                                                         [Line    19]
        gz_comp..0()                                                      [Line    76]
        gz_zero()                                                         [Line   148]
        gz_write..0()                                                     [Line   182]
        gzwrite()                                                         [Line   250]
        gzfwrite()                                                        [Line   279]
        gzputc(gzFile, int)                                               [Line   307]
        gzputs..0(gzFile, const char *)                                   [Line   355]
        gzputs(gzFile, const char *)                                      [Line   355]
        gzvprintf(gzFile, const char *, struct __va_list_tag *)           [Line   380]
        gzprintf(gzFile, const char *, ...)                               [Line   452]
        gzflush()                                                         [Line   556]
        gzsetparams()                                                     [Line   589]
        gzclose_w..0(gzFile)                                              [Line   629]
        gzclose_w(gzFile)                                                 [Line   629]

  File: inffast.c
        inflate_fast(z_streamp, unsigned int)                             [Line    53]

  File: inflate.c
        inflateResetKeep()                                                [Line   121]
        inflateReset()                                                    [Line   146]
        inflateReset2()                                                   [Line   160]
        inflateInit2_()                                                   [Line   200]
        inflateInit2_..0()                                                [Line   200]
        inflateInit_(z_streamp, const char *, int)                        [Line   243]
        inflatePrime()                                                    [Line   251]
        updatewindow()                                                    [Line   400]
        inflate(z_streamp, int)                                           [Line   625]
        inflate..0(z_streamp, int)                                        [Line   625]
        inflateEnd(z_streamp)                                             [Line  1279]
        inflateGetDictionary()                                            [Line  1295]
        inflateSetDictionary(z_streamp, const Bytef *, uInt)              [Line  1318]
        inflateGetHeader()                                                [Line  1352]
        inflateSync(z_streamp)                                            [Line  1402]
        inflateSyncPoint()                                                [Line  1453]
        inflateCopy()                                                     [Line  1464]
        inflateUndermine()                                                [Line  1511]
        inflateValidate()                                                 [Line  1529]
        inflateMark()                                                     [Line  1543]
        inflateCodesUsed()                                                [Line  1556]

  File: inftrees.c
        inflate_table(codetype, unsigned short *, unsigned int, code **, unsigned int *, unsigned short *)[Line    39]

  File: test/example.c
        test_compress()                                                   [Line    91]
        test_gzio()                                                       [Line   118]
        test_deflate()                                                    [Line   203]
        test_inflate()                                                    [Line   241]
        test_large_deflate()                                              [Line   282]
        test_large_inflate()                                              [Line   337]
        test_flush()                                                      [Line   378]
        test_sync()                                                       [Line   416]
        test_dict_deflate()                                               [Line   460]
        test_dict_inflate()                                               [Line   497]
        main()                                                            [Line   548]

  File: trees.c
        _tr_init(deflate_state *)                                         [Line   381]
        init_block()                                                      [Line   409]
        _tr_stored_block(deflate_state *, charf *, ulg, int)              [Line   868]
        _tr_flush_bits(deflate_state *)                                   [Line   888]
        _tr_align(deflate_state *)                                        [Line   898]
        _tr_flush_block(deflate_state *, charf *, ulg, int)               [Line   916]
        _tr_flush_block..1(deflate_state *, charf *, ulg, int)            [Line   916]
        _tr_flush_block..0(deflate_state *, charf *, ulg, int)            [Line   916]
        _tr_tally()                                                       [Line  1018]
        bi_flush()                                                        [Line  1175]
        bi_windup()                                                       [Line  1192]

  File: uncompr.c
        uncompress2()                                                     [Line    32]
        uncompress(Bytef *, uLongf *, const Bytef *, uLong)               [Line    91]

  File: zutil.c
        zlibVersion(void)                                                 [Line    28]
        zlibCompileFlags(void)                                            [Line    33]
        zError()                                                          [Line   135]
        zcalloc()                                                         [Line   309]
        zcfree()                                                          [Line   318]


  0 out of 144 routine(s) used training profile data for PGO feedback
  0 out of 144 routine(s) were unable to use training profile data for PGO feedback
  0 out of 144 routine(s) were unable to find training profile data for PGO feedback
  144 out of 144 routine(s) used a static estimate profile for PGO feedback




    Report from: Interprocedural optimizations [ipo]

INLINING FOOTNOTES:

<1> The compiler's heuristics indicate that the function is not profitable to 
    inline.  Override this decision by adding "inline 
    __attribute__((always_inline))" to the declaration of the called function, 
    or add "#pragma forceinline" before the call site.

<2> The compiler's heuristics predict that it is not profitable to inline the
    call.  Add "inline __attribute__((always_inline))" to the declaration of
    the called function or add "#pragma forceinline" before the call site.

<3> The indirectly called function must be resolved to its targets before it 
can be inlined.  Consider compiling with -ipo or -prof-gen followed by 
-prof-use.

<4> Inlining the function will lead to incorrect program behavior.

